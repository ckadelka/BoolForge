# Dynamics of Boolean Networks

In this tutorial, we study the *dynamics* of Boolean networks.
Building on the construction and structural analysis from previous tutorials,
we now focus on how Boolean networks evolve over time and how their long-term
behavior can be characterized.

You will learn how to:

- simulate Boolean network dynamics under different updating schemes,
- compute and classify attractors,
- analyze basins of attraction,
- relate network structure to dynamical behavior.

## Setup


```python
import boolforge
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
```

## State space of a Boolean network

A Boolean network with $N$ nodes defines a dynamical system on the discrete
state space $\{0,1\}^N$.

Each state is a binary vector

$$
\mathbf{x} = (x_0, \ldots, x_{N-1}) \in \{0,1\}^N,
$$

where $x_i$ denotes the state of node $i$.

We use a small Boolean network as a running example.


```python
string = """
x = y
y = x OR z
z = y
"""

bn = boolforge.BooleanNetwork.from_string(string, separator="=")

print("Variables:", bn.variables)
print("N:", bn.N)
print("bn.I:", bn.I)
print("bn.F:", bn.F)
```

    Variables: ['x' 'y' 'z']
    N: 3
    bn.I: [array([1]), array([0, 2]), array([1])]
    bn.F: [BooleanFunction(f=[0, 1]), BooleanFunction(f=[0, 1, 1, 1]), BooleanFunction(f=[0, 1])]


All state vectors follow the variable order given by `bn.variables`.
For small networks, we can enumerate all $2^N$ states explicitly.


```python
all_states = boolforge.get_left_side_of_truth_table(bn.N)
pd.DataFrame(all_states, columns=bn.variables)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>x</th>
      <th>y</th>
      <th>z</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>6</th>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>7</th>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



## Dynamics of synchronous Boolean networks

Under *synchronous updating*, all nodes are updated simultaneously, defining
a deterministic update map

$$
\mathbf{x}(t+1) = F(\mathbf{x}(t)).
$$

### Exact computation


```python
for state in all_states:
    print(state, "-->", bn.update_network_synchronously(state))
```

    [0 0 0] --> [0 0 0]
    [0 0 1] --> [0 1 0]
    [0 1 0] --> [1 0 1]
    [0 1 1] --> [1 1 1]
    [1 0 0] --> [0 1 0]
    [1 0 1] --> [0 1 0]
    [1 1 0] --> [1 1 1]
    [1 1 1] --> [1 1 1]


This output matches the synchronous truth table representation:


```python
print(bn.to_truth_table().to_string())
```

       x(t)  y(t)  z(t)  x(t+1)  y(t+1)  z(t+1)
    0     0     0     0       0       0       0
    1     0     0     1       0       1       0
    2     0     1     0       1       0       1
    3     0     1     1       1       1       1
    4     1     0     0       0       1       0
    5     1     0     1       0       1       0
    6     1     1     0       1       1       1
    7     1     1     1       1       1       1


Each state has exactly one successor, so the dynamics consist of transient
trajectories leading into *attractors* (steady states or cycles).

In this example, the network has:

- two steady states: $(0,0,0)$ and $(1,1,1)$,
- one cyclic attractor of length 2: $(0,1,0) \leftrightarrow (1,0,1)$.

### Exhaustive attractor computation


```python
dict_dynamics = bn.get_attractors_synchronous_exact()
dict_dynamics
```




    {'Attractors': [[0], [2, 5], [7]],
     'NumberOfAttractors': 3,
     'BasinSizes': array([0.125, 0.5  , 0.375]),
     'AttractorID': array([0, 1, 1, 2, 1, 1, 2, 2], dtype=int32),
     'STG': array([0, 2, 5, 7, 2, 2, 7, 7])}



The returned dictionary contains:

- `STG`: the synchronous state transition graph,
- `NumberOfAttractors`,
- `Attractors`,
- `AttractorDict`,
- `BasinSizes`.

The state transition graph can be decoded as follows:


```python
for state in range(2 ** bn.N):
    next_state = dict_dynamics["STG"][state]
    print(
        state,
        "=",
        boolforge.dec2bin(state, bn.N),
        "-->",
        next_state,
        "=",
        boolforge.dec2bin(next_state, bn.N),
    )
```

    0 = [0, 0, 0] --> 0 = [0, 0, 0]
    1 = [0, 0, 1] --> 2 = [0, 1, 0]
    2 = [0, 1, 0] --> 5 = [1, 0, 1]
    3 = [0, 1, 1] --> 7 = [1, 1, 1]
    4 = [1, 0, 0] --> 2 = [0, 1, 0]
    5 = [1, 0, 1] --> 2 = [0, 1, 0]
    6 = [1, 1, 0] --> 7 = [1, 1, 1]
    7 = [1, 1, 1] --> 7 = [1, 1, 1]


Attractors can be printed in binary representation:


```python
for attractor in dict_dynamics["Attractors"]:
    print(f"Attractor of length {len(attractor)}:")
    for state in attractor:
        print(state, boolforge.dec2bin(state, bn.N))
    print()
```

    Attractor of length 1:
    0 [0, 0, 0]
    
    Attractor of length 2:
    2 [0, 1, 0]
    5 [1, 0, 1]
    
    Attractor of length 1:
    7 [1, 1, 1]
    


Basin sizes count how many states flow into each attractor.
They always sum to $2^N$.

### Monte Carlo simulation

For larger networks, exhaustive enumeration is infeasible.
Monte Carlo simulation approximates the attractor landscape.


```python
dict_dynamics = bn.get_attractors_synchronous(n_simulations=100)
dict_dynamics
```




    {'Attractors': [[2, 5], [7], [0]],
     'NumberOfAttractors': 3,
     'BasinSizes': [50, 38, 12],
     'AttractorDict': {2: 0, 5: 0, 7: 1, 1: 0, 4: 0, 3: 1, 0: 2, 6: 1},
     'InitialSamplePoints': [2,
      7,
      5,
      1,
      7,
      5,
      1,
      1,
      4,
      3,
      0,
      2,
      7,
      4,
      5,
      4,
      5,
      1,
      0,
      4,
      2,
      4,
      4,
      6,
      0,
      6,
      3,
      4,
      6,
      4,
      7,
      3,
      3,
      6,
      6,
      6,
      6,
      7,
      1,
      6,
      3,
      0,
      2,
      0,
      4,
      7,
      6,
      3,
      3,
      5,
      5,
      5,
      6,
      4,
      1,
      2,
      1,
      4,
      0,
      0,
      5,
      6,
      0,
      6,
      2,
      1,
      5,
      7,
      7,
      0,
      7,
      7,
      1,
      6,
      7,
      7,
      0,
      1,
      2,
      0,
      2,
      0,
      2,
      1,
      1,
      7,
      1,
      2,
      2,
      1,
      7,
      7,
      5,
      7,
      2,
      2,
      3,
      1,
      7,
      1],
     'STG': {2: 5, 7: 7, 5: 2, 1: 2, 4: 2, 3: 7, 0: 0, 6: 7},
     'NumberOfTimeouts': 0}



The simulation returns additional information:

- sampled initial states,
- the number of timeouts (trajectories not reaching an attractor in time).

If an attractor has relative basin size $q$, the probability that it is found
after $m$ random initializations is $1 - (1-q)^m$.


```python
qs = [0.0001, 0.001, 0.01, 0.1]
ms = np.logspace(0, 4, 1000)

fig, ax = plt.subplots()
for q in qs:
    ax.semilogx(ms, 1 - (1 - q) ** ms, label=str(q))

ax.legend(title=r"$q$", frameon=False)
ax.set_xlabel("number of initial states ($m$)")
ax.set_ylabel("probability attractor is found")
plt.show()
```


    
![png](tutorial07_boolean_network_dynamics_files/tutorial07_boolean_network_dynamics_22_0.png)
    


## Dynamics of asynchronous Boolean networks

Synchronous updating is computationally convenient but biologically unrealistic.
Asynchronous updating assumes that only one node is updated at a time.

### Steady states under general asynchronous update

BoolForge can compute steady states under general asynchronous updating.


```python
dict_dynamics = bn.get_steady_states_asynchronous_exact()
dict_dynamics
```




    {'SteadyStates': [0, 7],
     'NumberOfSteadyStates': 2,
     'BasinSizes': array([0.33333333, 0.66666667]),
     'STGAsynchronous': {0: {0: np.float64(1.0)},
      1: {1: np.float64(0.3333333333333333),
       3: np.float64(0.3333333333333333),
       0: np.float64(0.3333333333333333)},
      2: {6: np.float64(0.3333333333333333),
       0: np.float64(0.3333333333333333),
       3: np.float64(0.3333333333333333)},
      3: {7: np.float64(0.3333333333333333), 3: np.float64(0.6666666666666666)},
      4: {0: np.float64(0.3333333333333333),
       6: np.float64(0.3333333333333333),
       4: np.float64(0.3333333333333333)},
      5: {1: np.float64(0.3333333333333333),
       7: np.float64(0.3333333333333333),
       4: np.float64(0.3333333333333333)},
      6: {6: np.float64(0.6666666666666666), 7: np.float64(0.3333333333333333)},
      7: {7: np.float64(1.0)}},
     'FinalTransitionProbabilities': array([[1.        , 0.        ],
            [0.5       , 0.5       ],
            [0.33333333, 0.66666667],
            [0.        , 1.        ],
            [0.5       , 0.5       ],
            [0.33333333, 0.66666667],
            [0.        , 1.        ],
            [0.        , 1.        ]])}



This reveals the same two steady states as in the synchronous case.
In addition, the full asynchronous transition graph and absorption
probabilities are returned.

BoolForge currently does not detect complex cyclic attractors under
asynchronous updating; for those, specialized tools such as
`pystablemotifs` are recommended.

### Monte Carlo approximation


```python
dict_dynamics = bn.get_steady_states_asynchronous(n_simulations=500)
dict_dynamics
```




    {'SteadyStates': [7, 0],
     'NumberOfSteadyStates': 2,
     'BasinSizes': [344, 156],
     'STGAsynchronous': {(6, 1): 6,
      (6, 0): 6,
      (6, 2): 7,
      (7, 1): 7,
      (7, 0): 7,
      (7, 2): 7,
      (4, 0): 0,
      (0, 1): 0,
      (0, 2): 0,
      (0, 0): 0,
      (4, 1): 6,
      (5, 2): 4,
      (2, 2): 3,
      (3, 0): 7,
      (3, 1): 3,
      (3, 2): 3,
      (4, 2): 4,
      (1, 2): 0,
      (1, 0): 1,
      (2, 0): 6,
      (1, 1): 3,
      (5, 0): 1,
      (5, 1): 7,
      (2, 1): 0},
     'InitialSamplePoints': [6,
      4,
      4,
      0,
      5,
      2,
      3,
      2,
      7,
      4,
      3,
      0,
      7,
      1,
      4,
      1,
      0,
      7,
      7,
      1,
      1,
      6,
      2,
      4,
      1,
      1,
      2,
      1,
      4,
      3,
      2,
      7,
      7,
      5,
      5,
      3,
      0,
      0,
      7,
      1,
      3,
      3,
      6,
      3,
      1,
      4,
      2,
      4,
      6,
      2,
      2,
      0,
      5,
      0,
      2,
      5,
      2,
      3,
      1,
      0,
      4,
      1,
      6,
      4,
      3,
      3,
      7,
      4,
      1,
      6,
      5,
      7,
      2,
      5,
      6,
      4,
      7,
      0,
      3,
      2,
      6,
      4,
      6,
      4,
      5,
      5,
      6,
      2,
      1,
      0,
      2,
      2,
      6,
      4,
      2,
      2,
      2,
      0,
      7,
      7,
      6,
      7,
      3,
      2,
      4,
      0,
      4,
      3,
      1,
      1,
      4,
      5,
      6,
      4,
      5,
      5,
      2,
      3,
      3,
      5,
      4,
      5,
      2,
      3,
      0,
      0,
      1,
      1,
      6,
      4,
      7,
      3,
      7,
      6,
      0,
      0,
      5,
      1,
      1,
      4,
      5,
      1,
      4,
      6,
      5,
      3,
      6,
      0,
      4,
      0,
      7,
      4,
      0,
      5,
      7,
      0,
      6,
      0,
      3,
      1,
      6,
      3,
      2,
      1,
      3,
      3,
      4,
      7,
      0,
      0,
      6,
      7,
      5,
      7,
      5,
      2,
      3,
      7,
      7,
      5,
      3,
      0,
      5,
      5,
      7,
      6,
      0,
      2,
      4,
      2,
      2,
      0,
      7,
      0,
      5,
      3,
      6,
      2,
      5,
      2,
      2,
      7,
      2,
      6,
      3,
      5,
      6,
      7,
      6,
      3,
      7,
      4,
      6,
      7,
      6,
      3,
      4,
      1,
      3,
      3,
      2,
      7,
      7,
      3,
      7,
      2,
      1,
      1,
      3,
      6,
      3,
      1,
      6,
      0,
      4,
      0,
      4,
      6,
      5,
      2,
      1,
      6,
      2,
      2,
      0,
      7,
      5,
      7,
      1,
      2,
      3,
      6,
      2,
      1,
      7,
      3,
      2,
      2,
      2,
      6,
      7,
      4,
      4,
      3,
      2,
      7,
      1,
      3,
      0,
      5,
      3,
      5,
      7,
      6,
      0,
      7,
      1,
      6,
      7,
      3,
      0,
      0,
      0,
      7,
      1,
      0,
      5,
      1,
      2,
      5,
      2,
      3,
      4,
      3,
      6,
      4,
      5,
      3,
      3,
      0,
      2,
      4,
      7,
      2,
      1,
      4,
      0,
      0,
      3,
      4,
      5,
      3,
      1,
      6,
      2,
      5,
      0,
      7,
      6,
      6,
      2,
      1,
      2,
      1,
      2,
      3,
      0,
      4,
      4,
      3,
      7,
      0,
      1,
      6,
      2,
      7,
      7,
      3,
      6,
      0,
      2,
      1,
      1,
      5,
      6,
      0,
      5,
      4,
      7,
      2,
      7,
      5,
      6,
      0,
      6,
      6,
      4,
      5,
      7,
      6,
      5,
      5,
      2,
      2,
      5,
      3,
      2,
      1,
      3,
      7,
      2,
      3,
      2,
      0,
      7,
      6,
      3,
      0,
      1,
      4,
      0,
      5,
      7,
      0,
      2,
      2,
      2,
      6,
      4,
      0,
      1,
      4,
      1,
      3,
      1,
      7,
      0,
      6,
      6,
      1,
      4,
      6,
      5,
      5,
      7,
      1,
      1,
      5,
      5,
      3,
      3,
      6,
      5,
      5,
      3,
      5,
      5,
      2,
      6,
      0,
      5,
      4,
      7,
      3,
      3,
      2,
      7,
      6,
      5,
      5,
      4,
      6,
      7,
      5,
      5,
      5,
      3,
      3,
      7,
      7,
      4,
      6,
      7,
      7,
      0,
      5,
      7,
      1,
      0,
      7,
      2,
      0,
      0,
      7,
      3,
      6,
      3,
      2,
      6,
      4,
      7,
      4,
      0,
      5,
      0,
      1,
      2,
      0,
      0,
      1,
      6,
      5,
      6,
      5,
      4,
      2,
      5,
      3,
      7,
      3,
      1,
      6,
      5,
      7,
      5,
      7,
      5,
      2,
      6,
      3,
      0,
      1,
      4,
      7,
      0,
      2,
      4,
      4,
      5,
      1]}



The simulation provides:

- a lower bound on the number of steady states,
- approximate basin size distributions,
- samples of the asynchronous state transition graph.

### Sampling from a fixed initial condition


```python
dict_dynamics = bn.get_steady_states_asynchronous_given_one_initial_condition(
    initial_condition=[0, 0, 1], n_simulations=500
)
dict_dynamics
```




    {'SteadyStates': [0, 7, 9, 2],
     'NumberOfSteadyStates': 4,
     'BasinSizes': [246, 132, 36, 86],
     'TransientTimes': [[1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1],
      [2,
       3,
       2,
       2,
       2,
       3,
       3,
       2,
       2,
       2,
       2,
       2,
       3,
       2,
       2,
       2,
       3,
       2,
       3,
       2,
       2,
       3,
       3,
       2,
       3,
       2,
       2,
       3,
       2,
       2,
       2,
       3,
       3,
       2,
       3,
       2,
       3,
       3,
       2,
       3,
       2,
       3,
       2,
       2,
       3,
       2,
       3,
       3,
       2,
       2,
       3,
       3,
       2,
       2,
       3,
       3,
       3,
       2,
       3,
       3,
       2,
       3,
       3,
       3,
       2,
       2,
       3,
       2,
       2,
       2,
       2,
       2,
       2,
       3,
       3,
       2,
       3,
       3,
       3,
       3,
       2,
       2,
       3,
       2,
       3,
       2,
       2,
       3,
       3,
       2,
       2,
       3,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       3,
       2,
       3,
       2,
       2,
       2,
       2,
       3,
       2,
       2,
       2,
       2,
       3,
       3,
       2,
       3,
       3,
       2,
       2,
       2,
       2,
       2,
       2,
       3,
       3,
       2,
       2,
       2,
       3,
       3,
       2,
       3],
      [3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3],
      [2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2]],
     'STGAsynchronous': {(1, 2): 0,
      (0, 2): 0,
      (0, 1): 0,
      (0, 0): 0,
      (1, 1): 3,
      (3, 0): 7,
      (7, 2): 7,
      (7, 1): 7,
      (7, 0): 7,
      (1, 0): 1,
      (3, 1): 5,
      (5, 2): 5,
      (5, 0): 9,
      (9, 0): 9,
      (9, 2): 9,
      (9, 1): 9,
      (3, 2): 2,
      (2, 0): 2,
      (2, 1): 2,
      (2, 2): 2,
      (5, 1): 7},
     'UpdateQueues': [[1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 3, 5, 9],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 5, 7],
      [1, 3, 2],
      [1, 3, 5, 9],
      [1, 3, 2],
      [1, 3, 7],
      [1, 3, 7],
      [1, 3, 2],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 3, 5, 7],
      [1, 3, 5, 7],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 3, 5, 9],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 3, 5, 7],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 3, 5, 7],
      [1, 3, 5, 9],
      [1, 3, 2],
      [1, 3, 5, 9],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 3, 5, 9],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 3, 5, 9],
      [1, 0],
      [1, 3, 2],
      [1, 3, 5, 7],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 3, 5, 7],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 3, 5, 7],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 3, 5, 9],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 3, 5, 7],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 5, 9],
      [1, 3, 7],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 3, 5, 9],
      [1, 3, 2],
      [1, 3, 5, 9],
      [1, 3, 5, 7],
      [1, 3, 2],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 3, 7],
      [1, 3, 5, 7],
      [1, 0],
      [1, 3, 7],
      [1, 3, 5, 7],
      [1, 3, 2],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 3, 2],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 3, 2],
      [1, 3, 7],
      [1, 3, 5, 9],
      [1, 3, 2],
      [1, 3, 5, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 5, 9],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 3, 5, 9],
      [1, 0],
      [1, 3, 5, 9],
      [1, 0],
      [1, 3, 2],
      [1, 3, 5, 7],
      [1, 0],
      [1, 3, 2],
      [1, 3, 5, 9],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 3, 5, 7],
      [1, 3, 5, 7],
      [1, 3, 7],
      [1, 3, 2],
      [1, 3, 5, 9],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 3, 7],
      [1, 3, 5, 7],
      [1, 0],
      [1, 0],
      [1, 3, 5, 9],
      [1, 3, 5, 7],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 3, 5, 7],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 5, 9],
      [1, 3, 5, 9],
      [1, 0],
      [1, 3, 5, 9],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 3, 7],
      [1, 0],
      [1, 3, 5, 7],
      [1, 3, 5, 7],
      [1, 3, 5, 9],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 5, 7],
      [1, 3, 7],
      [1, 3, 2],
      [1, 0],
      [1, 3, 7],
      [1, 3, 5, 7],
      [1, 3, 5, 9],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 5, 9],
      [1, 3, 7],
      [1, 3, 7],
      [1, 3, 7],
      [1, 3, 7],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 3, 2],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 5, 9],
      [1, 3, 2],
      [1, 3, 2],
      [1, 0],
      [1, 3, 2],
      [1, 3, 2],
      [1, 3, 5, 7],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 5, 7],
      [1, 3, 5, 9],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 3, 5, 7],
      [1, 3, 2],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 3, 2],
      [1, 3, 7],
      [1, 3, 2],
      [1, 3, 5, 7],
      [1, 3, 7],
      [1, 3, 5, 7],
      [1, 3, 7],
      [1, 3, 7],
      [1, 3, 2],
      [1, 0],
      [1, 3, 2],
      [1, 3, 2],
      [1, 0],
      [1, 3, 5, 7],
      [1, 3, 2],
      [1, 0],
      [1, 3, 5, 9],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 3, 7],
      [1, 0],
      [1, 3, 5, 7],
      [1, 3, 5, 9],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 3, 7],
      [1, 0],
      [1, 3, 2],
      [1, 3, 5, 9],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 3, 7],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 3, 2],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 3, 2],
      [1, 3, 7],
      [1, 0],
      [1, 3, 7],
      [1, 3, 2],
      [1, 3, 2],
      [1, 3, 5, 7],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 3, 5, 9],
      [1, 3, 7],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 3, 2],
      [1, 3, 7],
      [1, 3, 2],
      [1, 3, 7],
      [1, 3, 2],
      [1, 3, 5, 7],
      [1, 3, 2],
      [1, 3, 7],
      [1, 3, 7],
      [1, 3, 5, 9],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 3, 7],
      [1, 3, 5, 7],
      [1, 0],
      [1, 0],
      [1, 3, 5, 9],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 3, 2],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 3, 2],
      [1, 3, 2],
      [1, 0],
      [1, 3, 5, 9],
      [1, 0],
      [1, 3, 5, 9],
      [1, 0],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 3, 2],
      [1, 3, 7],
      [1, 0],
      [1, 3, 5, 7],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 3, 2],
      [1, 3, 2],
      [1, 3, 5, 7],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 3, 7],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 5, 9],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 3, 5, 7],
      [1, 3, 7],
      [1, 0],
      [1, 0],
      [1, 3, 2],
      [1, 3, 7],
      [1, 3, 7],
      [1, 0],
      [1, 3, 5, 9],
      [1, 0],
      [1, 3, 2],
      [1, 3, 5, 7],
      [1, 0],
      [1, 3, 2],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 0],
      [1, 3, 5, 7],
      [1, 0],
      [1, 3, 2],
      [1, 3, 2],
      [1, 3, 7],
      [1, 3, 5, 7],
      [1, 3, 2],
      [1, 0],
      [1, 0]]}



## Summary and outlook

In this tutorial you learned how to:

- simulate Boolean network dynamics,
- compute synchronous attractors exactly and approximately,
- analyze basin sizes,
- compute steady states under asynchronous updating.

This concludes the function- and network-level analysis.
Subsequent work focuses on large-scale dynamical analysis,
perturbations, and stability in Boolean network models.

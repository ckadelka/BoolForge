

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Boolean Function &mdash; BoolForge 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=8d563738"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Boolean Network" href="boolean_network.html" />
    <link rel="prev" title="Documentation" href="docs.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            BoolForge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="docs.html">Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Boolean Function</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.boolean_function.display_truth_table"><code class="docutils literal notranslate"><span class="pre">display_truth_table()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.boolean_function.get_layer_structure_from_canalized_outputs"><code class="docutils literal notranslate"><span class="pre">get_layer_structure_from_canalized_outputs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction"><code class="docutils literal notranslate"><span class="pre">BooleanFunction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.from_cana"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.from_cana()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.__str__"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.__str__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.__repr__"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.__repr__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.__add__"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.__add__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.__mul__"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.__mul__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.__rmul__"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.__rmul__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.__and__"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.__and__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.__or__"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.__or__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.__xor__"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.__xor__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.__invert__"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.__invert__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.__call__"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.__call__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.to_polynomial"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.to_polynomial()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.to_truth_table"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.to_truth_table()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.to_cana"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.to_cana()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.to_logical"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.to_logical()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.is_constant"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.is_constant()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.is_degenerate"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.is_degenerate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.is_monotonic"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.is_monotonic()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.is_canalizing"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.is_canalizing()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.is_k_canalizing"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.is_k_canalizing()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.is_kset_canalizing"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.is_kset_canalizing()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_hamming_weight"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_hamming_weight()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_essential_variables"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_essential_variables()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_number_of_essential_variables"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_number_of_essential_variables()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_type_of_inputs"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_type_of_inputs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_symmetry_groups"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_symmetry_groups()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_absolute_bias"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_absolute_bias()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_activities"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_activities()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_average_sensitivity"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_average_sensitivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_layer_structure"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_layer_structure()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_canalizing_depth"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_canalizing_depth()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_kset_canalizing_proportion"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_kset_canalizing_proportion()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_kset_canalizing_proportion_of_variables"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_kset_canalizing_proportion_of_variables()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_canalizing_strength"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_canalizing_strength()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_canalizing_strength_of_variables"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_canalizing_strength_of_variables()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_input_redundancy"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_input_redundancy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_edge_effectiveness"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_edge_effectiveness()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction.get_effective_degree"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_effective_degree()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="boolean_network.html">Boolean Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="generate.html">Generate</a></li>
<li class="toctree-l2"><a class="reference internal" href="bio_models.html">Bio Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="utils.html">Utils</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BoolForge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="docs.html">Documentation</a></li>
      <li class="breadcrumb-item active">Boolean Function</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/boolean_function.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="boolean-function">
<h1>Boolean Function<a class="headerlink" href="#boolean-function" title="Link to this heading"></a></h1>
<div class="toctree-wrapper compound">
</div>
<p id="module-boolforge.boolean_function">Created on Tue Aug 12 11:03:49 2025</p>
<p>&#64;author: Benjamin Coberly, Claus Kadelka</p>
<dl class="py function">
<dt class="sig sig-object py" id="boolforge.boolean_function.display_truth_table">
<span class="sig-prename descclassname"><span class="pre">boolforge.boolean_function.</span></span><span class="sig-name descname"><span class="pre">display_truth_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction" title="boolforge.boolean_function.BooleanFunction"><span class="pre">BooleanFunction</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_function.html#display_truth_table"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.display_truth_table" title="Link to this definition"></a></dt>
<dd><p>Display the full truth table of a BooleanFunction in a formatted way.</p>
<p>Each row shows the input combination (x1, x2, …, xn)
and the corresponding output(s) f(x).</p>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>*functions (BooleanFunction): One or more BooleanFunction objects.</p></li>
<li><p>labels (list[str], optional): Column labels for each function
(defaults to f1, f2, …).</p></li>
</ul>
</div></blockquote>
<p><strong>Example:</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">BooleanFunction</span><span class="p">(</span><span class="s2">&quot;(x1 &amp; ~x2) | x3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">display_truth_table</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.boolean_function.get_layer_structure_from_canalized_outputs">
<span class="sig-prename descclassname"><span class="pre">boolforge.boolean_function.</span></span><span class="sig-name descname"><span class="pre">get_layer_structure_from_canalized_outputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">can_outputs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#get_layer_structure_from_canalized_outputs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.get_layer_structure_from_canalized_outputs" title="Link to this definition"></a></dt>
<dd><p>Composes the layer structure when given canalized outputs.</p>
<p><strong>Parameters</strong>:</p>
<blockquote>
<div><ul class="simple">
<li><p>can_outputs (list[int] | np.array[int]): Array of canalized output
values.</p></li>
</ul>
</div></blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<div><ul class="simple">
<li><p>list[int]: The composed layer structure for the provided canalized
outputs.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">boolforge.boolean_function.</span></span><span class="sig-name descname"><span class="pre">BooleanFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">array</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class representing a Boolean function.</p>
<p><strong>Constructor Parameters:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>f (list[int] | np.array[int] | str): A list of length 2^n
representing the outputs of a Boolean function with n inputs, or a
string that can be properly evaluated, see utils.f_from_expression.</p></li>
<li><p>name (str, optional): The name of the node regulated by the Boolean
function (default ‘’).</p></li>
</ul>
</div></blockquote>
<p><strong>Members:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>f (np.array[int]): A numpy array of length 2^n representing the
outputs of a Boolean function with n inputs.</p></li>
<li><p>n (int): The number of inputs for the Boolean function.</p></li>
<li><p>variables (np.array[str]): A numpy array of n strings with variable
names, default x0, …, x_{n-1}.</p></li>
<li><p>name (str): The name of the node regulated by the Boolean function
(default ‘’).</p></li>
<li><p>properties (dict[str:Variant]): Dynamically created dictionary with
additional information about the function (canalizing layer
structure, type of inputs, etc.).</p></li>
</ul>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.from_cana">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_cana</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cana_BooleanNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cana.boolean_node.BooleanNode</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#boolforge.boolean_function.BooleanFunction" title="boolforge.boolean_function.BooleanFunction"><span class="pre">BooleanFunction</span></a></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.from_cana"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.from_cana" title="Link to this definition"></a></dt>
<dd><p><strong>Compatability Method:</strong></p>
<blockquote>
<div><p>Converts an instance of cana.boolean_node.BooleanNode from the
cana module into a Boolforge BooleanFunction object.</p>
</div></blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<div><ul class="simple">
<li><p>A BooleanFunction object.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.__str__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.__str__" title="Link to this definition"></a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.__repr__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.__repr__" title="Link to this definition"></a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.__add__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.__add__" title="Link to this definition"></a></dt>
<dd><p>Element-wise Boolean addition: +.</p>
<p><strong>Supports:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>BooleanFunction * BooleanFunction</p></li>
<li><p>BooleanFunction * int (0 or 1)</p></li>
</ul>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>BooleanFunction: The result of element-wise addition modulo 2.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.__mul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.__mul__" title="Link to this definition"></a></dt>
<dd><p>Element-wise Boolean multiplication (logical AND): *.</p>
<p><strong>Supports:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>BooleanFunction * BooleanFunction</p></li>
<li><p>BooleanFunction * int (0 or 1)</p></li>
</ul>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>BooleanFunction: The result of element-wise multiplication.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.__rmul__" title="Link to this definition"></a></dt>
<dd><p>Element-wise Boolean multiplication (logical AND): *.</p>
<p><strong>Supports:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>BooleanFunction * BooleanFunction</p></li>
<li><p>int (0 or 1) * BooleanFunction</p></li>
</ul>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>BooleanFunction: The result of element-wise multiplication.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.__and__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.__and__" title="Link to this definition"></a></dt>
<dd><p>Element-wise logical AND: &amp;.</p>
<p><strong>Supports:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>BooleanFunction &amp; BooleanFunction</p></li>
<li><p>BooleanFunction &amp; int (0 or 1)</p></li>
</ul>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>BooleanFunction: The result of the logical AND.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.__or__">
<span class="sig-name descname"><span class="pre">__or__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.__or__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.__or__" title="Link to this definition"></a></dt>
<dd><p>Element-wise logical OR: |.</p>
<p><strong>Supports:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>BooleanFunction | BooleanFunction</p></li>
<li><p>BooleanFunction | int (0 or 1)</p></li>
</ul>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>BooleanFunction: The result of the logical OR.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.__xor__">
<span class="sig-name descname"><span class="pre">__xor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.__xor__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.__xor__" title="Link to this definition"></a></dt>
<dd><p>Element-wise logical XOR: ^.</p>
<dl class="simple">
<dt><strong>Supports:</strong></dt><dd><ul class="simple">
<li><p>BooleanFunction ^ BooleanFunction</p></li>
<li><p>BooleanFunction ^ int (0 or 1)</p></li>
</ul>
</dd>
</dl>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>BooleanFunction: The result of the logical XOR.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.__invert__">
<span class="sig-name descname"><span class="pre">__invert__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.__invert__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.__invert__" title="Link to this definition"></a></dt>
<dd><p>Element-wise negation: ~.</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>BooleanFunction: The result of element-wise negation.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.__call__" title="Link to this definition"></a></dt>
<dd><p>Call self as a function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.to_polynomial">
<span class="sig-name descname"><span class="pre">to_polynomial</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.to_polynomial"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.to_polynomial" title="Link to this definition"></a></dt>
<dd><p>Returns the Boolean function converted into polynomial format in
non-reduced DNF.</p>
<p><strong>Returns</strong>:</p>
<blockquote>
<div><ul class="simple">
<li><p>str: Polynomial format in non-reduced DNF of the Boolean function.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.to_truth_table">
<span class="sig-name descname"><span class="pre">to_truth_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">RETURN</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.to_truth_table"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.to_truth_table" title="Link to this definition"></a></dt>
<dd><p>Returns or saves the full truth table of the Boolean function as a pandas DataFrame.</p>
<p>Each row shows the input combination (x1, x2, …, xn)
and the corresponding output f(x).</p>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>RETURN (bool, optional): Whether to return the DataFrame (default: True).
If False, the function only writes the table to file when <cite>filename</cite> is provided.</p></li>
<li><p>filename (str, optional): File name (including extension) to which the truth table
should be saved. Supported formats are ‘csv’, ‘xls’, and ‘xlsx’.
If provided, the truth table is automatically saved in the specified format.</p></li>
</ul>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>pd.DataFrame: The full truth table, if <cite>RETURN=True</cite>.
Otherwise, nothing is returned.</p></li>
</ul>
</div></blockquote>
<dl>
<dt><strong>Example</strong></dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">BooleanFunction</span><span class="p">(</span><span class="s2">&quot;(x1 &amp; ~x2) | x3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">to_truth_table</span><span class="p">()</span>
<span class="go">    x1  x2  x3  f</span>
<span class="go">0    0   0   0  0</span>
<span class="go">1    0   0   1  1</span>
<span class="go">2    0   1   0  0</span>
<span class="go">3    0   1   1  1</span>
<span class="go">4    1   0   0  1</span>
<span class="go">5    1   0   1  1</span>
<span class="go">6    1   1   0  0</span>
<span class="go">7    1   1   1  1</span>
</pre></div>
</div>
</dd>
</dl>
<p><strong>Notes:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>The column names correspond to the function’s variables followed by its name.</p></li>
<li><p>When saving to a file, the file extension determines the format.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.to_cana">
<span class="sig-name descname"><span class="pre">to_cana</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cana.boolean_node.BooleanNode</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.to_cana"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.to_cana" title="Link to this definition"></a></dt>
<dd><p><strong>Compatability method:</strong></p>
<blockquote>
<div><p>Returns an instance of cana.boolean_node.BooleanNode from the
cana module.</p>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>An instance of cana.boolean_node.BooleanNode.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.to_logical">
<span class="sig-name descname"><span class="pre">to_logical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AND</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'&amp;'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">OR</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'|'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NOT</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'!'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MINIMIZE_EXPRESSION</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.to_logical"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.to_logical" title="Link to this definition"></a></dt>
<dd><p>Transform a Boolean function from truth table format to logical expression format.</p>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>AND (str, optional): Character(s) to use for the And operator.
Defaults to ‘&amp;’.</p></li>
<li><p>OR (str, optional): Character(s) to use for the Or operator. Defaults
to ‘|’.</p></li>
<li><p>NOT (str, optional): Character(s) to use for the Not operator.
Defaults to ‘!’.</p></li>
<li><p>MINIMIZE_EXPRESSION (bool, optional): Whether or not to minimize
the expression using Espresso. If true, minimizes the expression.
If false, keeps the expression in DNF form. Defaults to true.</p></li>
</ul>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>str: A string representing the Boolean function.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.is_constant">
<span class="sig-name descname"><span class="pre">is_constant</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.is_constant"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.is_constant" title="Link to this definition"></a></dt>
<dd><p>Check whether a Boolean function is constant.</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>bool: True if f is constant (all outputs are 0 or all are 1),
False otherwise.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.is_degenerate">
<span class="sig-name descname"><span class="pre">is_degenerate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.is_degenerate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.is_degenerate" title="Link to this definition"></a></dt>
<dd><p>Determine if a Boolean function contains non-essential variables.
Numba-accelerated version.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.is_monotonic">
<span class="sig-name descname"><span class="pre">is_monotonic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.is_monotonic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.is_monotonic" title="Link to this definition"></a></dt>
<dd><p>Determine if a Boolean function is monotonic.</p>
<p>A Boolean function is monotonic if it is monotonic in each variable. 
That is, if for all i=1,…,n: f(x_1, …, x_i=0, …, x_n) &gt;= f(x_1,
…, x_i=1, …, x_n) for all (x_1, …, x_n) or f(x_1, …, x_i=0,
…, x_n) &lt;= f(x_1, …, x_i=1, …, x_n) for all (x_1, …, x_n).</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>bool: True if f contains no conditional variables, False if at
least one variable is conditional.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.is_canalizing">
<span class="sig-name descname"><span class="pre">is_canalizing</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.is_canalizing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.is_canalizing" title="Link to this definition"></a></dt>
<dd><p>Determine if a Boolean function is canalizing.</p>
<p>A Boolean function f(x_1, …, x_n) is canalizing if there exists at
least one variable x_i and a value a ∈ {0, 1} such that f(x_1, …,
x_i = a, …, x_n) is constant.</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>bool: True if f is canalizing, False otherwise.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.is_k_canalizing">
<span class="sig-name descname"><span class="pre">is_k_canalizing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.is_k_canalizing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.is_k_canalizing" title="Link to this definition"></a></dt>
<dd><p>Determine if a Boolean function is k-canalizing.</p>
<p>A Boolean function is k-canalizing if it has at least k conditionally
canalizing variables. This is checked recursively: after fixing a
canalizing variable (with a fixed canalizing input that forces the
output), the subfunction must itself be canalizing for
the next variable, and so on.</p>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>k (int): The desired canalizing depth (0 ≤ k ≤ n).
Note: every function is 0-canalizing.</p></li>
</ul>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>bool: True if f is k-canalizing, False otherwise.</p></li>
</ul>
</div></blockquote>
<p><strong>References:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li><p>He, Q., &amp; Macauley, M. (2016). Stratification and enumeration of
Boolean functions by canalizing depth. Physica D: Nonlinear
Phenomena, 314, 1-8.</p></li>
<li><p>Dimitrova, E., Stigler, B., Kadelka, C., &amp; Murrugarra, D.
(2022). Revealing the canalizing structure of Boolean functions:
Algorithms and applications. Automatica, 146, 110630.</p></li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.is_kset_canalizing">
<span class="sig-name descname"><span class="pre">is_kset_canalizing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.is_kset_canalizing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.is_kset_canalizing" title="Link to this definition"></a></dt>
<dd><p>Determine if a Boolean function is k-set canalizing.</p>
<p>A Boolean function is k-set canalizing if there exists a set of k
variables such that setting these variables to specific values forces
the output of the function, irrespective of the other n - k inputs.</p>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>k (int): The size of the variable set (with 0 ≤ k ≤ n).</p></li>
</ul>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>bool: True if f is k-set canalizing, False otherwise.</p></li>
</ul>
</div></blockquote>
<p><strong>References:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023). Collectively
canalizing Boolean functions. Advances in Applied Mathematics,
145, 102475.</p></li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_hamming_weight">
<span class="sig-name descname"><span class="pre">get_hamming_weight</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_hamming_weight"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_hamming_weight" title="Link to this definition"></a></dt>
<dd><p>Calculate the number of non-zero bits in the bit vector representing
a Boolean function.</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>int: The number of non-zero bits in the bit vector.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_essential_variables">
<span class="sig-name descname"><span class="pre">get_essential_variables</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_essential_variables"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_essential_variables" title="Link to this definition"></a></dt>
<dd><p>Determine the indices of essential variables in a Boolean function.</p>
<p>A variable is essential if changing its value (while holding the others
constant) can change the output of f.</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>list[int]: List of indices corresponding to the essential variables.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_number_of_essential_variables">
<span class="sig-name descname"><span class="pre">get_number_of_essential_variables</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_number_of_essential_variables"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_number_of_essential_variables" title="Link to this definition"></a></dt>
<dd><p>Count the number of essential variables in a Boolean function.</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>int: The number of essential variables.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_type_of_inputs">
<span class="sig-name descname"><span class="pre">get_type_of_inputs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_type_of_inputs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_type_of_inputs" title="Link to this definition"></a></dt>
<dd><p>Determine for each input of the Boolean function whether it is
positive, negative, conditional or non-essential.</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>np.ndarray[str]: The type of each input of the Boolean function.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_symmetry_groups">
<span class="sig-name descname"><span class="pre">get_symmetry_groups</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_symmetry_groups"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_symmetry_groups" title="Link to this definition"></a></dt>
<dd><p>Determine all symmetry groups of input variables for a Boolean function.</p>
<p>Two variables are in the same symmetry group if swapping their values
does not change the output of the function for any input of the other
variables.</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>list[list[int]]: A list of lists where each inner list contains
indices of variables that form a symmetry group.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_absolute_bias">
<span class="sig-name descname"><span class="pre">get_absolute_bias</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_absolute_bias"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_absolute_bias" title="Link to this definition"></a></dt>
<dd><p>Compute the absolute bias of a Boolean function.</p>
<p>The absolute bias is defined as <cite>|(self.get_hamming_weight() /
2^(n-1)) - 1|</cite>, which quantifies how far the function’s output
distribution deviates from being balanced.</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>float: The absolute bias of the Boolean function.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_activities">
<span class="sig-name descname"><span class="pre">get_activities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">EXACT</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">array</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_activities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_activities" title="Link to this definition"></a></dt>
<dd><p>Compute the activities of all variables of a Boolean function.</p>
<p>This function can compute the activities  by exhaustively iterating
over all inputs (if EXACT is True) or estimate it via Monte Carlo sampling 
(if EXACT is False).</p>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>nsim (int, optional): Number of random samples (default is 10000,
used when EXACT is False).</p></li>
<li><p>EXACT (bool, optional): If True, compute the exact sensitivity by
iterating over all inputs; otherwise, use sampling (default).</p></li>
<li><p>rng (None, optional): Argument for the random number generator,
implemented in ‘utils._coerce_rng’.</p></li>
</ul>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>np.array(float): The activities of the variables of the Boolean function.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_average_sensitivity">
<span class="sig-name descname"><span class="pre">get_average_sensitivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">EXACT</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NORMALIZED</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_average_sensitivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_average_sensitivity" title="Link to this definition"></a></dt>
<dd><p>Compute the average sensitivity of a Boolean function.</p>
<p>The average sensitivity is equivalent to the Derrida value D(F,1) when
the update rule is sampled from the same space. This function can
compute the exact sensitivity by exhaustively iterating over all inputs
(if EXACT is True) or estimate it via Monte Carlo sampling (if EXACT
is False). The result can be normalized by the number of inputs.</p>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>nsim (int, optional): Number of random samples (default is 10000,
used when EXACT is False).</p></li>
<li><p>EXACT (bool, optional): If True, compute the exact sensitivity by
iterating over all inputs; otherwise, use sampling (default).</p></li>
<li><p>NORMALIZED (bool, optional): If True, return the normalized
sensitivity (divided by the number of function inputs);
otherwise, return the total count.</p></li>
<li><p>rng (None, optional): Argument for the random number generator,
implemented in ‘utils._coerce_rng’.</p></li>
</ul>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>float: The (normalized) average sensitivity of the Boolean function.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_layer_structure">
<span class="sig-name descname"><span class="pre">get_layer_structure</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_layer_structure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_layer_structure" title="Link to this definition"></a></dt>
<dd><p>Determine the canalizing layer structure of a Boolean function.</p>
<p>This function decomposes a Boolean function into its canalizing layers
(standard monomial form) by recursively identifying and removing
conditionally canalizing variables. The output includes the canalizing
depth, the number of layers, the canalizing inputs and outputs, the
core function of the non-canalizing variables, and the order of the
canalizing variables.</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul>
<li><p>dict: A dictionary (self.properties) containing:</p>
<blockquote>
<div><ul class="simple">
<li><p>CanalizingDepth (int): Canalizing depth (number of
conditionally canalizing variables).</p></li>
<li><p>NumberOfLayers (int): Number of distinct canalizing layers.</p></li>
<li><p>CanalizingInputs (np.array[int]): Array of canalizing input
values.</p></li>
<li><p>CanalizedOutputs (np.array[int]): Array of canalized output
values.</p></li>
<li><p>CoreFunction (BooleanFunction): The core function (truth
table) after removing canalizing variables. Inputs:
non-canalizing variables.</p></li>
<li><p>OrderOfCanalizingVariables (np.array[int]): Array of indices
representing the order of canalizing variables.</p></li>
<li><p>LayerStructure (np.array[int]): Indicates the number of
variables in each canalizing layer.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p><strong>References:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li><p>He, Q., &amp; Macauley, M. (2016). Stratification and enumeration
of Boolean functions by canalizing depth. Physica D: Nonlinear
Phenomena, 314, 1-8.</p></li>
<li><p>Dimitrova, E., Stigler, B., Kadelka, C., &amp; Murrugarra, D.
(2022). Revealing the canalizing structure of Boolean functions:
Algorithms and applications. Automatica, 146, 110630.</p></li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_canalizing_depth">
<span class="sig-name descname"><span class="pre">get_canalizing_depth</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_canalizing_depth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_canalizing_depth" title="Link to this definition"></a></dt>
<dd><p>Returns the canalizing depth of the function.</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>int: The canalizing depth (number of conditionally canalizing
variables).</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_kset_canalizing_proportion">
<span class="sig-name descname"><span class="pre">get_kset_canalizing_proportion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_kset_canalizing_proportion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_kset_canalizing_proportion" title="Link to this definition"></a></dt>
<dd><p>Compute the proportion of k-set canalizing input sets for a Boolean
function.</p>
<p>For a given k, this function calculates the probability that a randomly
chosen set of k inputs canalizes the function, i.e., forces the output
regardless of the remaining variables.</p>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>k (int): The size of the variable set (0 ≤ k ≤ n).</p></li>
</ul>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>float: The proportion of k-set canalizing input sets.</p></li>
</ul>
</div></blockquote>
<p><strong>References:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023). Collectively
canalizing Boolean functions. Advances in Applied Mathematics,
145, 102475.</p></li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_kset_canalizing_proportion_of_variables">
<span class="sig-name descname"><span class="pre">get_kset_canalizing_proportion_of_variables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_kset_canalizing_proportion_of_variables"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_kset_canalizing_proportion_of_variables" title="Link to this definition"></a></dt>
<dd><p>Compute the proportion of k-set canalizing input sets that contain a specific variable.</p>
<p>For a given k, this function calculates the probability that a randomly
chosen set of k inputs (including a specific variable) canalizes the function,
i.e., forces the output regardless of the remaining variables.</p>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>k (int): The size of the variable set (0 ≤ k ≤ n).</p></li>
</ul>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>float: The proportion of k-set canalizing input sets.</p></li>
</ul>
</div></blockquote>
<p><strong>References:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023). Collectively
canalizing Boolean functions. Advances in Applied Mathematics,
145, 102475.</p></li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_canalizing_strength">
<span class="sig-name descname"><span class="pre">get_canalizing_strength</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_canalizing_strength"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_canalizing_strength" title="Link to this definition"></a></dt>
<dd><p>Compute the canalizing strength of a Boolean function via exhaustive
enumeration.</p>
<p>The canalizing strength is defined as a weighted average of the
proportions of k-set canalizing inputs for k = 1 to n-1. It is 0 for
minimally canalizing functions (e.g., Boolean parity functions) and 1
for maximally canalizing functions (e.g., nested canalizing functions
with one layer).</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>The canalizing strength of f.</p></li>
</ul>
</div></blockquote>
<p><strong>References:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023). Collectively
canalizing Boolean functions. Advances in Applied Mathematics,
145, 102475.</p></li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_canalizing_strength_of_variables">
<span class="sig-name descname"><span class="pre">get_canalizing_strength_of_variables</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_canalizing_strength_of_variables"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_canalizing_strength_of_variables" title="Link to this definition"></a></dt>
<dd><p>Compute the canalizing strength of each variable in a Boolean function 
via exhaustive enumeration.</p>
<p>The canalizing strength is defined as a weighted average of the
proportions of k-set canalizing inputs for k = 1 to n-1. It is 0 for
minimally canalizing functions (e.g., Boolean parity functions) and 1
for maximally canalizing functions (e.g., nested canalizing functions
with one layer).</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>np.array(float): The canalizing strength of each variable of f.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_input_redundancy">
<span class="sig-name descname"><span class="pre">get_input_redundancy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_input_redundancy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_input_redundancy" title="Link to this definition"></a></dt>
<dd><div class="admonition important">
<p class="admonition-title">Important</p>
<p>This method requires an installation of CANA (See
<a class="reference external" href="https://ckadelka.github.io/BoolForge/install.html#extended-functionality">Extended Functionality</a>). If CANA is not found, this method will
return None.</p>
</div>
<p>Compute the input redundancy of a Boolean function.</p>
<p>The input redundancy quantifies how many inputs are not required to
determine the function’s output. Constant functions have an input
redundancy of 1 (none of the inputs are needed), whereas parity
functions have an input redundancy of 0 (all inputs are necessary).</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>float: Normalized input redundancy in the interval [0, 1].</p></li>
</ul>
</div></blockquote>
<p><strong>References:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Marques-Pita, M., &amp; Rocha, L. M. (2013). Canalization and
control in automata networks: body segmentation in Drosophila
melanogaster. PloS One, 8(3), e55946.</p></li>
<li><p>Correia, R. B., Gates, A. J., Wang, X., &amp; Rocha, L. M. (2018).
CANA: a python package for quantifying control and canalization
in Boolean networks. Frontiers in Physiology, 9, 1046.</p></li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_edge_effectiveness">
<span class="sig-name descname"><span class="pre">get_edge_effectiveness</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_edge_effectiveness"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_edge_effectiveness" title="Link to this definition"></a></dt>
<dd><div class="admonition important">
<p class="admonition-title">Important</p>
<p>This method requires an installation of CANA (See
<a class="reference external" href="https://ckadelka.github.io/BoolForge/install.html#extended-functionality">Extended Functionality</a>). If CANA is not found, this method will
return None.</p>
</div>
<p>Compute the edge effectiveness for each regulator of a Boolean function.</p>
<p>Edge effectiveness measures how much flipping a given input (regulator)
influences the output. Non-essential inputs have an effectiveness of 0,
whereas inputs that always flip the output when toggled have an
effectiveness of 1.</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>list[float]: A list of n floats in [0, 1] representing the edge
effectiveness for each input.</p></li>
</ul>
</div></blockquote>
<p><strong>References:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Marques-Pita, M., &amp; Rocha, L. M. (2013). Canalization and
control in automata networks: body segmentation in Drosophila
melanogaster. PloS One, 8(3), e55946.</p></li>
<li><p>Correia, R. B., Gates, A. J., Wang, X., &amp; Rocha, L. M. (2018).
CANA: a python package for quantifying control and canalization
in Boolean networks. Frontiers in Physiology, 9, 1046.</p></li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_function.BooleanFunction.get_effective_degree">
<span class="sig-name descname"><span class="pre">get_effective_degree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_function.html#BooleanFunction.get_effective_degree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_function.BooleanFunction.get_effective_degree" title="Link to this definition"></a></dt>
<dd><div class="admonition important">
<p class="admonition-title">Important</p>
<p>This method requires an installation of CANA (See
<a class="reference external" href="https://ckadelka.github.io/BoolForge/install.html#extended-functionality">Extended Functionality</a>). If CANA is not found, this method will
return None.</p>
</div>
<p>Compute the effective degree, i.e., the sum of the edge effectivenesses
of each regulator, of a Boolean function.</p>
<p>Edge effectiveness measures how much flipping a given input (regulator)
influences the output. Non-essential inputs have an effectiveness of 0,
whereas inputs that always flip the output when toggled have an
effectiveness of 1.</p>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>float: The sum of the edge effectiveness of each regulator.</p></li>
</ul>
</div></blockquote>
<p><strong>References:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Marques-Pita, M., &amp; Rocha, L. M. (2013). Canalization and
control in automata networks: body segmentation in Drosophila
melanogaster. PloS One, 8(3), e55946.</p></li>
<li><p>Correia, R. B., Gates, A. J., Wang, X., &amp; Rocha, L. M. (2018).
CANA: a python package for quantifying control and canalization
in Boolean networks. Frontiers in Physiology, 9, 1046.</p></li>
</ol>
</div></blockquote>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="docs.html" class="btn btn-neutral float-left" title="Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="boolean_network.html" class="btn btn-neutral float-right" title="Boolean Network" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Claus Kadelka, Benjamin Coberly.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>


<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Generate &mdash; BoolForge 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=9edc463e" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=8d563738"></script>
      <script src="_static/doctools.js?v=fd6eb6e6"></script>
      <script src="_static/sphinx_highlight.js?v=6ffebe34"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Bio Models" href="bio_models.html" />
    <link rel="prev" title="Boolean Network" href="boolean_network.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            BoolForge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="docs.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="boolean_function.html">Boolean Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="boolean_network.html">Boolean Network</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Generate</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_function"><code class="docutils literal notranslate"><span class="pre">random_function()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_function_with_bias"><code class="docutils literal notranslate"><span class="pre">random_function_with_bias()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_function_with_exact_hamming_weight"><code class="docutils literal notranslate"><span class="pre">random_function_with_exact_hamming_weight()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_parity_function"><code class="docutils literal notranslate"><span class="pre">random_parity_function()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_non_degenerate_function"><code class="docutils literal notranslate"><span class="pre">random_non_degenerate_function()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_degenerate_function"><code class="docutils literal notranslate"><span class="pre">random_degenerate_function()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_non_canalizing_function"><code class="docutils literal notranslate"><span class="pre">random_non_canalizing_function()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_non_canalizing_non_degenerate_function"><code class="docutils literal notranslate"><span class="pre">random_non_canalizing_non_degenerate_function()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.sample_canalized_outputs_uniform_structure"><code class="docutils literal notranslate"><span class="pre">sample_canalized_outputs_uniform_structure()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_k_canalizing_function"><code class="docutils literal notranslate"><span class="pre">random_k_canalizing_function()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_k_canalizing_function_with_specific_layer_structure"><code class="docutils literal notranslate"><span class="pre">random_k_canalizing_function_with_specific_layer_structure()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_NCF"><code class="docutils literal notranslate"><span class="pre">random_NCF()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_degrees"><code class="docutils literal notranslate"><span class="pre">random_degrees()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_edge_list"><code class="docutils literal notranslate"><span class="pre">random_edge_list()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_wiring_diagram"><code class="docutils literal notranslate"><span class="pre">random_wiring_diagram()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.rewire_wiring_diagram"><code class="docutils literal notranslate"><span class="pre">rewire_wiring_diagram()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_network"><code class="docutils literal notranslate"><span class="pre">random_network()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.generate.random_null_model"><code class="docutils literal notranslate"><span class="pre">random_null_model()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="bio_models.html">Bio Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="utils.html">Utils</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BoolForge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="docs.html">Documentation</a></li>
      <li class="breadcrumb-item active">Generate</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/generate.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="generate">
<h1>Generate<a class="headerlink" href="#generate" title="Link to this heading"></a></h1>
<div class="toctree-wrapper compound">
</div>
<p id="module-boolforge.generate">This module provides functions for generating random Boolean functions and
Boolean networks with specified structural and dynamical properties.</p>
<p>The <a class="reference internal" href="#module-boolforge.generate" title="boolforge.generate"><code class="xref py py-mod docutils literal notranslate"><span class="pre">generate</span></code></a> module enables the systematic creation of
Boolean functions and networks that satisfy particular constraints, such as
specified canalization depth, sensitivity range, bias, or connectivity.
Generated instances can be used for statistical analysis, benchmarking, or
simulation studies.</p>
<p>Several generation routines leverage Numba acceleration for efficient sampling
and evaluation of large function spaces. While Numba is <strong>recommended</strong> to
achieve near-native performance, it is <strong>not required</strong> for functionality; all
functions have pure Python fallbacks.</p>
<p>This module complements <a class="reference internal" href="boolean_function.html#module-boolforge.boolean_function" title="boolforge.boolean_function"><code class="xref py py-mod docutils literal notranslate"><span class="pre">boolean_function</span></code></a> and
<a class="reference internal" href="boolean_network.html#module-boolforge.boolean_network" title="boolforge.boolean_network"><code class="xref py py-mod docutils literal notranslate"><span class="pre">boolean_network</span></code></a> by facilitating reproducible generation of
synthetic test cases and large ensembles of random networks.</p>
<section id="example">
<h2>Example<a class="headerlink" href="#example" title="Link to this heading"></a></h2>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">boolforge</span><span class="w"> </span><span class="kn">import</span> <span class="n">generate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generate</span><span class="o">.</span><span class="n">random_function</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">generate</span><span class="o">.</span><span class="n">random_network</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_function">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">EXACT_DEPTH</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">UNIFORM_STRUCTURE</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_structure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PARITY</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ALLOW_DEGENERATE_FUNCTIONS</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">absolute_bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">USE_ABSOLUTE_BIAS</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hamming_weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="boolean_function.html#boolforge.boolean_function.BooleanFunction" title="boolforge.boolean_function.BooleanFunction"><span class="pre">BooleanFunction</span></a></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_function" title="Link to this definition"></a></dt>
<dd><p>Generate a random Boolean function under flexible structural constraints.</p>
<p>This function acts as a high-level generator that unifies several common
ensembles of Boolean functions, including parity functions, canalizing
functions of specified depth or layer structure, functions with fixed
Hamming weight, and biased random functions. The first applicable
generation rule (in the order described below) is applied.</p>
<p>Selection logic (first applicable rule is used)</p>
<ol class="arabic">
<li><p>If <code class="docutils literal notranslate"><span class="pre">PARITY</span></code> is True, return a random parity function
(see <code class="docutils literal notranslate"><span class="pre">random_parity_function</span></code>).</p></li>
<li><p>Else, if <code class="docutils literal notranslate"><span class="pre">layer_structure</span></code> is provided, return a Boolean function
with the specified canalizing layer structure using
<code class="docutils literal notranslate"><span class="pre">random_k_canalizing_function_with_specific_layer_structure</span></code>.
Exactness of the canalizing depth is controlled by <code class="docutils literal notranslate"><span class="pre">EXACT_DEPTH</span></code>.</p></li>
<li><p>Else, if <code class="docutils literal notranslate"><span class="pre">depth</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, return a k-canalizing function with
<code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">min(depth,</span> <span class="pre">n)</span></code> using <code class="docutils literal notranslate"><span class="pre">random_k_canalizing_function</span></code>.
If <code class="docutils literal notranslate"><span class="pre">EXACT_DEPTH</span></code> is True, the function has exactly this depth;
otherwise, its canalizing depth is at least <code class="docutils literal notranslate"><span class="pre">k</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">UNIFORM_STRUCTURE</span></code> is True, canalizing layer structures are
sampled uniformly at random (up to the imposed constraints).
If False, canalized outputs are sampled independently and uniformly
as bitstrings, which biases the distribution toward more symmetric
layer structures.</p>
</li>
<li><p>Else, if <code class="docutils literal notranslate"><span class="pre">hamming_weight</span></code> is provided, repeatedly sample Boolean
functions with the specified Hamming weight until additional
constraints implied by <code class="docutils literal notranslate"><span class="pre">EXACT_DEPTH</span></code> and
<code class="docutils literal notranslate"><span class="pre">ALLOW_DEGENERATE_FUNCTIONS</span></code> are satisfied.</p></li>
<li><p>Else, generate a random Boolean function using a Bernoulli model with
either:</p>
<ul class="simple">
<li><p>fixed bias <code class="docutils literal notranslate"><span class="pre">bias</span></code>, or</p></li>
<li><p>an automatically chosen bias determined by <code class="docutils literal notranslate"><span class="pre">absolute_bias</span></code> if
<code class="docutils literal notranslate"><span class="pre">USE_ABSOLUTE_BIAS</span></code> is True.</p></li>
</ul>
<p>Additional constraints on canalization and degeneracy are enforced
depending on <code class="docutils literal notranslate"><span class="pre">EXACT_DEPTH</span></code> and <code class="docutils literal notranslate"><span class="pre">ALLOW_DEGENERATE_FUNCTIONS</span></code>.</p>
</li>
</ol>
<section id="parameters">
<h2>Parameters<a class="headerlink" href="#parameters" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>Number of input variables. Must be a positive integer.</p>
</dd>
<dt>depth<span class="classifier">int, optional</span></dt><dd><p>Requested canalizing depth. Used only if <code class="docutils literal notranslate"><span class="pre">layer_structure</span></code> is None
and <code class="docutils literal notranslate"><span class="pre">depth</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. If <code class="docutils literal notranslate"><span class="pre">EXACT_DEPTH</span></code> is True, the function has exactly
this canalizing depth (clipped at <code class="docutils literal notranslate"><span class="pre">n</span></code>); otherwise, its depth is at
least <code class="docutils literal notranslate"><span class="pre">depth</span></code>. Default is 0.</p>
</dd>
<dt>EXACT_DEPTH<span class="classifier">bool, optional</span></dt><dd><p>Enforce exact canalizing depth where applicable. If <code class="docutils literal notranslate"><span class="pre">depth</span> <span class="pre">==</span> <span class="pre">0</span></code>,
setting <code class="docutils literal notranslate"><span class="pre">EXACT_DEPTH=True</span></code> enforces that the function is
non-canalizing. Default is False.</p>
</dd>
<dt>UNIFORM_STRUCTURE<span class="classifier">bool, optional</span></dt><dd><p>If True (default), canalizing layer structures are sampled uniformly
at random in canalizing-function branches. If False, canalized outputs
are sampled independently as bitstrings, inducing a bias toward more
symmetric structures.</p>
</dd>
<dt>layer_structure<span class="classifier">list[int] or None, optional</span></dt><dd><p>Explicit canalizing layer structure <code class="docutils literal notranslate"><span class="pre">[k1,</span> <span class="pre">...,</span> <span class="pre">kr]</span></code>. If provided,
this takes precedence over <code class="docutils literal notranslate"><span class="pre">depth</span></code>. Default is None.</p>
</dd>
<dt>PARITY<span class="classifier">bool, optional</span></dt><dd><p>If True, ignore all other options and return a random parity function.
Default is False.</p>
</dd>
<dt>ALLOW_DEGENERATE_FUNCTIONS<span class="classifier">bool, optional</span></dt><dd><p>If True, functions with non-essential variables may be returned in
random-generation branches. If False, non-degenerate functions are
enforced whenever possible. Default is False.</p>
</dd>
<dt>bias<span class="classifier">float, optional</span></dt><dd><p>Probability of a 1 when sampling truth-table entries independently.
Used only if <code class="docutils literal notranslate"><span class="pre">USE_ABSOLUTE_BIAS</span></code> is False and no other branch applies.
Must lie in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>. Default is 0.5.</p>
</dd>
<dt>absolute_bias<span class="classifier">float, optional</span></dt><dd><p>Absolute deviation from 0.5 used to determine the bias when
<code class="docutils literal notranslate"><span class="pre">USE_ABSOLUTE_BIAS</span></code> is True. The bias is chosen uniformly from
<code class="docutils literal notranslate"><span class="pre">{0.5*(1</span> <span class="pre">-</span> <span class="pre">absolute_bias),</span> <span class="pre">0.5*(1</span> <span class="pre">+</span> <span class="pre">absolute_bias)}</span></code>. Must lie in
<code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>. Default is 0.</p>
</dd>
<dt>USE_ABSOLUTE_BIAS<span class="classifier">bool, optional</span></dt><dd><p>If True, ignore <code class="docutils literal notranslate"><span class="pre">bias</span></code> and determine the bias using
<code class="docutils literal notranslate"><span class="pre">absolute_bias</span></code>. Default is False.</p>
</dd>
<dt>hamming_weight<span class="classifier">int or None, optional</span></dt><dd><p>If provided, enforce that the Boolean function has exactly this many
ones in its truth table. Additional constraints are enforced depending
on <code class="docutils literal notranslate"><span class="pre">EXACT_DEPTH</span></code> and <code class="docutils literal notranslate"><span class="pre">ALLOW_DEGENERATE_FUNCTIONS</span></code>. Default is None.</p>
</dd>
<dt>rng<span class="classifier">int, numpy.random.Generator, numpy.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="returns">
<h2>Returns<a class="headerlink" href="#returns" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>BooleanFunction</dt><dd><p>A randomly generated Boolean function of arity <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
</dd>
</dl>
</section>
<section id="raises">
<h2>Raises<a class="headerlink" href="#raises" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>TypeError</dt><dd><p>If parameters have invalid types.</p>
</dd>
<dt>ValueError</dt><dd><p>If parameter values or combinations are invalid.</p>
</dd>
</dl>
</section>
<section id="notes">
<h2>Notes<a class="headerlink" href="#notes" title="Link to this heading"></a></h2>
<p>For any fixed combination of parameters, this function samples <strong>uniformly
at random</strong> from the set of Boolean functions satisfying the corresponding
constraints. Non-uniformity arises only when explicitly requested via
<code class="docutils literal notranslate"><span class="pre">UNIFORM_STRUCTURE=False</span></code>.</p>
<p>Extremely biased functions are often degenerate or highly canalizing;
under restrictive parameter choices, some branches may reject repeatedly
before returning a valid function.</p>
</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Link to this heading"></a></h2>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Unbiased, non-degenerate random function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">random_function</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Function with canalizing depth at least 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">random_function</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Function with exact canalizing depth 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">random_function</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">EXACT_DEPTH</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Function with a specific canalizing layer structure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">random_function</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">layer_structure</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Parity function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">random_function</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">PARITY</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Fixed Hamming weight with non-canalizing and non-degenerate constraints</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">random_function</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">hamming_weight</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">EXACT_DEPTH</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">ALLOW_DEGENERATE_FUNCTIONS</span><span class="o">=</span><span class="kc">False</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_function_with_bias">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_function_with_bias</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="boolean_function.html#boolforge.boolean_function.BooleanFunction" title="boolforge.boolean_function.BooleanFunction"><span class="pre">BooleanFunction</span></a></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_function_with_bias"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_function_with_bias" title="Link to this definition"></a></dt>
<dd><p>Generate a random Boolean function with a specified bias.</p>
<p>The Boolean function is represented by its truth table of length
<code class="docutils literal notranslate"><span class="pre">2**n</span></code>, where each entry is independently set to 1 with probability
<code class="docutils literal notranslate"><span class="pre">bias</span></code> and to 0 otherwise.</p>
<section id="id1">
<h2>Parameters<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>Number of Boolean variables.</p>
</dd>
<dt>bias<span class="classifier">float, optional</span></dt><dd><p>Probability that a given truth-table entry equals 1. Default is 0.5.</p>
</dd>
<dt>rng<span class="classifier">int, np.random.Generator, np.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id2">
<h2>Returns<a class="headerlink" href="#id2" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>BooleanFunction</dt><dd><p>Random Boolean function with the specified bias.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_function_with_exact_hamming_weight">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_function_with_exact_hamming_weight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hamming_weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="boolean_function.html#boolforge.boolean_function.BooleanFunction" title="boolforge.boolean_function.BooleanFunction"><span class="pre">BooleanFunction</span></a></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_function_with_exact_hamming_weight"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_function_with_exact_hamming_weight" title="Link to this definition"></a></dt>
<dd><p>Generate a random Boolean function with a fixed Hamming weight.</p>
<p>The Boolean function is represented by its truth table of length
<code class="docutils literal notranslate"><span class="pre">2**n</span></code>, containing exactly <code class="docutils literal notranslate"><span class="pre">hamming_weight</span></code> entries equal to 1.
All such functions are sampled uniformly at random.</p>
<section id="id3">
<h2>Parameters<a class="headerlink" href="#id3" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>Number of Boolean variables.</p>
</dd>
<dt>hamming_weight<span class="classifier">int</span></dt><dd><p>Number of truth-table entries equal to 1.</p>
</dd>
<dt>rng<span class="classifier">int, np.random.Generator, np.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id4">
<h2>Returns<a class="headerlink" href="#id4" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>BooleanFunction</dt><dd><p>Random Boolean function with exactly <code class="docutils literal notranslate"><span class="pre">hamming_weight</span></code> ones in its
truth table.</p>
</dd>
</dl>
</section>
<section id="id5">
<h2>Raises<a class="headerlink" href="#id5" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>TypeError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">hamming_weight</span></code> is not an integer.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">hamming_weight</span></code> is not in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">2**n]</span></code>.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_parity_function">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_parity_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="boolean_function.html#boolforge.boolean_function.BooleanFunction" title="boolforge.boolean_function.BooleanFunction"><span class="pre">BooleanFunction</span></a></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_parity_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_parity_function" title="Link to this definition"></a></dt>
<dd><p>Generate a random parity Boolean function.</p>
<p>A parity Boolean function evaluates to the parity (sum modulo 2) of all
input variables, optionally shifted by a constant. This function returns
either the parity function or its complement, chosen uniformly at random.</p>
<section id="id6">
<h2>Parameters<a class="headerlink" href="#id6" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>Number of Boolean variables.</p>
</dd>
<dt>rng<span class="classifier">int, np.random.Generator, np.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id7">
<h2>Returns<a class="headerlink" href="#id7" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>BooleanFunction</dt><dd><p>Random parity Boolean function on <code class="docutils literal notranslate"><span class="pre">n</span></code> variables.</p>
</dd>
</dl>
</section>
<section id="id8">
<h2>Raises<a class="headerlink" href="#id8" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">n</span></code> is not a positive integer.</p>
</dd>
</dl>
</section>
<section id="id9">
<h2>Notes<a class="headerlink" href="#id9" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>The returned function is either
<code class="docutils literal notranslate"><span class="pre">x1</span> <span class="pre">XOR</span> <span class="pre">x2</span> <span class="pre">XOR</span> <span class="pre">...</span> <span class="pre">XOR</span> <span class="pre">xn</span></code> or its complement.</p></li>
<li><p>All variables are included symmetrically.</p></li>
<li><p>Parity functions are never canalizing. All variables must always be known
to determine the output; they have maximal average sensitivity.</p></li>
</ul>
</section>
<section id="id10">
<h2>Examples<a class="headerlink" href="#id10" title="Link to this heading"></a></h2>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">random_parity_function</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_non_degenerate_function">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_non_degenerate_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="boolean_function.html#boolforge.boolean_function.BooleanFunction" title="boolforge.boolean_function.BooleanFunction"><span class="pre">BooleanFunction</span></a></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_non_degenerate_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_non_degenerate_function" title="Link to this definition"></a></dt>
<dd><p>Generate a random non-degenerate Boolean function.</p>
<p>A Boolean function is non-degenerate if every variable is essential, i.e.,
the function depends on all <code class="docutils literal notranslate"><span class="pre">n</span></code> input variables. Functions are sampled
repeatedly from the Bernoulli(bias) ensemble until a non-degenerate
function is obtained.</p>
<section id="id11">
<h2>Parameters<a class="headerlink" href="#id11" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>Number of Boolean variables.</p>
</dd>
<dt>bias<span class="classifier">float, optional</span></dt><dd><p>Probability that a truth-table entry equals 1. Default is 0.5.</p>
</dd>
<dt>rng<span class="classifier">int, np.random.Generator, np.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id12">
<h2>Returns<a class="headerlink" href="#id12" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>BooleanFunction</dt><dd><p>Random non-degenerate Boolean function.</p>
</dd>
</dl>
</section>
<section id="id13">
<h2>Raises<a class="headerlink" href="#id13" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">n</span></code> is not a positive integer.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">bias</span></code> is not strictly between 0 and 1.</p>
</dd>
</dl>
</section>
<section id="id14">
<h2>Notes<a class="headerlink" href="#id14" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>For moderate bias values, almost all Boolean functions are non-degenerate.</p></li>
<li><p>Extremely biased functions are very likely to be degenerate, which may
lead to long rejection-sampling times.</p></li>
</ul>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_degenerate_function">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_degenerate_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="boolean_function.html#boolforge.boolean_function.BooleanFunction" title="boolforge.boolean_function.BooleanFunction"><span class="pre">BooleanFunction</span></a></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_degenerate_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_degenerate_function" title="Link to this definition"></a></dt>
<dd><p>Generate a random degenerate Boolean function.</p>
<p>A Boolean function is degenerate if at least one variable is
non-essential, i.e., the function does not depend on that variable.
This function constructs a degenerate Boolean function by selecting
one variable uniformly at random and enforcing that the output is
independent of that variable.</p>
<section id="id15">
<h2>Parameters<a class="headerlink" href="#id15" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>Number of Boolean variables.</p>
</dd>
<dt>bias<span class="classifier">float, optional</span></dt><dd><p>Probability that a truth-table entry equals 1 for the underlying
(n−1)-variable function. Default is 0.5.</p>
</dd>
<dt>rng<span class="classifier">int, np.random.Generator, np.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id16">
<h2>Returns<a class="headerlink" href="#id16" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>BooleanFunction</dt><dd><p>Random degenerate Boolean function on <code class="docutils literal notranslate"><span class="pre">n</span></code> variables.</p>
</dd>
</dl>
</section>
<section id="id17">
<h2>Raises<a class="headerlink" href="#id17" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">n</span></code> is not a positive integer.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">bias</span></code> is not strictly between 0 and 1.</p>
</dd>
</dl>
</section>
<section id="id18">
<h2>Notes<a class="headerlink" href="#id18" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>Exactly one variable is forced to be non-essential by construction,
though additional variables may also be non-essential by chance.</p></li>
<li><p>The degenerate variable is chosen uniformly at random.</p></li>
<li><p>The resulting distribution is not uniform over all degenerate Boolean
functions.</p></li>
<li><p>This construction avoids rejection sampling.</p></li>
</ul>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_non_canalizing_function">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_non_canalizing_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="boolean_function.html#boolforge.boolean_function.BooleanFunction" title="boolforge.boolean_function.BooleanFunction"><span class="pre">BooleanFunction</span></a></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_non_canalizing_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_non_canalizing_function" title="Link to this definition"></a></dt>
<dd><p>Generate a random non-canalizing Boolean function.</p>
<p>A Boolean function is canalizing if there exists at least one variable
and a value of that variable such that fixing it forces the output of
the function. This function samples Boolean functions from the
Bernoulli(bias) ensemble until a non-canalizing function is obtained.</p>
<section id="id19">
<h2>Parameters<a class="headerlink" href="#id19" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>Number of Boolean variables. Must satisfy <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>.</p>
</dd>
<dt>bias<span class="classifier">float, optional</span></dt><dd><p>Probability that a truth-table entry equals 1. Default is 0.5.</p>
</dd>
<dt>rng<span class="classifier">int, np.random.Generator, np.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id20">
<h2>Returns<a class="headerlink" href="#id20" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>BooleanFunction</dt><dd><p>Random non-canalizing Boolean function on <code class="docutils literal notranslate"><span class="pre">n</span></code> variables.</p>
</dd>
</dl>
</section>
<section id="id21">
<h2>Raises<a class="headerlink" href="#id21" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">n</span></code> is not an integer greater than 1.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">bias</span></code> is not strictly between 0 and 1.</p>
</dd>
</dl>
</section>
<section id="id22">
<h2>Notes<a class="headerlink" href="#id22" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>This function uses rejection sampling.</p></li>
<li><p>For moderate bias values, almost all Boolean functions are
non-canalizing.</p></li>
<li><p>Extremely biased functions are more likely to be canalizing and may
lead to longer sampling times.</p></li>
</ul>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading"></a></h2>
<p>C. Kadelka, J. Kuipers, and R. Laubenbacher (2017).
The influence of canalization on the robustness of Boolean networks.
Physica D: Nonlinear Phenomena, 353, 39–47.</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_non_canalizing_non_degenerate_function">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_non_canalizing_non_degenerate_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="boolean_function.html#boolforge.boolean_function.BooleanFunction" title="boolforge.boolean_function.BooleanFunction"><span class="pre">BooleanFunction</span></a></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_non_canalizing_non_degenerate_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_non_canalizing_non_degenerate_function" title="Link to this definition"></a></dt>
<dd><p>Generate a random Boolean function that is both non-canalizing and
non-degenerate.</p>
<p>A Boolean function is non-canalizing if no variable can force the output
when fixed, and non-degenerate if every variable is essential. This
function samples Boolean functions from the Bernoulli(bias) ensemble
until both properties are satisfied.</p>
<section id="id23">
<h2>Parameters<a class="headerlink" href="#id23" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>Number of Boolean variables. Must satisfy <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>.</p>
</dd>
<dt>bias<span class="classifier">float, optional</span></dt><dd><p>Probability that a truth-table entry equals 1. Default is 0.5.</p>
</dd>
<dt>rng<span class="classifier">int, np.random.Generator, np.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id24">
<h2>Returns<a class="headerlink" href="#id24" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>BooleanFunction</dt><dd><p>Random Boolean function on <code class="docutils literal notranslate"><span class="pre">n</span></code> variables that is both non-canalizing
and non-degenerate.</p>
</dd>
</dl>
</section>
<section id="id25">
<h2>Raises<a class="headerlink" href="#id25" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">n</span></code> is not an integer greater than 1.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">bias</span></code> is not strictly between 0 and 1.</p>
</dd>
</dl>
</section>
<section id="id26">
<h2>Notes<a class="headerlink" href="#id26" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>This function uses rejection sampling.</p></li>
<li><p>For moderate bias values and sufficiently large <code class="docutils literal notranslate"><span class="pre">n</span></code>, almost all
Boolean functions are both non-canalizing and non-degenerate.</p></li>
<li><p>Extremely biased functions are more likely to be canalizing or
degenerate and may lead to longer sampling times.</p></li>
</ul>
</section>
<section id="id27">
<h2>References<a class="headerlink" href="#id27" title="Link to this heading"></a></h2>
<p>C. Kadelka, J. Kuipers, and R. Laubenbacher (2017).
The influence of canalization on the robustness of Boolean networks.
Physica D: Nonlinear Phenomena, 353, 39–47.</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.sample_canalized_outputs_uniform_structure">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">sample_canalized_outputs_uniform_structure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/generate.html#sample_canalized_outputs_uniform_structure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.sample_canalized_outputs_uniform_structure" title="Link to this definition"></a></dt>
<dd><p>Sample a canalized output bitstring yielding uniform layer-structure weighting.</p>
<p>This function samples a binary vector <code class="docutils literal notranslate"><span class="pre">b</span></code> of length <code class="docutils literal notranslate"><span class="pre">n</span></code> representing
canalized output values, where consecutive equal values are part of the same
canalizing layer. The probability of a given layer structure
<code class="docutils literal notranslate"><span class="pre">(k_1,</span> <span class="pre">k_2,</span> <span class="pre">...,</span> <span class="pre">k_r)</span></code> is proportional to</p>
<blockquote>
<div><p>1 / (k_1! k_2! … k_r!).</p>
</div></blockquote>
<p>Sampling is performed sequentially using precomputed dynamic-programming
weights <code class="docutils literal notranslate"><span class="pre">W</span></code>, stored in _uniform_structure_weights.</p>
<section id="id28">
<h2>Parameters<a class="headerlink" href="#id28" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>Length of the output bitstring to sample.</p>
</dd>
<dt>W<span class="classifier">ndarray of shape (n+1, n+1)</span></dt><dd><p>Dynamic-programming weight table, where <code class="docutils literal notranslate"><span class="pre">W[m,</span> <span class="pre">s]</span></code> gives the total
weight of all valid completions with <code class="docutils literal notranslate"><span class="pre">m</span></code> positions remaining and
current layer size <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
</dd>
<dt>rng<span class="classifier">numpy.random.Generator</span></dt><dd><p>Random number generator used for sampling.</p>
</dd>
</dl>
</section>
<section id="id29">
<h2>Returns<a class="headerlink" href="#id29" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>b<span class="classifier">ndarray of shape (n,), dtype int</span></dt><dd><p>Sampled binary canalized output vector.</p>
</dd>
</dl>
</section>
<section id="id30">
<h2>Notes<a class="headerlink" href="#id30" title="Link to this heading"></a></h2>
<p>The bitstring is generated left-to-right. At each step, the algorithm
probabilistically chooses whether to extend the current layer or start a
new one, using the weights in <code class="docutils literal notranslate"><span class="pre">W</span></code> to ensure correct global sampling
probabilities. The first bit is chosen uniformly at random.</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_k_canalizing_function">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_k_canalizing_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">EXACT_DEPTH</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">UNIFORM_STRUCTURE</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ALLOW_DEGENERATE_FUNCTIONS</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="boolean_function.html#boolforge.boolean_function.BooleanFunction" title="boolforge.boolean_function.BooleanFunction"><span class="pre">BooleanFunction</span></a></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_k_canalizing_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_k_canalizing_function" title="Link to this definition"></a></dt>
<dd><p>Generate a random k-canalizing Boolean function in n variables.</p>
<p>A Boolean function is k-canalizing if it has at least k conditionally 
canalizing variables. If <code class="docutils literal notranslate"><span class="pre">EXACT_DEPTH</span></code> is True, the function has exactly
k conditionally canalizing variables; otherwise, its canalizing depth 
may exceed k.</p>
<section id="id31">
<h2>Parameters<a class="headerlink" href="#id31" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>Number of Boolean variables.</p>
</dd>
<dt>k<span class="classifier">int</span></dt><dd><p>Requested canalizing depth. Must satisfy <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>.
Setting <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">n</span></code> generates a nested canalizing function.</p>
</dd>
<dt>EXACT_DEPTH<span class="classifier">bool, optional</span></dt><dd><p>If True, enforce that the canalizing depth is exactly <code class="docutils literal notranslate"><span class="pre">k</span></code>.
If False (default), the depth is at least <code class="docutils literal notranslate"><span class="pre">k</span></code>.</p>
</dd>
<dt>UNIFORM_STRUCTURE<span class="classifier">bool, optional</span></dt><dd><p>If True (default), canalized outputs are sampled uniformly over
canalizing layer structures. Specifically, layer structures
<code class="docutils literal notranslate"><span class="pre">(k_1,</span> <span class="pre">...,</span> <span class="pre">k_r)</span></code> are sampled with probability proportional to
<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">(k_1!</span> <span class="pre">...</span> <span class="pre">k_r!)</span></code>, removing the bias toward symmetric
structures induced by independent sampling.
If <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">==</span> <span class="pre">n</span></code>, the nested canalizing constraint that the final
layer has size at least 2 is enforced.
If False, canalized outputs are sampled independently and
uniformly as a bitstring, which biases the distribution toward
more symmetric layer structures.</p>
</dd>
<dt>ALLOW_DEGENERATE_FUNCTIONS<span class="classifier">bool, optional</span></dt><dd><p>If True, the non-canalizing core function may be degenerate.
If False (default), non-degenerate core functions are enforced
whenever possible.</p>
</dd>
<dt>rng<span class="classifier">int, numpy.random.Generator, numpy.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id32">
<h2>Returns<a class="headerlink" href="#id32" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>BooleanFunction</dt><dd><p>A Boolean function on <code class="docutils literal notranslate"><span class="pre">n</span></code> variables with canalizing depth at
least <code class="docutils literal notranslate"><span class="pre">k</span></code> (or exactly <code class="docutils literal notranslate"><span class="pre">k</span></code> if <code class="docutils literal notranslate"><span class="pre">EXACT_DEPTH=True</span></code>).</p>
</dd>
</dl>
</section>
<section id="id33">
<h2>Raises<a class="headerlink" href="#id33" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>AssertionError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">n</span></code> is not a positive integer.</p>
</dd>
<dt>AssertionError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">k</span></code> does not satisfy <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>.</p>
</dd>
<dt>AssertionError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">EXACT_DEPTH=True</span></code> and <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">n-1</span></code> (no such functions exist).</p>
</dd>
</dl>
</section>
<section id="id34">
<h2>Notes<a class="headerlink" href="#id34" title="Link to this heading"></a></h2>
<p>For fixed parameter values, this function samples uniformly at random
from the ensemble of Boolean functions consistent with the specified
constraints. Non-uniformity arises only when
<code class="docutils literal notranslate"><span class="pre">UNIFORM_STRUCTURE=False</span></code>.</p>
<p>The construction follows the standard decomposition of a k-canalizing
function into canalizing variables, canalizing inputs and outputs, and
a residual core function on <code class="docutils literal notranslate"><span class="pre">n-k</span></code> variables.</p>
</section>
<section id="id35">
<h2>References<a class="headerlink" href="#id35" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>He, Q., and Macauley, M. (2016).</dt><dd><p>Stratification and enumeration of Boolean functions by canalizing depth.
Physica D: Nonlinear Phenomena, 314, 1–8.</p>
</dd>
<dt>Dimitrova, E., Stigler, B., Kadelka, C., and Murrugarra, D. (2022).</dt><dd><p>Revealing the canalizing structure of Boolean functions: Algorithms
and applications. Automatica, 146, 110630.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_k_canalizing_function_with_specific_layer_structure">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_k_canalizing_function_with_specific_layer_structure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_structure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">EXACT_DEPTH</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ALLOW_DEGENERATE_FUNCTIONS</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="boolean_function.html#boolforge.boolean_function.BooleanFunction" title="boolforge.boolean_function.BooleanFunction"><span class="pre">BooleanFunction</span></a></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_k_canalizing_function_with_specific_layer_structure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_k_canalizing_function_with_specific_layer_structure" title="Link to this definition"></a></dt>
<dd><p>Generate a random Boolean function with a specified canalizing layer structure.</p>
<p>The canalizing layer structure is given as a list
<code class="docutils literal notranslate"><span class="pre">[k_1,</span> <span class="pre">...,</span> <span class="pre">k_r]</span></code>, where each <code class="docutils literal notranslate"><span class="pre">k_i</span></code> specifies the number of
canalizing variables in the i-th layer. The total canalizing depth is
<code class="docutils literal notranslate"><span class="pre">sum(layer_structure)</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">sum(layer_structure)</span> <span class="pre">==</span> <span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, the function is a nested
canalizing function and the final layer is required to have size at
least 2.</p>
<section id="id36">
<h2>Parameters<a class="headerlink" href="#id36" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>Total number of Boolean variables.</p>
</dd>
<dt>layer_structure<span class="classifier">list of int</span></dt><dd><p>Canalizing layer structure <code class="docutils literal notranslate"><span class="pre">[k_1,</span> <span class="pre">...,</span> <span class="pre">k_r]</span></code>. Each entry must be
at least 1. If <code class="docutils literal notranslate"><span class="pre">sum(layer_structure)</span> <span class="pre">==</span> <span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, the final
entry must satisfy <code class="docutils literal notranslate"><span class="pre">layer_structure[-1]</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code>.</p>
</dd>
<dt>EXACT_DEPTH<span class="classifier">bool, optional</span></dt><dd><p>If True, enforce that the canalizing depth is exactly
<code class="docutils literal notranslate"><span class="pre">sum(layer_structure)</span></code>. If False (default), additional canalizing
variables may occur in the core function.</p>
</dd>
<dt>ALLOW_DEGENERATE_FUNCTIONS<span class="classifier">bool, optional</span></dt><dd><p>If True, the non-canalizing core function may be degenerate.
If False (default), non-degenerate core functions are enforced
whenever possible.</p>
</dd>
<dt>rng<span class="classifier">int, numpy.random.Generator, numpy.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id37">
<h2>Returns<a class="headerlink" href="#id37" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>BooleanFunction</dt><dd><p>A Boolean function on <code class="docutils literal notranslate"><span class="pre">n</span></code> variables with the prescribed canalizing
layer structure.</p>
</dd>
</dl>
</section>
<section id="id38">
<h2>Raises<a class="headerlink" href="#id38" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>AssertionError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">n</span></code> is not a positive integer.</p>
</dd>
<dt>AssertionError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">sum(layer_structure)</span></code> does not satisfy <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">sum(layer_structure)</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>.</p>
</dd>
<dt>AssertionError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">EXACT_DEPTH=True</span></code> and <code class="docutils literal notranslate"><span class="pre">sum(layer_structure)</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
<dt>AssertionError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">sum(layer_structure)</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> and the final layer has size less
than 2.</p>
</dd>
<dt>AssertionError</dt><dd><p>If any entry of <code class="docutils literal notranslate"><span class="pre">layer_structure</span></code> is less than 1.</p>
</dd>
</dl>
</section>
<section id="id39">
<h2>Notes<a class="headerlink" href="#id39" title="Link to this heading"></a></h2>
<p>For fixed parameter values, this function samples uniformly at random
from the ensemble of Boolean functions consistent with the specified
canalizing layer structure and additional constraints.</p>
<p>The construction follows the standard decomposition of a canalizing
function into ordered canalizing layers and a residual core function on
the remaining variables.</p>
</section>
<section id="id40">
<h2>References<a class="headerlink" href="#id40" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>He, Q., and Macauley, M. (2016).</dt><dd><p>Stratification and enumeration of Boolean functions by canalizing depth.
Physica D: Nonlinear Phenomena, 314, 1–8.</p>
</dd>
<dt>Kadelka, C., Kuipers, J., and Laubenbacher, R. (2017).</dt><dd><p>The influence of canalization on the robustness of Boolean networks.
Physica D: Nonlinear Phenomena, 353, 39–47.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_NCF">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_NCF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">UNIFORM_STRUCTURE</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_structure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="boolean_function.html#boolforge.boolean_function.BooleanFunction" title="boolforge.boolean_function.BooleanFunction"><span class="pre">BooleanFunction</span></a></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_NCF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_NCF" title="Link to this definition"></a></dt>
<dd><p>Generate a random nested canalizing Boolean function in n variables.</p>
<p>A nested canalizing function (NCF) is an n-canalizing Boolean function,
i.e., a function whose canalizing depth equals the number of variables.
Optionally, a specific canalizing layer structure may be prescribed.</p>
<section id="id41">
<h2>Parameters<a class="headerlink" href="#id41" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>Total number of Boolean variables.</p>
</dd>
<dt>UNIFORM_STRUCTURE<span class="classifier">bool, optional</span></dt><dd><p>If True (default) and <code class="docutils literal notranslate"><span class="pre">layer_structure</span></code> is None, canalizing layer
structures are sampled uniformly at random, removing the bias toward
symmetric structures induced by independent sampling of canalized
outputs. If False, canalized outputs are sampled independently and
uniformly as a bitstring, which biases the distribution toward more
symmetric layer structures.
This parameter is ignored if <code class="docutils literal notranslate"><span class="pre">layer_structure</span></code> is provided.</p>
</dd>
<dt>layer_structure<span class="classifier">list of int or None, optional</span></dt><dd><p>Canalizing layer structure <code class="docutils literal notranslate"><span class="pre">[k_1,</span> <span class="pre">...,</span> <span class="pre">k_r]</span></code>. Each entry must be at
least 1. If provided, it must satisfy <code class="docutils literal notranslate"><span class="pre">sum(layer_structure)</span> <span class="pre">==</span> <span class="pre">n</span></code>.
If <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, the final entry must satisfy
<code class="docutils literal notranslate"><span class="pre">layer_structure[-1]</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code>. If None (default), the layer structure
is sampled at random.</p>
</dd>
<dt>rng<span class="classifier">int, numpy.random.Generator, numpy.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id42">
<h2>Returns<a class="headerlink" href="#id42" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>BooleanFunction</dt><dd><p>A nested canalizing Boolean function on <code class="docutils literal notranslate"><span class="pre">n</span></code> variables.</p>
</dd>
</dl>
</section>
<section id="id43">
<h2>Raises<a class="headerlink" href="#id43" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>AssertionError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">n</span></code> is not a positive integer.</p>
</dd>
<dt>AssertionError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">layer_structure</span></code> is provided but does not satisfy
<code class="docutils literal notranslate"><span class="pre">sum(layer_structure)</span> <span class="pre">==</span> <span class="pre">n</span></code>.</p>
</dd>
<dt>AssertionError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> and the final layer has size less than 2.</p>
</dd>
</dl>
</section>
<section id="id44">
<h2>Notes<a class="headerlink" href="#id44" title="Link to this heading"></a></h2>
<p>For fixed parameter values, this function samples uniformly at random
from the ensemble of nested canalizing Boolean functions consistent with
the specified constraints. Non-uniformity arises only when
<code class="docutils literal notranslate"><span class="pre">UNIFORM_STRUCTURE=False</span></code>.</p>
<p>This function is a convenience wrapper around
<code class="docutils literal notranslate"><span class="pre">random_k_canalizing_function</span></code> and
<code class="docutils literal notranslate"><span class="pre">random_k_canalizing_function_with_specific_layer_structure</span></code>.</p>
</section>
<section id="id45">
<h2>References<a class="headerlink" href="#id45" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>He, Q., and Macauley, M. (2016).</dt><dd><p>Stratification and enumeration of Boolean functions by canalizing depth.
Physica D: Nonlinear Phenomena, 314, 1–8.</p>
</dd>
<dt>Kadelka, C., Kuipers, J., and Laubenbacher, R. (2017).</dt><dd><p>The influence of canalization on the robustness of Boolean networks.
Physica D: Nonlinear Phenomena, 353, 39–47.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_degrees">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_degrees</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indegree_distribution</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NO_SELF_REGULATION</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_degrees"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_degrees" title="Link to this definition"></a></dt>
<dd><p>Draw an in-degree vector for a directed network with N nodes.</p>
<p>This function either accepts a user-specified in-degree vector or
samples in-degrees independently for each node from a specified
distribution.</p>
<section id="id46">
<h2>Parameters<a class="headerlink" href="#id46" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>N<span class="classifier">int</span></dt><dd><p>Number of nodes in the network. Must be a positive integer.</p>
</dd>
<dt>n<span class="classifier">int, float, list of int, or ndarray of int</span></dt><dd><p>Interpretation depends on <code class="docutils literal notranslate"><span class="pre">indegree_distribution</span></code>:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">n</span></code> is a length-<code class="docutils literal notranslate"><span class="pre">N</span></code> vector of integers, it is interpreted
as a user-specified in-degree sequence and returned after
validation.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">indegree_distribution</span></code> is one of
<code class="docutils literal notranslate"><span class="pre">{'constant',</span> <span class="pre">'dirac',</span> <span class="pre">'delta'}</span></code>, then <code class="docutils literal notranslate"><span class="pre">n</span></code> is a single integer
specifying the in-degree of every node.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">indegree_distribution</span> <span class="pre">==</span> <span class="pre">'uniform'</span></code>, then <code class="docutils literal notranslate"><span class="pre">n</span></code> is a positive
integer upper bound, and each node independently receives an
in-degree sampled uniformly from
<code class="docutils literal notranslate"><span class="pre">{1,</span> <span class="pre">2,</span> <span class="pre">...,</span> <span class="pre">n}</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">indegree_distribution</span> <span class="pre">==</span> <span class="pre">'poisson'</span></code>, then <code class="docutils literal notranslate"><span class="pre">n</span></code> is the Poisson
rate parameter <code class="docutils literal notranslate"><span class="pre">λ</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. Each node independently receives a
Poisson(<code class="docutils literal notranslate"><span class="pre">λ</span></code>) draw, truncated to lie in
<code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">N</span> <span class="pre">-</span> <span class="pre">int(NO_SELF_REGULATION)]</span></code>.</p></li>
</ul>
</dd>
<dt>indegree_distribution<span class="classifier">str, optional</span></dt><dd><p>Distribution used to generate in-degrees when <code class="docutils literal notranslate"><span class="pre">n</span></code> is not a vector.
Must be one of <code class="docutils literal notranslate"><span class="pre">{'constant',</span> <span class="pre">'dirac',</span> <span class="pre">'delta',</span> <span class="pre">'uniform',</span> <span class="pre">'poisson'}</span></code>.
Default is <code class="docutils literal notranslate"><span class="pre">'constant'</span></code>.</p>
</dd>
<dt>NO_SELF_REGULATION<span class="classifier">bool, optional</span></dt><dd><p>If True (default), self-loops are disallowed in subsequent wiring
generation. This is enforced here by capping in-degrees at <code class="docutils literal notranslate"><span class="pre">N-1</span></code>.
If False, in-degrees may be as large as <code class="docutils literal notranslate"><span class="pre">N</span></code>.</p>
</dd>
<dt>rng<span class="classifier">int, numpy.random.Generator, numpy.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id47">
<h2>Returns<a class="headerlink" href="#id47" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>indegrees<span class="classifier">ndarray of int, shape (N,)</span></dt><dd><p>In-degree of each node. For sampled distributions, values lie in
<code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">N</span> <span class="pre">-</span> <span class="pre">int(NO_SELF_REGULATION)]</span></code>.</p>
</dd>
</dl>
</section>
<section id="id48">
<h2>Raises<a class="headerlink" href="#id48" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>AssertionError</dt><dd><p>If inputs are malformed, out of range, or an unsupported distribution
is requested.</p>
</dd>
</dl>
</section>
<section id="id49">
<h2>Notes<a class="headerlink" href="#id49" title="Link to this heading"></a></h2>
<p>When sampling is requested, in-degrees for different nodes are generated
independently. No attempt is made to enforce graphicality or feasibility
of the resulting degree sequence for a particular wiring model; such
constraints must be handled downstream.</p>
</section>
<section id="id50">
<h2>Examples<a class="headerlink" href="#id50" title="Link to this heading"></a></h2>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">random_degrees</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">indegree_distribution</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
<span class="go">array([2, 2, 2, 2, 2])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">random_degrees</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">indegree_distribution</span><span class="o">=</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="n">NO_SELF_REGULATION</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([2, 1, 2, 2])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">random_degrees</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mf">1.7</span><span class="p">,</span> <span class="n">indegree_distribution</span><span class="o">=</span><span class="s1">&#39;poisson&#39;</span><span class="p">)</span>
<span class="go">array([1, 2, 1, 1, 2, 1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">random_degrees</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([1, 2, 1])</span>
</pre></div>
</div>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_edge_list">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_edge_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indegrees</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NO_SELF_REGULATION</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AT_LEAST_ONE_REGULATOR_PER_NODE</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_edge_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_edge_list" title="Link to this definition"></a></dt>
<dd><p>Generate a random directed edge list for a network with prescribed in-degrees.</p>
<p>Each node <code class="docutils literal notranslate"><span class="pre">i</span></code> receives exactly <code class="docutils literal notranslate"><span class="pre">indegrees[i]</span></code> incoming edges, with
regulators chosen uniformly at random from the set of admissible source
nodes. Optionally, the construction enforces that every node regulates at
least one other node.</p>
<section id="id51">
<h2>Parameters<a class="headerlink" href="#id51" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>N<span class="classifier">int</span></dt><dd><p>Number of nodes in the network.</p>
</dd>
<dt>indegrees<span class="classifier">sequence of int</span></dt><dd><p>Length-<code class="docutils literal notranslate"><span class="pre">N</span></code> sequence specifying the number of incoming edges for each
node.</p>
</dd>
<dt>NO_SELF_REGULATION<span class="classifier">bool</span></dt><dd><p>If True, self-loops (edges from a node to itself) are disallowed.</p>
</dd>
<dt>AT_LEAST_ONE_REGULATOR_PER_NODE<span class="classifier">bool, optional</span></dt><dd><p>If True, enforce that every node has at least one outgoing edge.
This is achieved by rewiring edges while preserving the prescribed
in-degree sequence. Default is False.</p>
</dd>
<dt>rng<span class="classifier">int, numpy.random.Generator, numpy.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id52">
<h2>Returns<a class="headerlink" href="#id52" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>edge_list<span class="classifier">list of tuple of int</span></dt><dd><p>List of directed edges represented as <code class="docutils literal notranslate"><span class="pre">(source,</span> <span class="pre">target)</span></code> pairs.</p>
</dd>
</dl>
</section>
<section id="id53">
<h2>Raises<a class="headerlink" href="#id53" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">N</span></code> or <code class="docutils literal notranslate"><span class="pre">indegrees</span></code> are inconsistent.</p>
</dd>
<dt>AssertionError</dt><dd><p>If sampling constraints cannot be satisfied.</p>
</dd>
</dl>
</section>
<section id="id54">
<h2>Notes<a class="headerlink" href="#id54" title="Link to this heading"></a></h2>
<p>Regulators for each node are sampled uniformly at random without
replacement from the set of admissible source nodes. If
<code class="docutils literal notranslate"><span class="pre">AT_LEAST_ONE_REGULATOR_PER_NODE</span></code>, the algorithm post-processes
the initially sampled edge list by replacing edges until every node
has at least one outgoing edge, while preserving all in-degrees and
respecting the self-regulation constraint.</p>
<p>No guarantee is made that the resulting edge list is uniformly sampled
from the space of all directed graphs satisfying the constraints.</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_wiring_diagram">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_wiring_diagram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NO_SELF_REGULATION</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">STRONGLY_CONNECTED</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indegree_distribution</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AT_LEAST_ONE_REGULATOR_PER_NODE</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_attempts_to_generate_strongly_connected_network</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_wiring_diagram"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_wiring_diagram" title="Link to this definition"></a></dt>
<dd><p>Generate a random wiring diagram for a directed network with N nodes.</p>
<p>A wiring diagram specifies, for each node, the set of its regulators
(incoming neighbors). In-degrees are first generated according to the
specified distribution, after which edges are sampled uniformly at
random subject to the requested constraints.</p>
<section id="id55">
<h2>Parameters<a class="headerlink" href="#id55" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>N<span class="classifier">int</span></dt><dd><p>Number of nodes in the network.</p>
</dd>
<dt>n<span class="classifier">int, float, list of int, or ndarray of int</span></dt><dd><p>Parameter determining the in-degree sequence. Interpretation depends
on <code class="docutils literal notranslate"><span class="pre">indegree_distribution</span></code>:</p>
<ul class="simple">
<li><p>If a length-<code class="docutils literal notranslate"><span class="pre">N</span></code> vector is provided, it is interpreted as the
in-degree of each node.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">indegree_distribution</span></code> is <code class="docutils literal notranslate"><span class="pre">'constant'</span></code> (or <code class="docutils literal notranslate"><span class="pre">'dirac'</span></code> /
<code class="docutils literal notranslate"><span class="pre">'delta'</span></code>), <code class="docutils literal notranslate"><span class="pre">n</span></code> specifies the in-degree of every node.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">indegree_distribution</span></code> is <code class="docutils literal notranslate"><span class="pre">'uniform'</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> specifies the
upper bound of a discrete uniform distribution on
<code class="docutils literal notranslate"><span class="pre">{1,</span> <span class="pre">...,</span> <span class="pre">n}</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">indegree_distribution</span></code> is <code class="docutils literal notranslate"><span class="pre">'poisson'</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> is the Poisson
rate parameter <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p></li>
</ul>
</dd>
<dt>NO_SELF_REGULATION<span class="classifier">bool, optional</span></dt><dd><p>If True (default), self-loops are disallowed.</p>
</dd>
<dt>STRONGLY_CONNECTED<span class="classifier">bool, optional</span></dt><dd><p>If True, repeatedly resample the wiring diagram until a strongly
connected network is obtained, or until the maximum number of
attempts is exceeded. Default is False.</p>
</dd>
<dt>indegree_distribution<span class="classifier">str, optional</span></dt><dd><p>Distribution used to generate in-degrees. Must be one of
<code class="docutils literal notranslate"><span class="pre">{'constant',</span> <span class="pre">'dirac',</span> <span class="pre">'delta',</span> <span class="pre">'uniform',</span> <span class="pre">'poisson'}</span></code>.
Default is <code class="docutils literal notranslate"><span class="pre">'constant'</span></code>.</p>
</dd>
<dt>AT_LEAST_ONE_REGULATOR_PER_NODE<span class="classifier">bool, optional</span></dt><dd><p>If True, enforce that every node has at least one outgoing edge.
This is achieved by rewiring edges while preserving the in-degree
sequence. Default is False.</p>
</dd>
<dt>n_attempts_to_generate_strongly_connected_network<span class="classifier">int, optional</span></dt><dd><p>Maximum number of attempts to generate a strongly connected wiring
diagram before raising a <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code>. Default is 1000.</p>
</dd>
<dt>rng<span class="classifier">int, numpy.random.Generator, numpy.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id56">
<h2>Returns<a class="headerlink" href="#id56" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>WiringDiagram</dt><dd><p>A wiring diagram object encoding the regulator set of each node.</p>
</dd>
</dl>
</section>
<section id="id57">
<h2>Raises<a class="headerlink" href="#id57" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>RuntimeError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">STRONGLY_CONNECTED=True</span></code> and a strongly connected wiring diagram
cannot be generated within the specified number of attempts.</p>
</dd>
</dl>
</section>
<section id="id58">
<h2>Notes<a class="headerlink" href="#id58" title="Link to this heading"></a></h2>
<p>In-degrees are generated first using <code class="docutils literal notranslate"><span class="pre">random_degrees</span></code>, and edges are
then sampled uniformly at random subject to the imposed constraints.
When <code class="docutils literal notranslate"><span class="pre">STRONGLY_CONNECTED=True</span></code> or
<code class="docutils literal notranslate"><span class="pre">AT_LEAST_ONE_REGULATOR_PER_NODE=True</span></code>, the resulting distribution is
not uniform over all wiring diagrams with the given in-degree sequence.</p>
<p>This function is a high-level convenience wrapper around
<code class="docutils literal notranslate"><span class="pre">random_degrees</span></code> and <code class="docutils literal notranslate"><span class="pre">random_edge_list</span></code>.</p>
</section>
<section id="id59">
<h2>Examples<a class="headerlink" href="#id59" title="Link to this heading"></a></h2>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span> <span class="o">=</span> <span class="n">random_wiring_diagram</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W</span> <span class="o">=</span> <span class="n">random_wiring_diagram</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">STRONGLY_CONNECTED</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W</span> <span class="o">=</span> <span class="n">random_wiring_diagram</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.rewire_wiring_diagram">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">rewire_wiring_diagram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">I</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">WiringDiagram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average_swaps_per_edge</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DO_NOT_ADD_SELF_REGULATION</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FIX_SELF_REGULATION</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="reference internal" href="_modules/boolforge/generate.html#rewire_wiring_diagram"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.rewire_wiring_diagram" title="Link to this definition"></a></dt>
<dd><p>Degree-preserving rewiring of a wiring diagram via double-edge swaps.</p>
<p>The wiring diagram is represented in regulator form: <code class="docutils literal notranslate"><span class="pre">I[target]</span></code> lists
all regulators (incoming neighbors) of <code class="docutils literal notranslate"><span class="pre">target</span></code>. The algorithm performs
random double-edge swaps of the form
<code class="docutils literal notranslate"><span class="pre">(u</span> <span class="pre">-&gt;</span> <span class="pre">v,</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">y)</span> <span class="pre">-&gt;</span> <span class="pre">(u</span> <span class="pre">-&gt;</span> <span class="pre">y,</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">v)</span></code>, while preserving both the
in-degree and out-degree of every node. Parallel edges are disallowed.</p>
<section id="id60">
<h2>Parameters<a class="headerlink" href="#id60" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>I<span class="classifier">list of array-like or WiringDiagram</span></dt><dd><p>Wiring diagram in regulator representation. For each node <code class="docutils literal notranslate"><span class="pre">target</span></code>,
<code class="docutils literal notranslate"><span class="pre">I[target]</span></code> contains the regulators of that node. Regulator indices
must be integers in <code class="docutils literal notranslate"><span class="pre">{0,</span> <span class="pre">...,</span> <span class="pre">N-1}</span></code>. If a <code class="docutils literal notranslate"><span class="pre">WiringDiagram</span></code> is
provided, its internal adjacency representation is used.</p>
</dd>
<dt>average_swaps_per_edge<span class="classifier">float, optional</span></dt><dd><p>Target number of successful double-edge swaps per edge. Larger values
typically yield better mixing but increase runtime. Default is 10.</p>
</dd>
<dt>DO_NOT_ADD_SELF_REGULATION<span class="classifier">bool, optional</span></dt><dd><p>If True (default), proposed swaps that would introduce a self-loop
are rejected.</p>
</dd>
<dt>FIX_SELF_REGULATION<span class="classifier">bool, optional</span></dt><dd><p>If True (default), existing self-loops are kept fixed and excluded
from the pool of swappable edges. If False, existing self-loops may
be rewired; if <code class="docutils literal notranslate"><span class="pre">DO_NOT_ADD_SELF_REGULATION</span></code> is True, no new self-loops
will be introduced.</p>
</dd>
<dt>rng<span class="classifier">int, numpy.random.Generator, numpy.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id61">
<h2>Returns<a class="headerlink" href="#id61" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>WiringDiagram</dt><dd><p>A new wiring diagram obtained by degree-preserving rewiring of <code class="docutils literal notranslate"><span class="pre">I</span></code>.</p>
</dd>
</dl>
</section>
<section id="id62">
<h2>Raises<a class="headerlink" href="#id62" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>ValueError</dt><dd><p>If the input wiring diagram is malformed.</p>
</dd>
<dt>AssertionError</dt><dd><p>If rewiring constraints cannot be satisfied.</p>
</dd>
</dl>
</section>
<section id="id63">
<h2>Notes<a class="headerlink" href="#id63" title="Link to this heading"></a></h2>
<p>Both in-degrees and out-degrees of all nodes are preserved exactly.
Duplicate edges are never introduced. Control over self-regulation is
governed by the two Boolean flags above.</p>
<p>The resulting wiring diagram is not guaranteed to be sampled uniformly
from the space of all directed graphs with the same degree sequence; the
procedure is intended as a practical degree-preserving randomization
method rather than an exact uniform sampler.</p>
</section>
<section id="id64">
<h2>Examples<a class="headerlink" href="#id64" title="Link to this heading"></a></h2>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">random_network</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="n">rewire_wiring_diagram</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="o">.</span><span class="n">indegrees</span> <span class="o">==</span> <span class="n">J</span><span class="o">.</span><span class="n">indegrees</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="o">.</span><span class="n">get_outdegrees</span><span class="p">()</span> <span class="o">==</span> <span class="n">J</span><span class="o">.</span><span class="n">get_outdegrees</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_network">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">EXACT_DEPTH</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">UNIFORM_STRUCTURE</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_structure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ALLOW_DEGENERATE_FUNCTIONS</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PARITY</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">absolute_bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">USE_ABSOLUTE_BIAS</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hamming_weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NO_SELF_REGULATION</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">STRONGLY_CONNECTED</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indegree_distribution</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AT_LEAST_ONE_REGULATOR_PER_NODE</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_attempts_to_generate_strongly_connected_network</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">WiringDiagram</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">DiGraph</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="boolean_network.html#boolforge.boolean_network.BooleanNetwork" title="boolforge.boolean_network.BooleanNetwork"><span class="pre">BooleanNetwork</span></a></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_network" title="Link to this definition"></a></dt>
<dd><p>Construct a random Boolean network with configurable wiring and update rules.</p>
<p>The network is built in two stages:</p>
<ol class="arabic simple">
<li><p>Wiring diagram
If <code class="docutils literal notranslate"><span class="pre">I</span></code> is provided, it is used directly as the wiring diagram, where
<code class="docutils literal notranslate"><span class="pre">I[v]</span></code> lists the regulators of node <code class="docutils literal notranslate"><span class="pre">v</span></code>. Otherwise, a wiring diagram
for <code class="docutils literal notranslate"><span class="pre">N</span></code> nodes is sampled using <code class="docutils literal notranslate"><span class="pre">random_wiring_diagram</span></code>, with in-degrees
determined by <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">indegree_distribution</span></code>. Self-loops may be
disallowed and strong connectivity may be enforced.</p></li>
<li><p>Update rules
For each node <code class="docutils literal notranslate"><span class="pre">i</span></code>, a Boolean update function with arity
<code class="docutils literal notranslate"><span class="pre">indegrees[i]</span></code> is generated using <code class="docutils literal notranslate"><span class="pre">random_function</span></code> subject to the
requested constraints on canalizing depth or layer structure, parity,
bias or absolute bias, and exact Hamming weight.</p></li>
</ol>
<section id="id65">
<h2>Parameters<a class="headerlink" href="#id65" title="Link to this heading"></a></h2>
<dl>
<dt>N<span class="classifier">int or None, optional</span></dt><dd><p>Number of nodes. Required when <code class="docutils literal notranslate"><span class="pre">I</span></code> is not provided. Ignored if <code class="docutils literal notranslate"><span class="pre">I</span></code> is
given.</p>
</dd>
<dt>n<span class="classifier">int, float, list of int, ndarray of int, or None, optional</span></dt><dd><p>Controls the in-degree distribution when generating a wiring diagram
(ignored if <code class="docutils literal notranslate"><span class="pre">I</span></code> is given). Interpretation depends on
<code class="docutils literal notranslate"><span class="pre">indegree_distribution</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'constant'</span></code>, <code class="docutils literal notranslate"><span class="pre">'dirac'</span></code>, <code class="docutils literal notranslate"><span class="pre">'delta'</span></code>:
Every node has constant in-degree <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'uniform'</span></code>:
<code class="docutils literal notranslate"><span class="pre">n</span></code> is an integer upper bound; each node’s in-degree is sampled
uniformly from <code class="docutils literal notranslate"><span class="pre">{1,</span> <span class="pre">...,</span> <span class="pre">n}</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'poisson'</span></code>:
<code class="docutils literal notranslate"><span class="pre">n</span></code> is a positive rate parameter lambda; in-degrees are Poisson(lambda) 
draws truncated to <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">N</span> <span class="pre">-</span> <span class="pre">int(NO_SELF_REGULATION)]</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">n</span></code> is a length-<code class="docutils literal notranslate"><span class="pre">N</span></code> vector of integers, it is taken as the exact
in-degree sequence.</p></li>
</ul>
</dd>
<dt>depth<span class="classifier">int, list of int, or ndarray of int, optional</span></dt><dd><p>Requested canalizing depth per node. If an integer, it is broadcast to
all nodes and clipped at each node’s in-degree. If a vector, it must have
length <code class="docutils literal notranslate"><span class="pre">N</span></code>. Interpreted as a minimum depth unless <code class="docutils literal notranslate"><span class="pre">EXACT_DEPTH=True</span></code>.
Default is 0.</p>
</dd>
<dt>EXACT_DEPTH<span class="classifier">bool, optional</span></dt><dd><p>If True, each Boolean function is generated with exactly the requested
canalizing depth (or exactly <code class="docutils literal notranslate"><span class="pre">sum(layer_structure[i])</span></code> if a layer
structure is provided). If False, the canalizing depth is at least as
large as requested. Default is False.</p>
</dd>
<dt>UNIFORM_STRUCTURE<span class="classifier">bool, optional</span></dt><dd><p>Controls how canalized outputs are sampled when generating canalizing
functions.</p>
<p>If True (default), canalizing layer structures are sampled uniformly at
random, i.e., proportional to the inverse factorials of layer sizes,
removing the bias toward symmetric structures induced by independent
sampling of canalized outputs.</p>
<p>If False, canalized outputs are sampled independently and uniformly as
bitstrings, which biases the distribution toward more symmetric layer
structures.</p>
<p>This parameter is ignored when <code class="docutils literal notranslate"><span class="pre">layer_structure</span></code> is explicitly provided.</p>
</dd>
<dt>layer_structure<span class="classifier">list, list of lists, or None, optional</span></dt><dd><p>Canalizing layer structure specifications.</p>
<ul class="simple">
<li><p>If None (default), rule generation is controlled by <code class="docutils literal notranslate"><span class="pre">depth</span></code> and
<code class="docutils literal notranslate"><span class="pre">EXACT_DEPTH</span></code>.</p></li>
<li><p>If a single list <code class="docutils literal notranslate"><span class="pre">[k1,</span> <span class="pre">...,</span> <span class="pre">kr]</span></code>, the same structure is used for all
nodes.</p></li>
<li><p>If a list of lists of length <code class="docutils literal notranslate"><span class="pre">N</span></code>, <code class="docutils literal notranslate"><span class="pre">layer_structure[i]</span></code> is used for
node <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p></li>
</ul>
<p>In all cases, <code class="docutils literal notranslate"><span class="pre">sum(layer_structure[i])</span></code> must not exceed the in-degree
of node <code class="docutils literal notranslate"><span class="pre">i</span></code>. When provided, <code class="docutils literal notranslate"><span class="pre">layer_structure</span></code> takes precedence over
<code class="docutils literal notranslate"><span class="pre">depth</span></code>.</p>
</dd>
<dt>ALLOW_DEGENERATE_FUNCTIONS<span class="classifier">bool, optional</span></dt><dd><p>If True and <code class="docutils literal notranslate"><span class="pre">depth</span> <span class="pre">==</span> <span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">layer_structure</span> <span class="pre">is</span> <span class="pre">None</span></code>, degenerate
Boolean functions (with non-essential inputs) may be generated, as in
classical NK-Kauffman models. If False, generated functions are required
to be non-degenerate whenever possible. Default is False.</p>
</dd>
<dt>PARITY<span class="classifier">bool, optional</span></dt><dd><p>If True, parity Boolean functions are generated for all nodes and all
other rule parameters are ignored. Default is False.</p>
</dd>
<dt>bias<span class="classifier">float, list of float, or ndarray of float, optional</span></dt><dd><p>Probability of output 1 when generating random (non-canalizing) Boolean
functions. Used only when <code class="docutils literal notranslate"><span class="pre">depth</span> <span class="pre">==</span> <span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">layer_structure</span> <span class="pre">is</span> <span class="pre">None</span></code>,
<code class="docutils literal notranslate"><span class="pre">PARITY</span></code> is False, and <code class="docutils literal notranslate"><span class="pre">USE_ABSOLUTE_BIAS</span></code> is False. Scalars are
broadcast to length <code class="docutils literal notranslate"><span class="pre">N</span></code>. Must lie in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>. Default is 0.5.</p>
</dd>
<dt>absolute_bias<span class="classifier">float, list of float, or ndarray of float, optional</span></dt><dd><p>Absolute deviation from 0.5 used when <code class="docutils literal notranslate"><span class="pre">USE_ABSOLUTE_BIAS</span></code> is True.
Scalars are broadcast to length <code class="docutils literal notranslate"><span class="pre">N</span></code>. Must lie in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>. Default 0.0.</p>
</dd>
<dt>USE_ABSOLUTE_BIAS<span class="classifier">bool, optional</span></dt><dd><p>If True, the bias of each rule is chosen at random from
<code class="docutils literal notranslate"><span class="pre">{0.5*(1-absolute_bias),</span> <span class="pre">0.5*(1+absolute_bias)}</span></code>. If False, <code class="docutils literal notranslate"><span class="pre">bias</span></code> is
used directly. Default is True.</p>
</dd>
<dt>hamming_weight<span class="classifier">int, list of int, ndarray of int, or None, optional</span></dt><dd><p>Exact Hamming weight (number of ones) of each truth table. Scalars are
broadcast to length <code class="docutils literal notranslate"><span class="pre">N</span></code>. Values must lie in <code class="docutils literal notranslate"><span class="pre">{0,</span> <span class="pre">...,</span> <span class="pre">2^k}</span></code> for a
k-input function. Additional restrictions apply when requesting exact
depth zero. Default is None.</p>
</dd>
<dt>NO_SELF_REGULATION<span class="classifier">bool, optional</span></dt><dd><p>If True, self-loops are forbidden in generated wiring diagrams. Ignored
if <code class="docutils literal notranslate"><span class="pre">I</span></code> is provided. Default is True.</p>
</dd>
<dt>STRONGLY_CONNECTED<span class="classifier">bool, optional</span></dt><dd><p>If True, wiring generation is repeated until a strongly connected
directed graph is obtained or the attempt limit is exceeded. Ignored if
<code class="docutils literal notranslate"><span class="pre">I</span></code> is provided. Default is False.</p>
</dd>
<dt>indegree_distribution<span class="classifier">str, optional</span></dt><dd><p>Distribution used when sampling in-degrees. Must be one of
<code class="docutils literal notranslate"><span class="pre">{'constant',</span> <span class="pre">'dirac',</span> <span class="pre">'delta',</span> <span class="pre">'uniform',</span> <span class="pre">'poisson'}</span></code>. Default
<code class="docutils literal notranslate"><span class="pre">'constant'</span></code>.</p>
</dd>
<dt>AT_LEAST_ONE_REGULATOR_PER_NODE<span class="classifier">bool, optional</span></dt><dd><p>If True, ensure that each node has at least one outgoing edge in the
generated wiring diagram. Default is False.</p>
</dd>
<dt>n_attempts_to_generate_strongly_connected_network<span class="classifier">int, optional</span></dt><dd><p>Maximum number of attempts to generate a strongly connected wiring
diagram before raising an error. Default is 1000.</p>
</dd>
<dt>I<span class="classifier">list, ndarray, WiringDiagram, networkx.DiGraph, or None, optional</span></dt><dd><p>Existing wiring diagram. If provided, <code class="docutils literal notranslate"><span class="pre">N</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> are ignored and
in-degrees are inferred from <code class="docutils literal notranslate"><span class="pre">I</span></code>. If I is a BooleanNetwork, its wiring
diagram is reused and its Boolean update rules are ignored.</p>
</dd>
<dt>rng<span class="classifier">int, numpy.random.Generator, numpy.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id66">
<h2>Returns<a class="headerlink" href="#id66" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>BooleanNetwork</dt><dd><p>A Boolean network with wiring diagram <code class="docutils literal notranslate"><span class="pre">I</span></code> (given or generated) and
Boolean update functions generated according to the specified constraints.</p>
</dd>
</dl>
</section>
<section id="id67">
<h2>Raises<a class="headerlink" href="#id67" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>AssertionError</dt><dd><p>If input shapes or parameter combinations are invalid.</p>
</dd>
<dt>RuntimeError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">STRONGLY_CONNECTED=True</span></code> and a strongly connected wiring diagram
cannot be generated within the specified number of attempts.</p>
</dd>
</dl>
</section>
<section id="id68">
<h2>Notes<a class="headerlink" href="#id68" title="Link to this heading"></a></h2>
<p>Constraint precedence for rule generation is:
<code class="docutils literal notranslate"><span class="pre">PARITY</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">layer_structure</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">depth</span></code> / <code class="docutils literal notranslate"><span class="pre">EXACT_DEPTH</span></code> -&gt; bias or
Hamming-weight constraints.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">EXACT_DEPTH=True</span></code> and the requested depth is zero, Hamming weights
<code class="docutils literal notranslate"><span class="pre">{0,</span> <span class="pre">1,</span> <span class="pre">2^k</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">2^k}</span></code> correspond to canalizing functions and are therefore
disallowed.</p>
</section>
<section id="id69">
<h2>Examples<a class="headerlink" href="#id69" title="Link to this heading"></a></h2>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Boolean network with only essential inputs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span> <span class="o">=</span> <span class="n">random_network</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ALLOW_DEGENERATE_FUNCTIONS</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Classic NK-Kauffman network allowing degenerate rules</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span> <span class="o">=</span> <span class="n">random_network</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ALLOW_DEGENERATE_FUNCTIONS</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Fixed wiring: reuse an existing diagram but resample rules</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn0</span> <span class="o">=</span> <span class="n">random_network</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span>  <span class="o">=</span> <span class="n">random_network</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">bn</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Exact canalizing depth k for all nodes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span> <span class="o">=</span> <span class="n">random_network</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">EXACT_DEPTH</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Nested canalizing update rules with specific layer structure (broadcast)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span> <span class="o">=</span> <span class="n">random_network</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">layer_structure</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># same for all nodes</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Parity rules</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span> <span class="o">=</span> <span class="n">random_network</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">PARITY</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Poisson in-degrees (truncated), no self-regulation, request strong connectivity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span> <span class="o">=</span> <span class="n">random_network</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mf">1.6</span><span class="p">,</span> <span class="n">indegree_distribution</span><span class="o">=</span><span class="s1">&#39;poisson&#39;</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">NO_SELF_REGULATION</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">STRONGLY_CONNECTED</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Exact Hamming weights (broadcast)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span> <span class="o">=</span> <span class="n">random_network</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">hamming_weight</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># To ensure strong connectivity, set ALLOW_DEGENERATE_FUNCTIONS=False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and STRONGLY_CONNECTED=True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span> <span class="o">=</span> <span class="n">random_network</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">ALLOW_DEGENERATE_FUNCTIONS</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">STRONGLY_CONNECTED</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="boolforge.generate.random_null_model">
<span class="sig-prename descclassname"><span class="pre">boolforge.generate.</span></span><span class="sig-name descname"><span class="pre">random_null_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bn</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="boolean_network.html#boolforge.boolean_network.BooleanNetwork" title="boolforge.boolean_network.BooleanNetwork"><span class="pre">BooleanNetwork</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">wiring_diagram</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'fixed'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PRESERVE_BIAS</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PRESERVE_CANALIZING_DEPTH</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="boolean_network.html#boolforge.boolean_network.BooleanNetwork" title="boolforge.boolean_network.BooleanNetwork"><span class="pre">BooleanNetwork</span></a></span></span><a class="reference internal" href="_modules/boolforge/generate.html#random_null_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.generate.random_null_model" title="Link to this definition"></a></dt>
<dd><p>Generate a randomized Boolean network (null model) from an existing
Boolean network while preserving selected structural and dynamical
properties.</p>
<p>The returned network has the same number of nodes as <code class="docutils literal notranslate"><span class="pre">bn</span></code>. Depending
on the selected options, the wiring diagram and/or the Boolean update
rules are randomized subject to specified invariants.</p>
<section id="wiring-diagram-randomization">
<h2>Wiring diagram randomization<a class="headerlink" href="#wiring-diagram-randomization" title="Link to this heading"></a></h2>
<p>The wiring diagram can be handled in one of three ways:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'fixed'</span></code> (default):
The original wiring diagram <code class="docutils literal notranslate"><span class="pre">bn.I</span></code> is reused unchanged.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'fixed_indegree'</span></code>:
A new wiring diagram is sampled uniformly at random subject to
preserving the in-degree of each node. This uses
<code class="docutils literal notranslate"><span class="pre">random_wiring_diagram</span></code> with <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">bn.N</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">bn.indegrees</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'fixed_in_and_outdegree'</span></code>:
The original wiring diagram is randomized via degree-preserving
double-edge swaps using <code class="docutils literal notranslate"><span class="pre">rewire_wiring_diagram</span></code>, preserving both
in-degrees and out-degrees of all nodes.</p></li>
</ul>
</section>
<section id="rule-randomization">
<h2>Rule randomization<a class="headerlink" href="#rule-randomization" title="Link to this heading"></a></h2>
<p>Independently of the wiring diagram, Boolean update rules are
randomized for each node, optionally preserving properties of the
original rules:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">PRESERVE_BIAS</span></code> is True, the exact Hamming weight (number of ones
in the truth table) of each rule is preserved.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">PRESERVE_CANALIZING_DEPTH</span></code> is True, the canalizing depth of each
rule is preserved exactly.</p></li>
</ul>
<p>If both flags are True, both properties are preserved simultaneously.
If neither flag is True, rules are regenerated subject only to
non-degeneracy and the node’s in-degree.</p>
</section>
<section id="id70">
<h2>Parameters<a class="headerlink" href="#id70" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>bn<span class="classifier">BooleanNetwork</span></dt><dd><p>Source Boolean network.</p>
</dd>
<dt>wiring_diagram<span class="classifier">{‘fixed’, ‘fixed_indegree’, ‘fixed_in_and_outdegree’}, optional</span></dt><dd><p>Strategy for handling the wiring diagram. Default is <code class="docutils literal notranslate"><span class="pre">'fixed'</span></code>.</p>
</dd>
<dt>PRESERVE_BIAS<span class="classifier">bool, optional</span></dt><dd><p>If True, preserve the exact Hamming weight of each Boolean rule.
Default is True.</p>
</dd>
<dt>PRESERVE_CANALIZING_DEPTH<span class="classifier">bool, optional</span></dt><dd><p>If True, preserve the exact canalizing depth of each Boolean rule.
Default is True.</p>
</dd>
<dt>rng<span class="classifier">int, numpy.random.Generator, numpy.random.RandomState, random.Random, or None, optional</span></dt><dd><p>Random number generator or seed specification. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
<dt>**kwargs</dt><dd><p>Additional keyword arguments forwarded to the wiring-diagram
randomization routine:</p>
<ul class="simple">
<li><p>For <code class="docutils literal notranslate"><span class="pre">wiring_diagram</span> <span class="pre">==</span> <span class="pre">'fixed_indegree'</span></code>, forwarded to
<code class="docutils literal notranslate"><span class="pre">random_wiring_diagram</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">NO_SELF_REGULATION</span></code>,
<code class="docutils literal notranslate"><span class="pre">STRONGLY_CONNECTED</span></code>).</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">wiring_diagram</span> <span class="pre">==</span> <span class="pre">'fixed_in_and_outdegree'</span></code>, forwarded to
<code class="docutils literal notranslate"><span class="pre">rewire_wiring_diagram</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">average_swaps_per_edge</span></code>,
<code class="docutils literal notranslate"><span class="pre">DO_NOT_ADD_SELF_REGULATION</span></code>, <code class="docutils literal notranslate"><span class="pre">FIX_SELF_REGULATION</span></code>).</p></li>
</ul>
</dd>
</dl>
</section>
<section id="id71">
<h2>Returns<a class="headerlink" href="#id71" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>BooleanNetwork</dt><dd><p>A randomized Boolean network satisfying the selected invariants.</p>
</dd>
</dl>
</section>
<section id="id72">
<h2>Raises<a class="headerlink" href="#id72" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>AssertionError</dt><dd><p>If invalid options are provided.</p>
</dd>
<dt>RuntimeError</dt><dd><p>If wiring-diagram randomization fails (e.g., strong connectivity
cannot be achieved within the allowed number of attempts).</p>
</dd>
</dl>
</section>
<section id="id73">
<h2>Notes<a class="headerlink" href="#id73" title="Link to this heading"></a></h2>
<p>This function generates null models by selectively preserving structural
and dynamical properties of an existing Boolean network. It is intended
for hypothesis testing and comparative studies rather than for uniform
sampling over all networks satisfying the given constraints.</p>
</section>
<section id="id74">
<h2>Examples<a class="headerlink" href="#id74" title="Link to this heading"></a></h2>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Most restrictive use case: Preserve both wiring and rule properties (default) </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn_null</span> <span class="o">=</span> <span class="n">random_null_model</span><span class="p">(</span><span class="n">bn</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Preserve in-degrees only and preserve rule bias</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn_null</span> <span class="o">=</span> <span class="n">random_null_model</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">bn</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">wiring_diagram</span><span class="o">=</span><span class="s1">&#39;fixed_indegree&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">PRESERVE_BIAS</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">PRESERVE_CANALIZING_DEPTH</span><span class="o">=</span><span class="kc">False</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Preserve both in- and out-degrees via rewiring</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn_null</span> <span class="o">=</span> <span class="n">random_null_model</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">bn</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">wiring_diagram</span><span class="o">=</span><span class="s1">&#39;fixed_in_and_outdegree&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">average_swaps_per_edge</span><span class="o">=</span><span class="mi">15</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="boolean_network.html" class="btn btn-neutral float-left" title="Boolean Network" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="bio_models.html" class="btn btn-neutral float-right" title="Bio Models" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Claus Kadelka, Benjamin Coberly.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jul 29 09:25:40 2025
Last Edited on Thu Aug 14 2025

@author: Claus Kadelka, Benjamin Coberly
"""

##Imports
import itertools
import random

import numpy as np
import networkx as nx

try:
    from boolforge.boolean_function import BooleanFunction
    from boolforge.boolean_network import BooleanNetwork
    import boolforge.utils as utils
except ModuleNotFoundError:
    from boolean_function import BooleanFunction
    from boolean_network import BooleanNetwork
    import utils


## Helper variables and functions 

left_side_of_truth_tables = {}

def get_left_side_of_truth_table(n):
    if n in left_side_of_truth_tables:
        left_side_of_truth_table = left_side_of_truth_tables[n]
    else:
        left_side_of_truth_table = np.array(list(itertools.product([0, 1], repeat=n)))
        left_side_of_truth_tables[n] = left_side_of_truth_table
    return left_side_of_truth_table


## Random function generation

def random_function(n, depth=0, EXACT_DEPTH=False, layer_structure=None, 
                 LINEAR=False, ALLOW_DEGENERATED_FUNCTIONS=False,
                 bias=0.5, absolute_bias = 0, USE_ABSOLUTE_BIAS=False,
                 hamming_weight = None):
    if LINEAR:
        return random_linear_function(n)
    elif depth>0 and layer_structure is None:
        return random_k_canalizing_function(n, min(depth, n), EXACT_DEPTH=EXACT_DEPTH, ALLOW_DEGENERATED_FUNCTIONS=ALLOW_DEGENERATED_FUNCTIONS)
    elif layer_structure is not None:
        return random_k_canalizing_function_with_specific_layer_structure(n, layer_structure, EXACT_DEPTH=EXACT_DEPTH, ALLOW_DEGENERATED_FUNCTIONS=ALLOW_DEGENERATED_FUNCTIONS)
    elif hamming_weight is None:
        if USE_ABSOLUTE_BIAS:
            assert 0<=absolute_bias<=1,"absolute_bias must be in [0,1]. It is double the absolute difference of bias from 0.5."
            bias_of_function = random.choice([0.5*(1-absolute_bias),0.5*(1+absolute_bias)])
        else:
            assert 0<=bias<=1,"bias must be in [0,1]. It describes the probability of a 1 in the randomly generated function."            
            bias_of_function = bias
        if ALLOW_DEGENERATED_FUNCTIONS:
            if EXACT_DEPTH is True:
                return random_non_canalizing_function(n, bias_of_function)
            else: #completely random function
                return random_function_with_bias(n, bias_of_function)
        else:
            if EXACT_DEPTH is True:
                return random_non_canalizing_non_degenerated_function(n, bias_of_function)
            else: #generated by default
                return random_non_degenerated_function(n, bias_of_function)
    else:
        assert isinstance(hamming_weight, (int, np.integer)) and 0<=hamming_weight<=2**n, "Hamming weight must be an integer in {0,1,...,2^n}"
        assert 1<hamming_weight<2**n-1 or not EXACT_DEPTH,"If EXACT_DEPTH==True and depth==0, Hamming_weight must be in 2,3,...,2^n-2. All functions with Hamming weight 0,1,2^n-1,2^n are canalizing"
        f=random_function_with_exact_hamming_weight(n, hamming_weight)
        while True:
            if ALLOW_DEGENERATED_FUNCTIONS and EXACT_DEPTH:
                if not f.is_canalizing():
                    return f
            elif ALLOW_DEGENERATED_FUNCTIONS:
                return f
            elif EXACT_DEPTH:
                if not f.is_canalizing() and not f.is_degenerated():
                    return f
            else:
                if not f.is_degenerated():
                    return f
            f=random_function_with_exact_hamming_weight(n, hamming_weight)


def random_function_with_bias(n, bias=0.5):
    """
    Generate a random Boolean function in n variables with a specified bias.

    The Boolean function is represented as a truth table (an array of length 2^n) in which each entry is 0 or 1.
    Each entry is set to 1 with probability `bias`.

    Parameters:
        - n (int): Number of variables.
        - bias (float, optional): Probability that a given entry is 1 (default is 0.5).

    Returns:
        - BooleanFunction: Boolean function object.
    """
    return BooleanFunction(np.array(np.random.random(2**n) < bias, dtype=int))


def random_function_with_exact_hamming_weight(n, hamming_weight):
    """
    Generate a random Boolean function in n variables with exact Hamming weight (number of ones).

    The Boolean function is represented as a truth table (an array of length 2^n) in which each entry is 0 or 1.
    Exactly 'hamming_weight' entries are set to 1.

    Parameters:
        - n (int): Number of variables.
        - hamming_weight (int): Probability that a given entry is 1 (default is 0.5).

    Returns:
        - BooleanFunction: Boolean function object.
    """
    assert isinstance(hamming_weight, (int, np.integer)) and 0<=hamming_weight<=2**n,"Hamming weight must be an integer between 0 and 2^n."
    oneIndices = np.random.choice(2**n,hamming_weight,replace=False)
    f = np.zeros(2**n,dtype=int)
    f[oneIndices] = 1    
    return BooleanFunction(f)


def random_linear_function(n):
    """
    Generate a random linear Boolean function in n variables.

    A random linear Boolean function is constructed by randomly choosing whether to include each variable or its negation in a linear sum.
    The resulting expression is then reduced modulo 2.

    Parameters:
        - n (int): Number of variables.

    Returns:
        - BooleanFunction: Boolean function object.
    """
    assert isinstance(n, (int, np.integer)) and n>0,"n must be a positive integer"
    val = int(random.random()>0.5)
    f = [0] * 2**n
    for i in range(1 << n):
        if i.bit_count() % 2 == val:
            f[i] = 1
    return BooleanFunction(f)


def random_non_degenerated_function(n, bias=0.5):
    """
    Generate a random non-degenerated Boolean function in n variables.

    A non-degenerated Boolean function is one in which every variable is essential (i.e. the output depends on every input).
    The function is repeatedly generated with the specified bias until a non-degenerated function is found.

    Parameters:
        - n (int): Number of variables.
        - bias (float, optional): Bias of the Boolean function (probability of a 1; default is 0.5).

    Returns:
        - BooleanFunction: Boolean function object.
    
    References:
        Kadelka, C., Kuipers, J., & Laubenbacher, R. (2017). The influence of canalization on the robustness 
        of Boolean networks. Physica D: Nonlinear Phenomena, 353, 39-47.
    """
    assert isinstance(n, (int, np.integer)) and n>0,"n must be a positive integer"
    assert isinstance(bias, (float, np.floating)) and 0.001<bias<0.999,"almost all extremely biased Boolean functions are degenerated. Choose a more balanced value for the 'bias'."
    while True:  # works well because most Boolean functions are non-degenerated
        f = random_function_with_bias(n, bias)
        if not f.is_degenerated():
            return f


def random_degenerated_function(n, bias=0.5):
    """
    Generate a random degenerated Boolean function in n variables.

    A degenerated Boolean function is one in which at least one variable is non‐essential (its value never affects the output).
    The function is generated repeatedly until a degenerated function is found.

    Parameters:
        - n (int): Number of variables.
        - bias (float, optional): Bias of the Boolean function (default is 0.5, i.e., unbiased).

    Returns:
        - BooleanFunction: Boolean function object that is degenerated in the first input (and possibly others).
    
    References:
        Kadelka, C., Kuipers, J., & Laubenbacher, R. (2017). The influence of canalization on the robustness 
        of Boolean networks. Physica D: Nonlinear Phenomena, 353, 39-47.
    """
    assert isinstance(n, (int, np.integer)) and n>0,"n must be a positive integer"
    
    f_original = random_function_with_bias(n-1, bias)
    index_non_essential_variable = int(random.random()*n)
    f = np.zeros(2**n, dtype=int)
    indices = (np.arange(2**n)//(2**index_non_essential_variable))%2==1
    f[indices] = f_original.f
    f[~indices] = f_original.f
    return BooleanFunction(f)


def random_non_canalizing_function(n, bias=0.5):
    """
    Generate a random non-canalizing Boolean function in n (>1) variables.

    A Boolean function is canalizing if there exists at least one variable whose fixed value forces the output.
    This function returns one that is not canalizing.

    Parameters:
        - n (int): Number of variables (n > 1).
        - bias (float, optional): Bias of the Boolean function (default is 0.5, i.e., unbiased).

    Returns:
        - BooleanFunction: Boolean function object.
    
    References:
        Kadelka, C., Kuipers, J., & Laubenbacher, R. (2017). The influence of canalization on the robustness 
        of Boolean networks. Physica D: Nonlinear Phenomena, 353, 39-47.
    """
    assert isinstance(n, (int, np.integer)) and n > 1, "n must be an integer > 1"
    while True:  # works because most functions are non-canalizing
        f = BooleanFunction(np.array(np.random.random(2**n) < bias, dtype=int))
        if not f.is_canalizing():
            return f


def random_non_canalizing_non_degenerated_function(n, bias=0.5):
    """
    Generate a random Boolean function in n (>1) variables that is both non-canalizing and non-degenerated.

    Such a function has every variable essential and is not canalizing.

    Parameters:
        - n (int): Number of variables (n > 1).
        - bias (float, optional): Bias of the Boolean function (default is 0.5, i.e., unbiased).

    Returns:
        - BooleanFunction: Boolean function object.
    
    References:
        Kadelka, C., Kuipers, J., & Laubenbacher, R. (2017). The influence of canalization on the robustness 
        of Boolean networks. Physica D: Nonlinear Phenomena, 353, 39-47.
    """
    assert isinstance(n, (int, np.integer)) and n > 1, "n must be an integer > 1"
    while True:  # works because most functions are non-canalizing and non-degenerated
        f = BooleanFunction(np.array(np.random.random(2**n) < bias, dtype=int))
        if not f.is_canalizing() and not f.is_degenerated():
            return f


def random_k_canalizing_function(n, k, EXACT_DEPTH=False, ALLOW_DEGENERATED_FUNCTIONS=False):
    """
    Generate a random k-canalizing Boolean function in n variables.

    A Boolean function is k-canalizing if it has at least k conditionally canalizing variables.
    If EXACT_DEPTH is True, the function will have exactly k canalizing variables; otherwise, its canalizing depth may exceed k.

    Parameters:
        - n (int): Total number of variables.
        - k (int): Number of canalizing variables. Set k==n to generate a random nested canalizing function.
        - EXACT_DEPTH (bool, optional): If True, enforce that the canalizing depth is exactly k (default is False).
        - ALLOW_DEGENERATED_FUNCTIONS(bool, optional): If True (default False) and k==0 and layer_structure is None, degenerated functions may be created as in classical NK-Kauffman networks.

    Returns:
        - BooleanFunction: Boolean function object.
    
    References:
        [1] He, Q., & Macauley, M. (2016). Stratification and enumeration of Boolean functions by canalizing depth. 
            Physica D: Nonlinear Phenomena, 314, 1-8.
        [2] Dimitrova, E., Stigler, B., Kadelka, C., & Murrugarra, D. (2022). Revealing the canalizing structure of Boolean functions: 
            Algorithms and applications. Automatica, 146, 110630.
    """
    assert isinstance(n, (int, np.integer)) and n>0,"n must be a positive integer"
    assert n - k != 1 or not EXACT_DEPTH,'There are no functions of exact canalizing depth n-1.\nEither set EXACT_DEPTH=False or ensure k != n-1'
    assert isinstance(k, (int, np.integer)) and 0 <= k and k <= n,'k, the canalizing depth, must satisfy 0 <= k <= n.'

    left_side_of_truth_table = get_left_side_of_truth_table(n)
    num_values = 2**n
    aas = np.random.randint(2, size=k)  # canalizing inputs
    bbs = np.random.randint(2, size=k)  # canalized outputs

    can_vars = np.random.choice(n, k, replace=False)
    f = np.zeros(num_values, dtype=int)
    if k < n:
        core_function = random_function(n=n-k,depth=0,EXACT_DEPTH=EXACT_DEPTH,ALLOW_DEGENERATED_FUNCTIONS=ALLOW_DEGENERATED_FUNCTIONS)
    else:
        core_function = [1 - bbs[-1]]
    counter_non_canalized_positions = 0
    for i in range(num_values):
        for j in range(k):
            if left_side_of_truth_table[i][can_vars[j]] == aas[j]:
                f[i] = bbs[j]
                break
        else:
            f[i] = core_function[counter_non_canalized_positions]
            counter_non_canalized_positions += 1
    return BooleanFunction(f)


def random_k_canalizing_function_with_specific_layer_structure(n, layer_structure, EXACT_DEPTH=False, ALLOW_DEGENERATED_FUNCTIONS=False):
    """
    Generate a random Boolean function in n variables with a specified canalizing layer structure.

    The layer structure is given as a list [k_1, ..., k_r], where each k_i indicates the number of canalizing variables 
    in that layer. If the function is fully canalizing (i.e. sum(layer_structure) == n and n > 1), the last layer must have at least 2 variables.

    Parameters:
        - n (int): Total number of variables.
        - layer_structure (list): List [k_1, ..., k_r] describing the canalizing layer structure. Each k_i ≥ 1, and if sum(layer_structure) == n and n > 1, then layer_structure[-1] ≥ 2. Set sum(layer_structure)==n to generate a random nested canalizing function.
        - EXACT_DEPTH (bool, optional): If True, the canalizing depth is exactly sum(layer_structure) (default is False).
        - ALLOW_DEGENERATED_FUNCTIONS(bool, optional): If True (default False), the core function may be degenerated, as in NK-Kauffman networks.

    Returns:
        - BooleanFunction: Boolean function object.
    
    References:
        [1] He, Q., & Macauley, M. (2016). Stratification and enumeration of Boolean functions by canalizing depth.
            Physica D: Nonlinear Phenomena, 314, 1-8.
        [2] Kadelka, C., Kuipers, J., & Laubenbacher, R. (2017). The influence of canalization on the robustness 
            of Boolean networks. Physica D: Nonlinear Phenomena, 353, 39-47.
    """
    depth = sum(layer_structure)  # canalizing depth
    if depth == 0:
        layer_structure = [0]
        
    assert isinstance(n, (int, np.integer)) and n > 0, "n must be an integer > 0"        
    assert n - depth != 1 or not EXACT_DEPTH,'There are no functions of exact canalizing depth n-1.\nEither set EXACT_DEPTH=False or ensure depth=sum(layer_structure)!=n-1.'
    assert 0 <= depth and depth <= n,'Ensure 0 <= depth = sum(layer_structure) <= n.'
    assert depth < n or layer_structure[-1] > 1 or n == 1,'The last layer of an NCF (i.e., an n-canalizing function) has to have size >= 2 whenever n > 1.\nIf depth=sum(layer_structure)=n, ensure that layer_structure[-1]>=2.'
    assert min(layer_structure) >= 1,'Each layer must have at least one variable (each element of layer_structure must be >= 1).'
    
    left_side_of_truth_table = get_left_side_of_truth_table(n)

    size_state_space = 2**n
    aas = np.random.randint(2, size=depth)  # canalizing inputs
    b0 = np.random.randint(2)
    bbs = [b0] * layer_structure[0]  # canalized outputs for first layer
    for i in range(1, len(layer_structure)):
        if i % 2 == 0:
            bbs.extend([b0] * layer_structure[i])
        else:
            bbs.extend([1 - b0] * layer_structure[i])
    can_vars = np.random.choice(n, depth, replace=False)
    f = np.zeros(size_state_space, dtype=int)
    if depth < n:
        core_function = random_function(n=n-depth,depth=0,EXACT_DEPTH=EXACT_DEPTH,ALLOW_DEGENERATED_FUNCTIONS=ALLOW_DEGENERATED_FUNCTIONS)
    else:
        core_function = [1 - bbs[-1]]
    counter_non_canalized_positions = 0
    for i in range(size_state_space):
        for j in range(depth):
            if left_side_of_truth_table[i][can_vars[j]] == aas[j]:
                f[i] = bbs[j]
                break
        else:
            f[i] = core_function[counter_non_canalized_positions]
            counter_non_canalized_positions += 1
    return BooleanFunction(f)


def random_nested_canalizing_function(n,layer_structure=None):
    '''
    Generate a random nested canalizing Boolean function in n variables 
    with a specified canalizing layer structure (if provided).

    The layer structure is given as a list [k_1, ..., k_r], where each k_i indicates the number of canalizing variables 
    in that layer. If the function is fully canalizing (i.e. sum(layer_structure) == n and n > 1), the last layer must have at least 2 variables.

    Parameters:
        - n (int): Total number of variables.
        - layer_structure (list,optional): List [k_1, ..., k_r] describing the canalizing layer structure. Each k_i ≥ 1, and if sum(layer_structure) == n and n > 1, then layer_structure[-1] ≥ 2. Set sum(layer_structure)==n to generate a random nested canalizing function.

    Returns:
        - BooleanFunction: Boolean function object.
    
    References:
        [1] He, Q., & Macauley, M. (2016). Stratification and enumeration of Boolean functions by canalizing depth.
            Physica D: Nonlinear Phenomena, 314, 1-8.
        [2] Kadelka, C., Kuipers, J., & Laubenbacher, R. (2017). The influence of canalization on the robustness 
            of Boolean networks. Physica D: Nonlinear Phenomena, 353, 39-47.
    '''    
    if layer_structure is None:
        return random_k_canalizing_function(n,n,EXACT_DEPTH=False)
    else:
        assert sum(layer_structure) == n,'Ensure sum(layer_structure) == n.'
        assert layer_structure[-1] > 1 or n == 1,'The last layer of an NCF has to have size >= 2 whenever n > 1.\nEnsure that layer_structure[-1]>=2.'
        return random_k_canalizing_function_with_specific_layer_structure(n,layer_structure,EXACT_DEPTH=False)

def random_NCF(n,layer_structure=None):
    '''
    See random_nested_canalizing_function.
    '''
    return random_nested_canalizing_function(n=n,layer_structure=layer_structure)


## Random network generation
def random_degrees(N,n,indegree_distribution='constant',NO_SELF_REGULATION=True):
    if isinstance(n, (list, np.ndarray)):
        assert (np.all([isinstance(el, (int, np.integer)) for el in n]) and len(n) == N and min(n) >= 1 and max(n) <= N), 'A vector n was submitted.\nEnsure that n is an N-dimensional vector where each element is an integer between 1 and N representing the upper bound of a uniform degree distribution (lower bound == 1).'
        indegrees = np.array(n,dtype=int)
    elif indegree_distribution.lower() in ['constant', 'dirac', 'delta']:
        assert (isinstance(n, (int, np.integer)) and n >= 1 and n <= N), 'n must be a single integer (or N-dimensional vector of integers) between 1 and N when using a constant degree distribution.'
        indegrees = np.ones(N, dtype=int) * n
    elif indegree_distribution.lower() == 'uniform':
        assert (isinstance(n, (int, np.integer)) and n >= 1 and n <= N - int(NO_SELF_REGULATION)), 'n must be a single integer (or N-dimensional vector of integers) between 1 and ' + ('N-1' if NO_SELF_REGULATION else 'N')+' representing the upper bound of a uniform degree distribution (lower bound == 1).'
        indegrees = 1 + np.random.randint(n - 1, size=N)
    elif indegree_distribution.lower() == 'poisson':
        assert (isinstance(n, (int, float, np.integer, np.floating)) and n>0), 'n must be a single number (or N-dimensional vector) > 0 representing the Poisson parameter.'
        indegrees = np.maximum(np.minimum(np.random.poisson(lam=n, size=N),N - int(NO_SELF_REGULATION)), 1)
    else:
        raise AssertionError('None of the predefined in-degree distributions were chosen.\nTo use a user-defined in-degree vector, submit an N-dimensional vector as argument for n; each element of n must an integer between 1 and N.')
    return indegrees


def random_edge_list(N, indegrees, NO_SELF_REGULATION, AT_LEAST_ONE_REGULATOR_PER_NODE=False):
    """
    Generate a random edge list for a network of N nodes with optional constraints.

    Each node i receives indegrees[i] incoming edges chosen at random.
    Optionally, the function can ensure that every node regulates at least one other node.

    Parameters:
        - N (int): Number of nodes.
        - indegrees (list or array-like): List of length N specifying the number of regulators for each node.
        - NO_SELF_REGULATION (bool): If True, disallow self-regulation.
        - AT_LEAST_ONE_REGULATOR_PER_NODE (bool, optional): If True, ensure that each node has at least one outgoing edge (default is False).

    Returns:
        - list: A list of tuples (source, target) representing the edges.
    """
    if AT_LEAST_ONE_REGULATOR_PER_NODE == False:
        edge_list = []
        for i in range(N):
            if NO_SELF_REGULATION:
                indices = np.random.choice(np.append(np.arange(i), np.arange(i+1, N)), indegrees[i], replace=False)
            else:
                indices = np.random.choice(np.arange(N), indegrees[i], replace=False)
            edge_list.extend(list(zip(indices, i * np.ones(indegrees[i], dtype=int))))
    else:
        edge_list = []
        outdegrees = np.zeros(N, dtype=int)
        sum_indegrees = sum(indegrees)  # total number of regulations
        for i in range(N):
            if NO_SELF_REGULATION:
                indices = np.random.choice(np.append(np.arange(i), np.arange(i+1, N)), indegrees[i], replace=False)
            else:
                indices = np.random.choice(np.arange(N), indegrees[i], replace=False)
            outdegrees[indices] += 1
            edge_list.extend(list(zip(indices, i * np.ones(indegrees[i], dtype=int))))
        while min(outdegrees) == 0:
            index_sink = np.where(outdegrees == 0)[0][0]
            index_edge = int(random.random() * sum_indegrees)
            if NO_SELF_REGULATION:
                while edge_list[index_edge][1] == index_sink:
                    index_edge = int(random.random() * sum_indegrees)
            outdegrees[index_sink] += 1
            outdegrees[edge_list[index_edge][0]] -= 1
            edge_list[index_edge] = (index_sink, edge_list[index_edge][1])
    return edge_list


def random_wiring_diagram(N,n,NO_SELF_REGULATION=True, STRONGLY_CONNECTED=False,
                          indegree_distribution='constant', 
                          n_attempts_to_generate_strongly_connected_network = 1000):
    """
    Generate a random wiring diagram for a network of N nodes.

    Each node i is assigned indegrees[i] outgoing edges (regulators) chosen at random.
    Optionally, self-regulation (an edge from a node to itself) can be disallowed,
    and the generated network can be forced to be strongly connected.

    Parameters:
        - N (int): Number of nodes.
        - indegrees (list or array-like): List of length N specifying the number of outgoing edges for each node.
        - NO_SELF_REGULATION (bool, optional): If True, self-regulation is disallowed (default is True).
        - STRONGLY_CONNECTED (bool, optional): If True, the generated network is forced to be strongly connected (default is False).

    Returns:
        - tuple: (matrix, indices) where:
            - matrix (np.array): An N x N adjacency matrix with entries 0 or 1.
            - indices (list): A list of length N, where each element is an array of selected target indices for the corresponding node.
    """
    indegrees = random_degrees(N,n,indegree_distribution=indegree_distribution,NO_SELF_REGULATION=NO_SELF_REGULATION)

    counter = 0
    while True:  # Keep generating until we have a strongly connected graph
        edges_wiring_diagram = random_edge_list(N, indegrees, NO_SELF_REGULATION)
        if STRONGLY_CONNECTED:#may take a long time ("forever") if n is small and N is large
            G = nx.from_edgelist(edges_wiring_diagram, create_using=nx.MultiDiGraph())
            if not nx.is_strongly_connected(G):
                counter+=1
                if counter>n_attempts_to_generate_strongly_connected_network:
                    raise RuntimeError('Made '+str(n_attempts_to_generate_strongly_connected_network)+' unsuccessful attempts to generate a strongly connected wiring diagram of '+str(N)+' nodes and degrees '+str(indegrees)+'.\nYou may increase the number of attempts by modulating the parameter n_attempts_to_generate_strongly_connected_network.')
                continue
        break
    I = [[] for _ in range(N)]
    for edge in edges_wiring_diagram:
        I[edge[1]].append(edge[0])
    for i in range(N):
        I[i] = np.sort(I[i])
    return I, indegrees


#for testing:
# depths=0
# EXACT_DEPTH=False
# layer_structures=None
# ALLOW_DEGENERATED_FUNCTIONS=False
# LINEAR=False, 
# biases=0.5
# absolute_biases = 0.
# USE_ABSOLUTE_BIAS=True
# hamming_weights = None
# NO_SELF_REGULATION=True
# STRONGLY_CONNECTED=False
# indegree_distribution='constant'
# n_attempts_to_generate_strongly_connected_network = 1000

def random_network(N=None, n=None, 
                   depths=0, EXACT_DEPTH=False, layer_structures=None, 
                   ALLOW_DEGENERATED_FUNCTIONS=False, LINEAR=False, 
                   biases=0.5, absolute_biases = 0., USE_ABSOLUTE_BIAS=True,
                   hamming_weights = None,
                   NO_SELF_REGULATION=True, 
                   STRONGLY_CONNECTED=False, 
                   indegree_distribution='constant', 
                   n_attempts_to_generate_strongly_connected_network = 1000, 
                   I=None):
    """
    Generate a random Boolean network (BN).

    This function creates a random Boolean network of N nodes in two steps:
        1. A random wiring diagram is generated using random_wiring_diagram 
           Note: this step is passed if the wiring diagram is provided via I.
        2. Random update rules are generated using random_rules. The degree of the
           rules is determined by the wiring diagram. The functions themselves 
           can be canalizing with prescribed depth and/or specific layer structure,
           linear, or random functions with a specified bias.

    Parameters:
        - N (int): Number of nodes in the network.
        - n (int, list, or np.array; float allowed if indegree_distribution=='poisson'):  Determines the in-degree of each node. If an integer, each node has the same number of regulators; if a vector, each element gives the number of regulators for the corresponding node.
        - depths (int, list, or np.array, optional): Specifies the minimal canalizing depth for each node (exact canalizing depth if EXACT_DEPTH==True). If an integer, the same depth is used for all nodes; if a vector, each node gets its own depth. Default is 0.
        - EXACT_DEPTH (bool, optional): If True, Boolean functions are generated with exactly the specified canalizing depth; if False, the functions have at least that depth. Default is False.
        - layer_structures (list, or (list of np.array) of lists, optional): Specifies the canalizing layer structure for the Boolean functions. If provided, the parameter 'depths' is ignored.
        - ALLOW_DEGENERATED_FUNCTIONS(bool, optional): If True (default False) and depths==0 and layer_structures is None, degenerated functions may be created as in NK-Kauffman networks.
        - LINEAR (bool, optional): If True, Boolean functions are generated to be linear. Default is False.
        - biases (float, list, or np.array, optional): Bias of generated Boolean functions (probability of output 1). Default is 0.5. Ignored unless depths==0 and LINEAR==False and layer_structure is None.
        - absolute_biases (float, list, or np.array, optional): Absolute bias of generated Boolean functions (default 0.0). Ignored unless depths==0 and LINEAR==False and layer_structure is None and USE_ABSOLUTE_BIAS==True.
        - USE_ABSOLUTE_BIAS (bool, optional): Determines if absolute bias or regular bias is used in the generation of functions. Default is True (i.e., absolute bias). Ignored unless depths==0 and LINEAR==False and layer_structures is None.
        - NO_SELF_REGULATION (bool, optional): If True, self-regulation (self-loops) is disallowed. Default is True.
        - STRONGLY_CONNECTED (bool, optional): If True, ensures that the generated network is strongly connected. Default is False.
        - indegree_distribution (str, optional): In-degree distribution to use. Options include 'constant' (or 'dirac'/'delta'), 'uniform', or 'poisson'. Default is 'constant'.
        - n_attempts_to_generate_strongly_connected_network (integer, optional): Number of attempts to generate a strongly connected wiring diagram before raising an error and quitting.
        - I (list or numpy array, optional): A list of N lists representing the regulators (or inputs) for each node.
    
    Returns:
        - BooleanNetwork: Boolean network object.
        
    Examples:
        >>> random_network(N,n,ALLOW_DEGENERATED_FUNCTIONS=False) #creates a random NK-Kauffman network in which all inputs are essential.

        >>> random_network(N,n, ALLOW_DEGENERATED_FUNCTIONS = True) #creates a classical random NK-Kauffman network. The constant degree is specified by n. Some inputs may be non-essential.
        
        >>> random_network(N,n,k) #all functions have degree n and at least canalizing depth k.

        >>> random_network(N,n,depths=n) #all functions are n-input NCFs of arbitrary layer structure.

        >>> random_network(N,n,depths=k,EXACT_DEPTH=True) #all functions have degree n and exact canalizing depth k.

        >>> random_network(N,n,layer_structure=[n]) #all functions have degree n and are NCFs with exactly one layer.

        >>> random_network(N,n, LINEAR=True) #creates a random network with linear update rules

        >>> random_network(N,n,NO_SELF_REGULATION=False) #The underlying wiring diagram may contain self-loops.
        
        >>> random_network(N,n,ALLOW_DEGENERATED_FUNCTIONS=False,STRONGLY_CONNECTED=True) #The underlying wiring diagram is truly strongly connected.

        >>> random_network(N,n,indegree_distribution='Poisson') #Creates a random network where the degree of each node is drawn from a truncated Poisson distribution with parameter n, min = 1, max = N - int(NO_SELF_REGULATION).

        >>> bn = random_network(N,n)
            random_network(I = bn.I) #Creates a random network with defined wiring diagram (specified by I, see BooleanNetwork.I), only randomizes the update rules.

    """

    if I is None and N is not None and n is not None: #generate wiring diagram
        I,indegrees = random_wiring_diagram(N,n,NO_SELF_REGULATION=NO_SELF_REGULATION, 
                                            STRONGLY_CONNECTED=STRONGLY_CONNECTED,
                                            indegree_distribution=indegree_distribution, 
                                            n_attempts_to_generate_strongly_connected_network = n_attempts_to_generate_strongly_connected_network)
    elif I is not None: #load wiring diagram
        assert isinstance(I, (list, np.ndarray)), "I must be a list or np.array of lists or np.arrays. Each inner list describes the regulators of node i (indexed by 0,1,...,len(I)-1)"
        N = len(I)
        for regulators in I:
            assert utils.is_list_or_array_of_ints(regulators) and min(regulators)>=0 and max(regulators)<=N-1, "Each element in I describes the regulators of a node (indexed by 0,1,...,len(I)-1)"
        indegrees = list(map(len,I))
    else:
        raise AssertionError('At a minimum, the wiring diagram I must be provided or the network size N and degree parameter n.')
       
        
       
    # Process the inputs, turn single inputs into vectors of length N
    if isinstance(depths, (int, np.integer)):
        assert depths >= 0 and depths<=min(indegrees),'The canalizing depth must be an integer between 0 and min(indegrees) or an N-dimensional vector of integers must be provided to use different depths per function.'
        max_depths = depths
        depths = [min(indegrees[i],depths) for i in range(N)]
    elif utils.is_list_or_array_of_ints(depths, required_length=N):
        max_depths = max(depths)
        assert min(depths) >= 0 and max_depths <= N,"'depths' received a vector as input.\nTo use a user-defined vector, ensure that it is an N-dimensional vector where each element is an integer between 0 and N."
    else:
        raise AssertionError("Wrong input format for 'depths'.\nIt must be a single integer (or N-dimensional vector of integers) between 0 and N, specifying the minimal canalizing depth or exact canalizing depth (if EXACT_DEPTH==True).")            
    
    if layer_structures == None:
        layer_structures = [None] * N
    elif utils.is_list_or_array_of_ints(layer_structures):
        depth = sum(layer_structures)
        assert depth==0 or (min(layer_structures)>=1 and depth <= min(indegrees)), 'The layer structure must be [] or a vector of positive integers with 0 <= depth = sum(layer_structure) <= N.'
        layer_structures = [layer_structures[:]] * N
    elif np.all([utils.is_list_or_array_of_ints(el) for el in layer_structures]) and len(layer_structures) == N:
        for i,layer_structure in enumerate(layer_structures):
            depth = sum(layer_structure)
            assert depth==0 or (min(layer_structure)>=1 and depth <= indegrees[i]), 'Ensure that layer_structure is an N-dimensional vector where each element represents a layer structure and is either [] or a vector of positive integers with 0 <= depth = sum(layer_structure[i]) <= n = indegrees[i].'
    else:
        raise AssertionError("Wrong input format for 'layer_structure'.\nIt must be a single vector (or N-dimensional vector of layer structures) where the sum of each element is between 0 and N.")
    
    if isinstance(biases, (float, np.floating)):
        biases = [biases] * N
    elif not utils.is_list_or_array_of_floats(biases, required_length=N):
        raise AssertionError("Wrong input format for 'biases'.\nIt must be a single float (or N-dimensional vector of floats) in [0,1] , specifying the bias (probability of a 1) in the generation of the Boolean function.")            
    
    if isinstance(absolute_biases, (float, np.floating)):
        absolute_biases = [absolute_biases] * N
    elif not utils.is_list_or_array_of_floats(absolute_biases, required_length=N):
        raise AssertionError("Wrong input format for 'absolute_biases'.\nIt must be a single float (or N-dimensional vector of floats) in [0,1], specifying the absolute bias (divergence from the 'unbiased bias' of 0.5) in the generation of the Boolean function.")            

    if hamming_weights == None:
        hamming_weights = [None] * N    
    elif isinstance(hamming_weights, (int, np.integer)):
        hamming_weights = [hamming_weights] * N
    elif not utils.is_list_or_array_of_ints(hamming_weights, required_length=N):
        raise AssertionError("Wrong input format for 'hamming_weights'.\nIf provided, it must be a single integer (or N-dimensional vector of integers) in {0,1,...,2^n}, specifying the number of 1s in the truth table of each Boolean function.\nIf EXACT_DEPTH == True and depths==0, it must be in {2,3,...,2^n-2} because all functions with Hamming weight 0,1,2^n-1,2^n are canalizing.")            
            
    #generate functions
    F = [random_function(n=indegrees[i], depth=depths[i], EXACT_DEPTH=EXACT_DEPTH, layer_structure=layer_structures[i], 
                     LINEAR=LINEAR, ALLOW_DEGENERATED_FUNCTIONS=ALLOW_DEGENERATED_FUNCTIONS,
                     bias=biases[i], absolute_bias=absolute_biases[i], USE_ABSOLUTE_BIAS=USE_ABSOLUTE_BIAS,
                     hamming_weight=hamming_weights[i]) for i in range(N)]

    return BooleanNetwork(F, I)


def random_null_model(bn, wiring_diagram = 'fixed', PRESERVE_BIAS = True, PRESERVE_CANALIZING_DEPTH = True):
    if wiring_diagram == 'fixed':
        I = bn.I
        
    F = []
    for i,f in enumerate(bn.F):
        # if i>=n_variables: #constants don't change #TODO: add constants
        #     newF.append(np.array([0,1]))
        #     continue
        if PRESERVE_CANALIZING_DEPTH:
            depth = f.get_canalizing_depth()           
        if PRESERVE_BIAS and PRESERVE_CANALIZING_DEPTH:
            core_function = f.properties['CoreFunction']
            can_outputs = f.properties['CanalizedOutputs']
            
            can_inputs = np.random.choice(2,depth,replace=True)
            can_order = np.random.choice(f.n,depth,replace=False)
            if f.n-depth==0:
                core_function = np.array([1 - can_outputs[-1]],dtype=int)
            elif f.n-depth==2:
                core_function = random.choice([np.array([0,1,1,0],dtype=int),np.array([1,0,0,1],dtype=int)])
            else: #if f.n-depth>=3
                hamming_weight = sum(core_function)
                while True:
                    core_function = random_function_with_exact_hamming_weight(f.n-depth, hamming_weight)
                    if not core_function.is_canalizing():
                        if not core_function.is_degenerated():
                            break
            newf = -np.ones(2**bn.indegrees[i],dtype=int)
            for j in range(depth):
                newf[np.where(np.bitwise_and(newf==-1,get_left_side_of_truth_table(bn.indegrees[i])[:,can_order[j]]==can_inputs[j]))[0]] = can_outputs[j]
            newf[np.where(newf==-1)[0]] = core_function
            newf = BooleanFunction(newf)
        elif PRESERVE_BIAS:  #and PRESERVE_CANALIZING_DEPTH==False
            hamming_weight = sum(f)
            newf = random_function_with_exact_hamming_weight(bn.indegrees[i],hamming_weight)
        elif PRESERVE_CANALIZING_DEPTH:
            newf = random_k_canalizing_function(n=bn.indegrees[i],k=depth,EXACT_DEPTH=True)
        else:
            newf = random_non_degenerated_function(n=bn.indegrees[i])
        F.append(newf)
    return BooleanNetwork(F, I)

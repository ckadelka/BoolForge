

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>boolforge.boolean_network &mdash; BoolForge 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../../_static/sphinx_highlight.js?v=6ffebe34"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            BoolForge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../docs.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">BoolForge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">boolforge.boolean_network</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for boolforge.boolean_network</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines the :class:`~boolforge.BooleanNetwork` class, which provides</span>
<span class="sd">a high-level framework for modeling, simulating, and analyzing Boolean networks.</span>

<span class="sd">A :class:`BooleanNetwork` represents a discrete dynamical system</span>
<span class="sd">:math:`F = (f_1, \ldots, f_N)` composed of multiple</span>
<span class="sd">:class:`~boolforge.BooleanFunction` objects as update rules. The class includes</span>
<span class="sd">methods for constructing state transition graphs, identifying attractors,</span>
<span class="sd">computing robustness and sensitivity measures, and exporting truth tables.</span>

<span class="sd">Several computational routines—particularly those involving state space</span>
<span class="sd">exploration, attractor detection, and robustness estimation—offer optional</span>
<span class="sd">Numba-based just-in-time (JIT) acceleration. Installing Numba is **recommended**</span>
<span class="sd">for optimal performance but **not required**; all features remain functional</span>
<span class="sd">without it.</span>

<span class="sd">This module serves as the central interface for dynamic Boolean network</span>
<span class="sd">analysis within the BoolForge package.</span>

<span class="sd">Example</span>
<span class="sd">-------</span>
<span class="sd">&gt;&gt;&gt; from boolforge import BooleanNetwork</span>
<span class="sd">&gt;&gt;&gt; bn = BooleanNetwork(F=[[0, 1], [0, 0, 0, 1], [0, 1]], I=[[1], [0, 2], [1]])</span>
<span class="sd">&gt;&gt;&gt; bn.get_attractors_synchronous_exact()</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">boolforge.utils</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">utils</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">boolforge.boolean_function</span><span class="w"> </span><span class="kn">import</span> <span class="n">BooleanFunction</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">boolforge.wiring_diagram</span><span class="w"> </span><span class="kn">import</span> <span class="n">WiringDiagram</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">utils</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">utils</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">boolean_function</span><span class="w"> </span><span class="kn">import</span> <span class="n">BooleanFunction</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">wiring_diagram</span><span class="w"> </span><span class="kn">import</span> <span class="n">WiringDiagram</span>
    
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">cana.boolean_network</span>
    <span class="n">__LOADED_CANA__</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="n">__LOADED_CANA__</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">numba</span><span class="w"> </span><span class="kn">import</span> <span class="n">njit</span><span class="p">,</span> <span class="n">int64</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">numba.typed</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span>
    <span class="n">__LOADED_NUMBA__</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="n">__LOADED_NUMBA__</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;dict_weights&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_entropy_of_basin_size_distribution&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BooleanNetwork&quot;</span>
<span class="p">]</span>

<span class="n">dict_weights</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;non-essential&#39;</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s1">&#39;conditional&#39;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;positive&#39;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;negative&#39;</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>

<div class="viewcode-block" id="get_entropy_of_basin_size_distribution">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.get_entropy_of_basin_size_distribution">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_entropy_of_basin_size_distribution</span><span class="p">(</span>
    <span class="n">basin_sizes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Shannon entropy of a basin size distribution.</span>

<span class="sd">    The basin sizes are first normalized to form a probability distribution.</span>
<span class="sd">    The Shannon entropy is then computed as</span>

<span class="sd">    ``H = -sum(p_i * log(p_i))``,</span>

<span class="sd">    where ``p_i`` is the proportion of states in basin ``i``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    basin_sizes : Sequence[int] or np.ndarray</span>
<span class="sd">        Sizes of the basins of attraction, where each entry corresponds to</span>
<span class="sd">        the number of initial conditions that converge to a given attractor.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Shannon entropy of the basin size distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">basin_sizes</span><span class="p">)</span>
    <span class="n">probabilities</span> <span class="o">=</span> <span class="p">[</span><span class="n">size</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">total</span> <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">basin_sizes</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">probabilities</span><span class="p">])</span></div>



<span class="k">if</span> <span class="n">__LOADED_NUMBA__</span><span class="p">:</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># safe: operations are integer-only</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_update_network_synchronously_numba</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">F_array_list</span><span class="p">,</span>
        <span class="n">I_array_list</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform one synchronous update of a Boolean network.</span>
<span class="sd">    </span>
<span class="sd">        Given a binary state vector ``x``, this function computes the next network</span>
<span class="sd">        state under synchronous updating by evaluating each node’s Boolean update</span>
<span class="sd">        function based on its regulators.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : np.ndarray</span>
<span class="sd">            Binary state vector of shape ``(N,)`` with dtype ``uint8``.</span>
<span class="sd">        F_array_list : list[np.ndarray]</span>
<span class="sd">            List of truth tables for each node, where the ``j``-th entry is an</span>
<span class="sd">            array of length ``2**k_j`` giving the update rule for node ``j`` with</span>
<span class="sd">            ``k_j`` regulators.</span>
<span class="sd">        I_array_list : list[np.ndarray]</span>
<span class="sd">            List of regulator index arrays, where the ``j``-th entry contains the</span>
<span class="sd">            indices of the regulators of node ``j``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Updated binary state vector of shape ``(N,)`` with dtype ``uint8``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">regulators</span> <span class="o">=</span> <span class="n">I_array_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">regulators</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">F_array_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">regulators</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span><span class="p">[</span><span class="n">regulators</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
                <span class="n">fx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">F_array_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">fx</span>
    
    <span class="nd">@njit</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_synchronous_stg_numba</span><span class="p">(</span>
        <span class="n">F_array_list</span><span class="p">,</span> 
        <span class="n">I_array_list</span><span class="p">,</span> 
        <span class="n">N_variables</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the synchronous state transition graph (STG).</span>
<span class="sd">    </span>
<span class="sd">        This Numba-compiled function computes, for every possible binary state</span>
<span class="sd">        of a Boolean network, the index of its successor state under synchronous</span>
<span class="sd">        updating.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        F_array_list : list[np.ndarray]</span>
<span class="sd">            List of Boolean update tables. The ``j``-th entry is a NumPy array of</span>
<span class="sd">            length ``2**k_j`` representing the update rule for node ``j`` with</span>
<span class="sd">            ``k_j`` regulators.</span>
<span class="sd">        I_array_list : list[np.ndarray]</span>
<span class="sd">            List of regulator index arrays. The ``j``-th entry contains the indices</span>
<span class="sd">            of the regulators of node ``j``.</span>
<span class="sd">        N_variables : int</span>
<span class="sd">            Number of variables (nodes) in the network.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            One-dimensional array of length ``2**N_variables`` containing, for</span>
<span class="sd">            each state index, the index of the successor state under synchronous</span>
<span class="sd">            updating.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nstates</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">N_variables</span>
        <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nstates</span><span class="p">,</span> <span class="n">N_variables</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstates</span><span class="p">):</span>
            <span class="c1"># binary representation of i</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_variables</span><span class="p">):</span>
                <span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">N_variables</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
    
        <span class="n">next_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
        <span class="n">powers_of_two</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N_variables</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
        <span class="c1"># Compute next state for each node</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_variables</span><span class="p">):</span>
            <span class="n">regulators</span> <span class="o">=</span> <span class="n">I_array_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">regulators</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># constant node</span>
                <span class="n">next_states</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">F_array_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">continue</span>
    
            <span class="n">n_reg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">regulators</span><span class="p">)</span>
            <span class="n">reg_powers</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_reg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstates</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_reg</span><span class="p">):</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="n">states</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">regulators</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">*</span> <span class="n">reg_powers</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">next_states</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">F_array_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
    
        <span class="c1"># Convert each next state to integer index</span>
        <span class="n">next_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="c1"># NOTE: this cannot be an unsigned int for safe indexing inside Numba kernels.</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstates</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_variables</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">+=</span> <span class="n">next_states</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">powers_of_two</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">next_indices</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    
        <span class="k">return</span> <span class="n">next_indices</span>

    <span class="nd">@njit</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_synchronous_stg_numba_low_memory</span><span class="p">(</span>
        <span class="n">F_array_list</span><span class="p">,</span>
        <span class="n">I_array_list</span><span class="p">,</span>
        <span class="n">N_variables</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the synchronous state transition graph (STG) using minimal memory.</span>
<span class="sd">    </span>
<span class="sd">        For each integer state index ``i`` in ``[0, 2**N_variables)``, this function</span>
<span class="sd">        decodes ``i`` into its binary state vector, computes the synchronous update</span>
<span class="sd">        of the Boolean network, and encodes the resulting state back into an integer</span>
<span class="sd">        index.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        F_array_list : list[np.ndarray]</span>
<span class="sd">            List of Boolean update tables. The ``j``-th entry is an array of length</span>
<span class="sd">            ``2**k_j`` representing the update rule for node ``j`` with ``k_j``</span>
<span class="sd">            regulators.</span>
<span class="sd">        I_array_list : list[np.ndarray]</span>
<span class="sd">            List of regulator index arrays. The ``j``-th entry contains the indices</span>
<span class="sd">            of the regulators of node ``j``.</span>
<span class="sd">        N_variables : int</span>
<span class="sd">            Number of variables (nodes) in the network.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            One-dimensional array of length ``2**N_variables`` containing, for each</span>
<span class="sd">            state index, the index of the successor state under synchronous updating.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This implementation avoids storing the full state matrix and therefore</span>
<span class="sd">        reduces memory usage from ``O(N * 2**N)`` to ``O(N + 2**N)``. The time</span>
<span class="sd">        complexity remains exponential in ``N_variables``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nstates</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">N_variables</span>
        <span class="n">next_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="c1"># NOTE: this cannot be an unsigned int for safe indexing inside Numba kernels.</span>
        <span class="n">powers_of_two</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N_variables</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_variables</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">next_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_variables</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstates</span><span class="p">):</span>
            <span class="c1"># --- Decode i into binary vector (most-significant bit first)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_variables</span><span class="p">):</span>
                <span class="n">state</span><span class="p">[</span><span class="n">N_variables</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="mi">1</span>
                <span class="n">tmp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
    
            <span class="c1"># --- Compute next-state values</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_variables</span><span class="p">):</span>
                <span class="n">regulators</span> <span class="o">=</span> <span class="n">I_array_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">regulators</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">next_state</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">F_array_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n_reg</span> <span class="o">=</span> <span class="n">regulators</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_reg</span><span class="p">):</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">state</span><span class="p">[</span><span class="n">regulators</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
                    <span class="n">next_state</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">F_array_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
    
            <span class="c1"># --- Encode next_state back to integer</span>
            <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_variables</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">+=</span> <span class="n">next_state</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">powers_of_two</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">next_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    
        <span class="k">return</span> <span class="n">next_indices</span>

    <span class="nd">@njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># safe: operations are integer-only</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_hamming_distance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Hamming distance between two binary vectors.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : np.ndarray</span>
<span class="sd">            One-dimensional array of dtype ``uint8``.</span>
<span class="sd">        b : np.ndarray</span>
<span class="sd">            One-dimensional array of dtype ``uint8`` with the same shape as ``a``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Number of positions at which ``a`` and ``b`` differ.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">dist</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dist</span>
    
    
    <span class="nd">@njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># safe: operations are integer-only</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_derrida_simulation</span><span class="p">(</span>
        <span class="n">F_array_list</span><span class="p">,</span>
        <span class="n">I_array_list</span><span class="p">,</span>
        <span class="n">N</span><span class="p">,</span>
        <span class="n">nsim</span><span class="p">,</span>
        <span class="n">seed</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a Monte Carlo simulation to estimate the Derrida value.</span>
<span class="sd">    </span>
<span class="sd">        This function estimates the Derrida value by repeatedly sampling a random</span>
<span class="sd">        initial state, flipping a single randomly chosen bit, synchronously</span>
<span class="sd">        updating both states, and computing the Hamming distance between the</span>
<span class="sd">        resulting successor states.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        F_array_list : list[np.ndarray]</span>
<span class="sd">            List of Boolean update tables for each node.</span>
<span class="sd">        I_array_list : list[np.ndarray]</span>
<span class="sd">            List of regulator index arrays for each node.</span>
<span class="sd">        N : int</span>
<span class="sd">            Number of variables (nodes) in the network.</span>
<span class="sd">        nsim : int</span>
<span class="sd">            Number of Monte Carlo simulations to perform.</span>
<span class="sd">        seed : int</span>
<span class="sd">            Seed for the Numba-compatible random number generator.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Estimated Derrida value, i.e., the expected Hamming distance after one</span>
<span class="sd">            synchronous update following a random single-bit perturbation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Numba RNG: seed once</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">total_dist</span> <span class="o">=</span> <span class="mf">0.0</span>
    
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsim</span><span class="p">):</span>
            <span class="c1"># Random initial state</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">Y</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">X</span>
    
            <span class="c1"># Flip one random bit</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Y</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    
            <span class="c1"># Synchronous updates</span>
            <span class="n">FX</span> <span class="o">=</span> <span class="n">_update_network_synchronously_numba</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">F_array_list</span><span class="p">,</span> <span class="n">I_array_list</span><span class="p">)</span>
            <span class="n">FY</span> <span class="o">=</span> <span class="n">_update_network_synchronously_numba</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">F_array_list</span><span class="p">,</span> <span class="n">I_array_list</span><span class="p">)</span>
    
            <span class="n">total_dist</span> <span class="o">+=</span> <span class="n">_hamming_distance</span><span class="p">(</span><span class="n">FX</span><span class="p">,</span> <span class="n">FY</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">total_dist</span> <span class="o">/</span> <span class="n">nsim</span>

    <span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_attractors_functional_graph</span><span class="p">(</span><span class="n">next_state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify attractors and basins in a functional graph.</span>
<span class="sd">    </span>
<span class="sd">        Given a functional graph represented by a successor array, this function</span>
<span class="sd">        identifies all attractors (cycles), assigns each state to an attractor,</span>
<span class="sd">        and computes basin sizes and cycle properties.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        next_state : np.ndarray</span>
<span class="sd">            One-dimensional integer array of length ``n`` such that</span>
<span class="sd">            ``next_state[x]`` gives the successor of state ``x`` and lies in</span>
<span class="sd">            ``[0, n-1]``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        attr_id : np.ndarray</span>
<span class="sd">            Integer array of length ``n`` mapping each state to its attractor</span>
<span class="sd">            index.</span>
<span class="sd">        basin_sizes : np.ndarray</span>
<span class="sd">            Integer array of length ``n_attr`` giving the basin size of each</span>
<span class="sd">            attractor.</span>
<span class="sd">        cycle_rep : np.ndarray</span>
<span class="sd">            Integer array of length ``n_attr`` containing one representative</span>
<span class="sd">            state from each attractor cycle.</span>
<span class="sd">        cycle_len : np.ndarray</span>
<span class="sd">            Integer array of length ``n_attr`` giving the length of each cycle.</span>
<span class="sd">        n_attr : np.int32</span>
<span class="sd">            Number of attractors in the functional graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">next_state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">attr_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    
        <span class="c1"># For detecting cycles within the current walk:</span>
        <span class="c1"># seen[u] == run_id  means u was visited in this run</span>
        <span class="c1"># pos[u] = index of u in the current path (when first visited this run)</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    
        <span class="c1"># Upper bounds: in the worst case every node could be its own 1-cycle</span>
        <span class="n">basin_sizes_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">cycle_rep_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">cycle_len_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    
        <span class="n">n_attr</span> <span class="o">=</span> <span class="mi">0</span>
    
        <span class="c1"># Numba typed list for the current path</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">List</span><span class="o">.</span><span class="n">empty_list</span><span class="p">(</span><span class="n">int64</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr_id</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
    
            <span class="n">path</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">start</span>
            <span class="n">run_id</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># unique per start; safe while n &lt;&lt; 2**31 (always true in practice)</span>
    
            <span class="c1"># Walk until we hit a known attractor or revisit a node in this run</span>
            <span class="k">while</span> <span class="n">attr_id</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">seen</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="n">run_id</span><span class="p">:</span>
                <span class="n">seen</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">run_id</span>
                <span class="n">pos</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">next_state</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
    
            <span class="k">if</span> <span class="n">attr_id</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># This path flows into an already-known attractor</span>
                <span class="n">aid</span> <span class="o">=</span> <span class="n">attr_id</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">attr_id</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">aid</span>
                    <span class="n">basin_sizes_full</span><span class="p">[</span><span class="n">aid</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We found a cycle within the current run.</span>
                <span class="c1"># u is the first repeated node; cycle starts at pos[u] in path</span>
                <span class="n">cyc_start</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                <span class="n">aid</span> <span class="o">=</span> <span class="n">n_attr</span>
                <span class="n">n_attr</span> <span class="o">+=</span> <span class="mi">1</span>
    
                <span class="c1"># Representative and length of the cycle</span>
                <span class="n">cycle_rep_full</span><span class="p">[</span><span class="n">aid</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
                <span class="n">cycle_len_full</span><span class="p">[</span><span class="n">aid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">-</span> <span class="n">cyc_start</span>
    
                <span class="c1"># Assign all nodes on the path to this new attractor</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">attr_id</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">aid</span>
                    <span class="n">basin_sizes_full</span><span class="p">[</span><span class="n">aid</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    
        <span class="k">return</span> <span class="n">attr_id</span><span class="p">,</span> <span class="n">basin_sizes_full</span><span class="p">[:</span><span class="n">n_attr</span><span class="p">],</span> <span class="n">cycle_rep_full</span><span class="p">[:</span><span class="n">n_attr</span><span class="p">],</span> <span class="n">cycle_len_full</span><span class="p">[:</span><span class="n">n_attr</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">n_attr</span><span class="p">)</span>
    
    <span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_robustness_edge_traversal_numba</span><span class="p">(</span>
        <span class="n">N</span><span class="p">,</span>
        <span class="n">attractor_idx</span><span class="p">,</span>
        <span class="n">is_attr_mask</span><span class="p">,</span>
        <span class="n">dist_attr</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Traverse hypercube edges to compute basin and attractor robustness measures.</span>
<span class="sd">    </span>
<span class="sd">        This function iterates over all undirected edges of the Boolean hypercube</span>
<span class="sd">        exactly once and accumulates coherence and fragility contributions for</span>
<span class="sd">        basins of attraction and for attractor states.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        N : int</span>
<span class="sd">            Number of variables (dimension of the Boolean hypercube).</span>
<span class="sd">        attractor_idx : np.ndarray</span>
<span class="sd">            Integer array of shape ``(2**N,)`` mapping each state to its attractor</span>
<span class="sd">            index in ``[0, n_attr - 1]``.</span>
<span class="sd">        is_attr_mask : np.ndarray</span>
<span class="sd">            Boolean or uint8 array of shape ``(2**N,)`` indicating whether a state</span>
<span class="sd">            lies on an attractor.</span>
<span class="sd">        dist_attr : np.ndarray</span>
<span class="sd">            Two-dimensional array of shape ``(n_attr, n_attr)`` giving pairwise</span>
<span class="sd">            distances between attractors.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        basin_coh : np.ndarray</span>
<span class="sd">            Array of length ``n_attr`` containing basin coherence values.</span>
<span class="sd">        basin_frag : np.ndarray</span>
<span class="sd">            Array of length ``n_attr`` containing basin fragility values.</span>
<span class="sd">        attr_coh : np.ndarray</span>
<span class="sd">            Array of length ``n_attr`` containing attractor coherence values.</span>
<span class="sd">        attr_frag : np.ndarray</span>
<span class="sd">            Array of length ``n_attr`` containing attractor fragility values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_states</span> <span class="o">=</span> <span class="n">attractor_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_attr</span> <span class="o">=</span> <span class="n">dist_attr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
        <span class="n">basin_coh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_attr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">basin_frag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_attr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">attr_coh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_attr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">attr_frag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_attr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    
        <span class="c1"># Iterate each undirected hypercube edge exactly once:</span>
        <span class="c1"># For x, flip only bits that are 0 -&gt; y = x | (1&lt;&lt;bit), which guarantees y &gt; x.</span>
        <span class="k">for</span> <span class="n">xdec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
            <span class="n">idx_x</span> <span class="o">=</span> <span class="n">attractor_idx</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span>
            <span class="c1"># (Should never be -1 if attractor_idx is filled for all states)</span>
            <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">xdec</span> <span class="o">&gt;&gt;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">ydec</span> <span class="o">=</span> <span class="n">xdec</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">)</span>
                <span class="n">idx_y</span> <span class="o">=</span> <span class="n">attractor_idx</span><span class="p">[</span><span class="n">ydec</span><span class="p">]</span>
    
                <span class="k">if</span> <span class="n">idx_x</span> <span class="o">==</span> <span class="n">idx_y</span><span class="p">:</span>
                    <span class="c1"># same basin: count both directions (like your +2)</span>
                    <span class="n">basin_coh</span><span class="p">[</span><span class="n">idx_x</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">2.0</span>
                    <span class="k">if</span> <span class="n">is_attr_mask</span><span class="p">[</span><span class="n">xdec</span><span class="p">]:</span>
                        <span class="n">attr_coh</span><span class="p">[</span><span class="n">idx_x</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span>
                    <span class="k">if</span> <span class="n">is_attr_mask</span><span class="p">[</span><span class="n">ydec</span><span class="p">]:</span>
                        <span class="n">attr_coh</span><span class="p">[</span><span class="n">idx_y</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dxy</span> <span class="o">=</span> <span class="n">dist_attr</span><span class="p">[</span><span class="n">idx_x</span><span class="p">,</span> <span class="n">idx_y</span><span class="p">]</span>
                    <span class="n">basin_frag</span><span class="p">[</span><span class="n">idx_x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dxy</span>
                    <span class="n">basin_frag</span><span class="p">[</span><span class="n">idx_y</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dxy</span>
                    <span class="k">if</span> <span class="n">is_attr_mask</span><span class="p">[</span><span class="n">xdec</span><span class="p">]:</span>
                        <span class="n">attr_frag</span><span class="p">[</span><span class="n">idx_x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dxy</span>
                    <span class="k">if</span> <span class="n">is_attr_mask</span><span class="p">[</span><span class="n">ydec</span><span class="p">]:</span>
                        <span class="n">attr_frag</span><span class="p">[</span><span class="n">idx_y</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dxy</span>
    
        <span class="k">return</span> <span class="n">basin_coh</span><span class="p">,</span> <span class="n">basin_frag</span><span class="p">,</span> <span class="n">attr_coh</span><span class="p">,</span> <span class="n">attr_frag</span>


<div class="viewcode-block" id="BooleanNetwork">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BooleanNetwork</span><span class="p">(</span><span class="n">WiringDiagram</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of a Boolean network.</span>

<span class="sd">    A Boolean network consists of a wiring diagram specifying regulatory</span>
<span class="sd">    interactions between nodes and a collection of Boolean update functions</span>
<span class="sd">    defining the dynamics at each node.</span>
<span class="sd">    </span>
<span class="sd">    In a BooleanNetwork, constant nodes are removed during initialization, </span>
<span class="sd">    so all nodes represent dynamic variables.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    F : sequence</span>
<span class="sd">        Sequence of Boolean update functions or truth tables. Each entry may</span>
<span class="sd">        be a ``BooleanFunction`` instance, a truth table, or a Boolean</span>
<span class="sd">        expression. The length of ``F`` must match the number of nodes in the</span>
<span class="sd">        wiring diagram.</span>
<span class="sd">    I : sequence of sequences of int or WiringDiagram</span>
<span class="sd">        Wiring diagram specifying the regulators of each node, or an existing</span>
<span class="sd">        ``WiringDiagram`` instance.</span>
<span class="sd">    variables : sequence of str, optional</span>
<span class="sd">        Names of the variables corresponding to each node. Ignored if ``I`` is</span>
<span class="sd">        provided as a ``WiringDiagram``.</span>
<span class="sd">    SIMPLIFY_FUNCTIONS : bool, optional</span>
<span class="sd">        If True, simplify Boolean update functions after initialization.</span>
<span class="sd">        Default is False.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    F : list[BooleanFunction]</span>
<span class="sd">        Boolean update functions for each node.</span>
<span class="sd">    I : list[np.ndarray[int]]</span>
<span class="sd">        Wiring diagram specifying the regulators of each node.</span>
<span class="sd">    variables : np.ndarray[str]</span>
<span class="sd">        Names of the variables corresponding to each node.</span>
<span class="sd">    N : int</span>
<span class="sd">        Number of dynamic (non-constant) nodes in the network.</span>
<span class="sd">    indegrees : np.ndarray[int]</span>
<span class="sd">        Indegree of each node.</span>
<span class="sd">    outdegrees : np.ndarray[int]</span>
<span class="sd">        Outdegree of each node.</span>
<span class="sd">    constants : dict[str, dict[str, int | list[str]]]</span>
<span class="sd">        Mapping of node indices to constant values.</span>
<span class="sd">    weights : list[np.ndarray[float]] or None</span>
<span class="sd">        Interaction weights associated with the wiring diagram.</span>
<span class="sd">    STG : dict or None</span>
<span class="sd">        State transition graph, initialized to None and computed on demand.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">F</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">BooleanFunction</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">I</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="n">WiringDiagram</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">SIMPLIFY_FUNCTIONS</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a Boolean network.</span>
<span class="sd">    </span>
<span class="sd">        A Boolean network is defined by a wiring diagram specifying regulatory</span>
<span class="sd">        interactions between nodes and a collection of Boolean update functions</span>
<span class="sd">        defining the dynamics at each node. Constant nodes (nodes with no</span>
<span class="sd">        regulators) are automatically eliminated during initialization and</span>
<span class="sd">        stored in the ``constants`` attribute.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        F : sequence of BooleanFunction or array-like of int</span>
<span class="sd">            Boolean update functions for each node. Each entry must be either a</span>
<span class="sd">            ``BooleanFunction`` instance or a truth table encoding the function</span>
<span class="sd">            outputs. The length of ``F`` must match the number of nodes in the</span>
<span class="sd">            wiring diagram, and each function must have an arity consistent with</span>
<span class="sd">            the indegree of the corresponding node.</span>
<span class="sd">        I : sequence of sequences of int or WiringDiagram</span>
<span class="sd">            Wiring diagram specifying the regulators of each node, or an existing</span>
<span class="sd">            ``WiringDiagram`` instance. Regulator indices are assumed to be</span>
<span class="sd">            zero-based.</span>
<span class="sd">        variables : sequence of str, optional</span>
<span class="sd">            Names of the variables corresponding to each node. Ignored if ``I`` is</span>
<span class="sd">            provided as a ``WiringDiagram``.</span>
<span class="sd">        SIMPLIFY_FUNCTIONS : bool, optional</span>
<span class="sd">            If True, Boolean update functions are simplified after initialization.</span>
<span class="sd">            Default is False.</span>
<span class="sd">    </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If ``F`` is not a sequence of ``BooleanFunction`` objects or truth</span>
<span class="sd">            tables, or if ``I`` is not a valid wiring diagram specification.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the length of ``F`` does not match the number of nodes in the wiring</span>
<span class="sd">            diagram, or if a Boolean function has an arity inconsistent with the</span>
<span class="sd">            wiring diagram.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Constant nodes are removed from the dynamic network during</span>
<span class="sd">          initialization and recorded in the ``constants`` attribute.</span>
<span class="sd">        - After initialization, the attribute ``N`` refers to the number of</span>
<span class="sd">          remaining dynamic nodes.</span>
<span class="sd">        - The state transition graph (``STG``) is initialized to ``None`` and</span>
<span class="sd">          computed on demand.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># ---- Validate inputs -------------------------------------------------</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;F must be a sequence of BooleanFunction objects or truth tables&quot;</span>
            <span class="p">)</span>
    
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="p">(</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">WiringDiagram</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;I must be a sequence of sequences of int or a WiringDiagram instance&quot;</span>
            <span class="p">)</span>
    
        <span class="c1"># ---- Initialize wiring diagram --------------------------------------</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">WiringDiagram</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Provided variables ignored; using variables from WiringDiagram.&quot;</span><span class="p">,</span>
                    <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">I</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">variables</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(F) must match the number of nodes in the wiring diagram&quot;</span><span class="p">)</span>
    
        <span class="c1"># ---- BooleanNetwork invariant: do not expose these -------------------</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_variables</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_constants</span>
    
        <span class="c1"># ---- Initialize Boolean functions -----------------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="p">[]</span>
    
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">bf</span> <span class="o">=</span> <span class="n">BooleanFunction</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">BooleanFunction</span><span class="p">):</span>
                <span class="n">bf</span> <span class="o">=</span> <span class="n">f</span>
                <span class="n">bf</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Invalid entry in F at index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: expected BooleanFunction, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;truth table, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
    
            <span class="k">if</span> <span class="n">bf</span><span class="o">.</span><span class="n">n</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: function has </span><span class="si">{</span><span class="n">bf</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s2"> inputs but wiring diagram &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;has indegree </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
    
            <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bf</span><span class="p">)</span>
    
        <span class="c1"># ---- Constant bookkeeping -------------------------------------------</span>
        <span class="c1"># Always initialize (may already exist if called from get_network_with_fixed_source_nodes, etc)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{}</span>
    
        <span class="c1"># IMPORTANT: remove constants based on topology, not on dict contents</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_constants</span><span class="p">()</span>
    
        <span class="c1"># ---- State transition graph -----------------------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">STG</span> <span class="o">=</span> <span class="kc">None</span>
    
        <span class="c1"># ---- Optional simplification ----------------------------------------</span>
        <span class="k">if</span> <span class="n">SIMPLIFY_FUNCTIONS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simplify_functions</span><span class="p">()</span>

<div class="viewcode-block" id="BooleanNetwork.remove_constants">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.remove_constants">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_constants</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove structurally constant nodes from the Boolean network.</span>
<span class="sd">    </span>
<span class="sd">        A node is considered constant if it has no regulators (indegree zero).</span>
<span class="sd">        Such nodes are eliminated from the dynamic network by propagating their</span>
<span class="sd">        fixed Boolean values to downstream nodes. Eliminated constants and their</span>
<span class="sd">        effects are recorded in the ``constants`` attribute.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The Boolean value of a constant node is taken from its Boolean function.</span>
<span class="sd">        - After removal, ``self.N`` refers to the number of remaining dynamic nodes.</span>
<span class="sd">        - Nodes that lose all regulators as a result of constant removal are</span>
<span class="sd">          assigned a non-essential self-loop to preserve network structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Identify constant nodes from topology</span>
        <span class="n">indices_constants</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_constants</span><span class="p">(</span><span class="n">AS_DICT</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_constants</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
    
        <span class="n">dict_constants</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_constants</span><span class="p">(</span><span class="n">AS_DICT</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">values_constants</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">indices_constants</span><span class="p">]</span>
    
        <span class="c1"># Propagate constant values downstream</span>
        <span class="k">for</span> <span class="n">id_constant</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices_constants</span><span class="p">,</span> <span class="n">values_constants</span><span class="p">):</span>
            <span class="n">regulated_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dict_constants</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">continue</span>
    
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">id_constant</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">continue</span>
    
                <span class="n">truth_table</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_left_side_of_truth_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">indices_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">truth_table</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
                <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>
    
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">id_constant</span><span class="p">]</span>
    
                <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">id_constant</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
    
                <span class="n">regulated_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    
            <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">id_constant</span><span class="p">])]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span>
                <span class="s2">&quot;regulatedNodes&quot;</span><span class="p">:</span> <span class="n">regulated_nodes</span><span class="p">,</span>
            <span class="p">}</span>
    
        <span class="c1"># Ensure no remaining node loses all regulators</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dict_constants</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>
    
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    
        <span class="c1"># Remove constant nodes structurally (using original mask)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">dict_constants</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    
        <span class="n">adjustment_for_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">dict_constants</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">adjustment_for_I</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dict_constants</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="p">]</span>
    
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">dict_constants</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">dict_constants</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="p">)</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">dict_constants</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="p">)</span>
    
        <span class="c1"># Update network size and recompute outdegrees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outdegrees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_outdegrees</span><span class="p">()</span></div>


        
<div class="viewcode-block" id="BooleanNetwork.from_cana">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.from_cana">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_cana</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">cana_BooleanNetwork</span><span class="p">:</span> <span class="s2">&quot;cana.boolean_network.BooleanNetwork&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanNetwork&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a BooleanNetwork from a ``cana.BooleanNetwork`` instance.</span>
<span class="sd">    </span>
<span class="sd">        This compatibility method converts a Boolean network defined using the</span>
<span class="sd">        ``cana`` package into a BoolForge ``BooleanNetwork``.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cana_BooleanNetwork : cana.boolean_network.BooleanNetwork</span>
<span class="sd">            A Boolean network instance from the ``cana`` package.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BooleanNetwork</span>
<span class="sd">            The corresponding BoolForge BooleanNetwork.</span>
<span class="sd">    </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the input object does not appear to be a valid CANA BooleanNetwork.</span>
<span class="sd">        KeyError</span>
<span class="sd">            If required fields are missing from the CANA logic specification.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">logic</span> <span class="o">=</span> <span class="n">cana_BooleanNetwork</span><span class="o">.</span><span class="n">logic</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Input must be a cana.boolean_network.BooleanNetwork instance.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
    
        <span class="n">F</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">I</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>
    
        <span class="c1"># Ensure deterministic ordering by node index</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">logic</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="n">logic</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    
            <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entry</span> <span class="ow">or</span> <span class="s2">&quot;in&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entry</span> <span class="ow">or</span> <span class="s2">&quot;out&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Logic entry for node </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> must contain keys &quot;</span>
                    <span class="s2">&quot;&#39;name&#39;, &#39;in&#39;, and &#39;out&#39;.&quot;</span>
                <span class="p">)</span>
    
            <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]))</span>
            <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="s2">&quot;in&quot;</span><span class="p">]))</span>
            <span class="n">F</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="s2">&quot;out&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
    
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">F</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">)</span></div>



<div class="viewcode-block" id="BooleanNetwork.from_string">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.from_string">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_string</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">network_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">separator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span>
        <span class="n">max_degree</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
        <span class="n">original_not</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;NOT&quot;</span><span class="p">,</span>
        <span class="n">original_and</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;AND&quot;</span><span class="p">,</span>
        <span class="n">original_or</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;OR&quot;</span><span class="p">,</span>
        <span class="n">ALLOW_TRUNCATION</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanNetwork&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a BooleanNetwork from a textual Boolean rule specification.</span>
<span class="sd">    </span>
<span class="sd">        This compatibility method parses a string representation of Boolean update</span>
<span class="sd">        rules and constructs a corresponding BooleanNetwork. The input format is</span>
<span class="sd">        intended for legacy or trusted sources and supports logical expressions</span>
<span class="sd">        using AND/OR/NOT operators.</span>
<span class="sd">    </span>
<span class="sd">        .. warning::</span>
<span class="sd">            This method uses ``eval`` internally and MUST NOT be used on untrusted</span>
<span class="sd">            input. It is provided solely for backward compatibility.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        network_string : str</span>
<span class="sd">            String encoding Boolean update rules, one per line.</span>
<span class="sd">        separator : str or sequence of str, optional</span>
<span class="sd">            Separator(s) between variable names and Boolean expressions.</span>
<span class="sd">        max_degree : int, optional</span>
<span class="sd">            Maximum allowed indegree for explicit truth-table construction.</span>
<span class="sd">        original_not, original_and, original_or : str or sequence of str, optional</span>
<span class="sd">            Operator strings to be replaced by logical NOT, AND, OR.</span>
<span class="sd">        ALLOW_TRUNCATION : bool, optional</span>
<span class="sd">            If False (default), nodes with indegree greater than ``max_degree``</span>
<span class="sd">            raise a ValueError. If True, such nodes are replaced by identity</span>
<span class="sd">            self-loops, allowing fast construction of large networks while</span>
<span class="sd">            ignoring high-degree functions.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BooleanNetwork</span>
<span class="sd">            The constructed Boolean network.</span>
<span class="sd">    </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If parsing fails or if ``ALLOW_TRUNCATION`` is False and </span>
<span class="sd">            a node exceeds ``max_degree``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sepstr</span><span class="p">,</span> <span class="n">andop</span><span class="p">,</span> <span class="n">orop</span><span class="p">,</span> <span class="n">notop</span> <span class="o">=</span> <span class="s2">&quot;@&quot;</span><span class="p">,</span> <span class="s2">&quot;∧&quot;</span><span class="p">,</span> <span class="s2">&quot;∨&quot;</span><span class="p">,</span> <span class="s2">&quot;¬&quot;</span>
        <span class="n">get_dummy_var</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;x</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2">y&quot;</span>
    
        <span class="k">def</span><span class="w"> </span><span class="nf">_replace_all</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">original</span><span class="p">,</span> <span class="n">replacement</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">original</span><span class="p">:</span>
                    <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">replacement</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">replacement</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">string</span>
    
        <span class="c1"># Normalize input</span>
        <span class="n">text</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">network_string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot; ( &quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot; ) &quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">_replace_all</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">separator</span><span class="p">,</span> <span class="n">sepstr</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">_replace_all</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">original_not</span><span class="p">,</span> <span class="n">notop</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">_replace_all</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">original_and</span><span class="p">,</span> <span class="n">andop</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">_replace_all</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">original_or</span><span class="p">,</span> <span class="n">orop</span><span class="p">)</span>
    
        <span class="c1"># Remove comments and empty lines</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">text</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">)</span>
        <span class="p">]</span>
    
        <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sepstr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">]</span>
    
        <span class="c1"># Collect symbols</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="n">sepstr</span><span class="p">,</span> <span class="n">andop</span><span class="p">,</span> <span class="n">orop</span><span class="p">,</span> <span class="n">notop</span><span class="p">}</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>
                    <span class="n">symbols</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    
        <span class="n">consts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">symbols</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">variables</span><span class="p">))</span>
        <span class="n">dummy_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">get_dummy_var</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">variables</span> <span class="o">+</span> <span class="n">consts</span><span class="p">)}</span>
    
        <span class="c1"># Replace symbols with dummy variables</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dummy_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">)</span>
    
        <span class="n">expressions</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sepstr</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">]</span>
    
        <span class="n">I</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">F</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    
        <span class="c1"># Build wiring diagram</span>
        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
            <span class="n">regs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">k</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">utils</span><span class="o">.</span><span class="n">find_all_indices</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">),</span>
                    <span class="n">utils</span><span class="o">.</span><span class="n">find_all_indices</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
    
        <span class="c1"># Build Boolean functions</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">expressions</span><span class="p">):</span>
            <span class="n">deg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    
            <span class="k">if</span> <span class="n">deg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">F</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">expr</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
    
            <span class="k">elif</span> <span class="n">deg</span> <span class="o">&gt;</span> <span class="n">max_degree</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ALLOW_TRUNCATION</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Node &#39;</span><span class="si">{</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39; has indegree </span><span class="si">{</span><span class="n">deg</span><span class="si">}</span><span class="s2"> &gt; max_degree=</span><span class="si">{</span><span class="n">max_degree</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                <span class="c1"># Truncate: identity self-loop</span>
                <span class="n">F</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
                <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_left_side_of_truth_table</span><span class="p">(</span><span class="n">deg</span><span class="p">)</span>
                <span class="n">env</span> <span class="o">=</span> <span class="p">{</span><span class="n">get_dummy_var</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]):</span> <span class="n">tt</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg</span><span class="p">)}</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span>
                        <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">andop</span><span class="p">,</span> <span class="s2">&quot;&amp;&quot;</span><span class="p">)</span>
                            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">orop</span><span class="p">,</span> <span class="s2">&quot;|&quot;</span><span class="p">)</span>
                            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">notop</span><span class="p">,</span> <span class="s2">&quot;~&quot;</span><span class="p">)</span>
                            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                        <span class="p">{</span><span class="s2">&quot;__builtins__&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
                        <span class="n">env</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to parse expression: </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
    
                <span class="n">F</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
    
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">variables</span><span class="p">)</span></div>



<div class="viewcode-block" id="BooleanNetwork.from_DiGraph">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.from_DiGraph">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_DiGraph</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">nx_DiGraph</span><span class="p">:</span> <span class="s2">&quot;nx.DiGraph&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;WiringDiagram&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;from_DiGraph is not supported for BooleanNetwork. &quot;</span>
            <span class="s2">&quot;Use WiringDiagram.from_DiGraph and then construct &quot;</span>
            <span class="s2">&quot;a BooleanNetwork by providing Boolean update functions.&quot;</span>
        <span class="p">)</span></div>

    
<div class="viewcode-block" id="BooleanNetwork.to_cana">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.to_cana">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_cana</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;cana.boolean_network.BooleanNetwork&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export the Boolean network as a ``cana.BooleanNetwork`` instance.</span>
<span class="sd">    </span>
<span class="sd">        This compatibility method converts the current BooleanNetwork into an</span>
<span class="sd">        equivalent representation from the ``cana`` package. The exported network</span>
<span class="sd">        reflects the current state of the model, including any removed constants,</span>
<span class="sd">        simplifications, or identity self-loops.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cana.boolean_network.BooleanNetwork</span>
<span class="sd">            A ``cana`` BooleanNetwork instance representing this network.</span>
<span class="sd">    </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ImportError</span>
<span class="sd">            If the ``cana`` package is not installed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">cana</span>
        <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;The &#39;cana&#39; package is required for to_cana().&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
    
        <span class="n">logic_dicts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bf</span><span class="p">,</span> <span class="n">regulators</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="n">logic_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">var</span><span class="p">,</span>
                    <span class="s2">&quot;in&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">regulators</span><span class="p">),</span>
                    <span class="s2">&quot;out&quot;</span><span class="p">:</span> <span class="n">bf</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                <span class="p">}</span>
            <span class="p">)</span>
    
        <span class="k">return</span> <span class="n">cana</span><span class="o">.</span><span class="n">boolean_network</span><span class="o">.</span><span class="n">BooleanNetwork</span><span class="p">(</span>
            <span class="n">Nnodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span>
            <span class="n">logic</span><span class="o">=</span><span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">d</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">logic_dicts</span><span class="p">)},</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="BooleanNetwork.to_bnet">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.to_bnet">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_bnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">separator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;,</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">AS_POLYNOMIAL</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export the Boolean network in BNET format.</span>
<span class="sd">    </span>
<span class="sd">        This compatibility method returns a string representation of the Boolean</span>
<span class="sd">        network in the BNET format used by tools such as BoolNet and PyBoolNet,</span>
<span class="sd">        with one line per variable of the form ``variable &lt;separator&gt; function``.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        separator : str, optional</span>
<span class="sd">            String used to separate the target variable from its update function.</span>
<span class="sd">            Default is `&quot;,\\t&quot;`.</span>
<span class="sd">        AS_POLYNOMIAL : bool, optional</span>
<span class="sd">            If True (default), return Boolean functions in polynomial form.</span>
<span class="sd">            If False, return functions as logical expressions.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            A string containing the BNET representation of the network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">constants_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_constants</span><span class="p">(</span><span class="n">AS_DICT</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">constants_indices</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">function</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">AS_POLYNOMIAL</span><span class="p">:</span>
                <span class="n">function</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">bool_to_poly</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">to_expression</span><span class="p">(</span><span class="s2">&quot; &amp; &quot;</span><span class="p">,</span> <span class="s2">&quot; | &quot;</span><span class="p">)</span>
    
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}{</span><span class="n">separator</span><span class="si">}{</span><span class="n">function</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>


    
    
<div class="viewcode-block" id="BooleanNetwork.to_truth_table">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.to_truth_table">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_truth_table</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the full synchronous truth table of the Boolean network.</span>
<span class="sd">    </span>
<span class="sd">        Each row corresponds to a network state at time ``t`` and its deterministic</span>
<span class="sd">        successor at time ``t+1`` under synchronous updating.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            If provided, the truth table is written to a file. The file extension</span>
<span class="sd">            determines the format and must be one of ``&#39;csv&#39;``, ``&#39;xls&#39;``, or</span>
<span class="sd">            ``&#39;xlsx&#39;``. If None (default), no file is created.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            The full truth table with shape ``(2**N, 2*N)``.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - States are enumerated in lexicographic order, consistent with</span>
<span class="sd">          ``utils.get_left_side_of_truth_table``.</span>
<span class="sd">        - This method computes and stores the synchronous state transition graph</span>
<span class="sd">          (``self.STG``) if it has not been computed previously.</span>
<span class="sd">        - Exporting to Excel requires the ``openpyxl`` package.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;(t)&quot;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">]</span>
        <span class="n">columns</span> <span class="o">+=</span> <span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;(t+1)&quot;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">]</span>
    
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">STG</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_synchronous_state_transition_graph</span><span class="p">()</span>
    
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_left_side_of_truth_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">STG</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
    
        <span class="n">truth_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;filename must be a string&quot;</span><span class="p">)</span>
    
            <span class="n">ending</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ending</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;csv&quot;</span><span class="p">,</span> <span class="s2">&quot;xls&quot;</span><span class="p">,</span> <span class="s2">&quot;xlsx&quot;</span><span class="p">}:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;filename must end in &#39;csv&#39;, &#39;xls&#39;, or &#39;xlsx&#39;&quot;</span><span class="p">)</span>
    
            <span class="k">if</span> <span class="n">ending</span> <span class="o">==</span> <span class="s2">&quot;csv&quot;</span><span class="p">:</span>
                <span class="n">truth_table</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">truth_table</span><span class="o">.</span><span class="n">to_excel</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">truth_table</span></div>


    
    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
    
    
<div class="viewcode-block" id="BooleanNetwork.__str__">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.__str__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;BooleanNetwork(N=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;indegrees=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span></div>

    
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    
<div class="viewcode-block" id="BooleanNetwork.__repr__">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.__repr__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;BooleanNetwork(N=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="si">}</span><span class="s2">)&quot;</span></div>

    
    
<div class="viewcode-block" id="BooleanNetwork.__call__">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.__call__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply one synchronous update step to the Boolean network.</span>
<span class="sd">    </span>
<span class="sd">        The next state is obtained by evaluating each node&#39;s Boolean update</span>
<span class="sd">        function on the current values of its regulators.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state : sequence of int</span>
<span class="sd">            Current network state as a binary vector of length ``N``, ordered</span>
<span class="sd">            according to ``self.variables``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The updated network state after one synchronous update.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is equivalent to calling ``update_network_synchronously``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_network_synchronously</span><span class="p">(</span><span class="n">state</span><span class="p">)</span></div>

    
    
<div class="viewcode-block" id="BooleanNetwork.get_types_of_regulation">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.get_types_of_regulation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_types_of_regulation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute and return regulation types (weights) for all nodes in the network.</span>
<span class="sd">    </span>
<span class="sd">        For each Boolean function, the type of each input regulation is determined</span>
<span class="sd">        via ``BooleanFunction.get_type_of_inputs`` and mapped to numerical weights</span>
<span class="sd">        using ``dict_weights``. The resulting weights are stored in the</span>
<span class="sd">        ``self.weights`` attribute and also returned.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of np.ndarray</span>
<span class="sd">            Regulation weights for each node, aligned with the wiring diagram.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method recomputes ``self.weights`` from scratch.</span>
<span class="sd">        - Calling this method overwrites any existing values in ``self.weights``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dict_weights</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">bf</span><span class="o">.</span><span class="n">get_type_of_inputs</span><span class="p">()],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span></div>




    <span class="c1">## Transform Boolean networks</span>
<div class="viewcode-block" id="BooleanNetwork.simplify_functions">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.simplify_functions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">simplify_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all non-essential regulators from the Boolean network.</span>
<span class="sd">    </span>
<span class="sd">        For each node, non-essential regulators (identified via ``np.nan`` entries</span>
<span class="sd">        in ``self.weights``) are removed from the wiring diagram and the associated</span>
<span class="sd">        Boolean function is restricted to its essential inputs. Nodes that would</span>
<span class="sd">        otherwise lose all regulators are assigned an identity self-loop to preserve</span>
<span class="sd">        network structure.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method modifies the network in place.</span>
<span class="sd">        - Regulation types (``self.weights``) are recomputed if necessary.</span>
<span class="sd">        - Identity self-loops introduced here are structural artifacts and do not</span>
<span class="sd">          represent genuine regulatory interactions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure regulation types / weights are available</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_types_of_regulation</span><span class="p">()</span>
    
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="n">regulator_is_non_essential</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    
            <span class="c1"># All regulators are essential</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">regulator_is_non_essential</span><span class="p">):</span>
                <span class="k">continue</span>
    
            <span class="n">non_essential_variables</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">regulator_is_non_essential</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">essential_variables</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">regulator_is_non_essential</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
            <span class="c1"># Update outdegrees (each regulator appears at most once in I[i])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outdegrees</span><span class="p">[</span><span class="n">non_essential_variables</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
    
            <span class="c1"># No essential regulators: introduce identity self-loop</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">essential_variables</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outdegrees</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># keep sum(outdegrees) == sum(indegrees)</span>
                <span class="k">continue</span>
    
            <span class="c1"># Restrict truth table to essential inputs</span>
            <span class="n">left_side</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_left_side_of_truth_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">left_side</span><span class="p">[:,</span> <span class="n">non_essential_variables</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    
            <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">essential_variables</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="o">~</span><span class="n">regulator_is_non_essential</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">essential_variables</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">essential_variables</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">essential_variables</span><span class="p">)</span></div>



<div class="viewcode-block" id="BooleanNetwork.get_identity_nodes">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.get_identity_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_identity_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">AS_DICT</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify identity (memory) nodes in the Boolean network.</span>
<span class="sd">    </span>
<span class="sd">        An identity node is a node with a single self-regulatory edge whose</span>
<span class="sd">        Boolean update function is the identity function ``f(x) = x``. Such</span>
<span class="sd">        nodes retain their state over time unless externally modified.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        AS_DICT : bool, optional</span>
<span class="sd">            If True, return a dictionary mapping node indices to booleans.</span>
<span class="sd">            If False (default), return an array of indices of identity nodes.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict[int, bool] or np.ndarray</span>
<span class="sd">            If ``AS_DICT`` is True, a dictionary indicating which nodes are</span>
<span class="sd">            identity nodes.</span>
<span class="sd">            If ``AS_DICT`` is False, an array of indices of identity nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_identity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
            <span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span>
        <span class="p">)</span>
    
        <span class="k">if</span> <span class="n">AS_DICT</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">is_identity</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">is_identity</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>



<div class="viewcode-block" id="BooleanNetwork.get_network_with_fixed_identity_nodes">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.get_network_with_fixed_identity_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_network_with_fixed_identity_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">values_identity_nodes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanNetwork&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a Boolean network with identity nodes fixed to given values.</span>
<span class="sd">    </span>
<span class="sd">        Identity nodes are nodes with a single self-regulatory edge and identity</span>
<span class="sd">        update rule ``f(x) = x``. This method fixes the values of such nodes and</span>
<span class="sd">        returns a new BooleanNetwork with the corresponding constants removed.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values_identity_nodes : sequence of int</span>
<span class="sd">            Values to fix for each identity node, in the order returned by</span>
<span class="sd">            ``get_identity_nodes(AS_DICT=False)``. Each value must be either 0 or 1.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BooleanNetwork</span>
<span class="sd">            A new BooleanNetwork with the specified identity nodes fixed. Any</span>
<span class="sd">            constants previously removed from the original network are preserved.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices_identity_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_identity_nodes</span><span class="p">(</span><span class="n">AS_DICT</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values_identity_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_identity_nodes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The number of values provided (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">values_identity_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">) must &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;match the number of identity nodes (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">indices_identity_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>
    
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values_identity_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Identity node values must be 0 or 1.&quot;</span><span class="p">)</span>
    
        <span class="n">F</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">identity_node</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices_identity_nodes</span><span class="p">,</span> <span class="n">values_identity_nodes</span><span class="p">):</span>
            <span class="n">F</span><span class="p">[</span><span class="n">identity_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">BooleanFunction</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">value</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
            <span class="n">I</span><span class="p">[</span><span class="n">identity_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    
        <span class="n">bn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
    
        <span class="c1"># Preserve previously removed constants</span>
        <span class="n">bn</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">bn</span></div>



<div class="viewcode-block" id="BooleanNetwork.get_network_with_node_controls">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.get_network_with_node_controls">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_network_with_node_controls</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indices_controlled_nodes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">values_controlled_nodes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">KEEP_CONTROLLED_NODES</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanNetwork&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a Boolean network with specified nodes fixed to given values.</span>
<span class="sd">    </span>
<span class="sd">        This method applies node-level interventions by fixing selected nodes to</span>
<span class="sd">        constant Boolean values. Controlled nodes may either be removed from the</span>
<span class="sd">        dynamic network as constants or retained as identity-clamped nodes.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices_controlled_nodes : sequence of int</span>
<span class="sd">            Indices of nodes to be fixed.</span>
<span class="sd">        values_controlled_nodes : sequence of int</span>
<span class="sd">            Values to fix for each specified node, in the same order as</span>
<span class="sd">            ``indices_controlled_nodes``. Each value must be either 0 or 1.</span>
<span class="sd">        KEEP_CONTROLLED_NODES : bool, optional</span>
<span class="sd">            If True, controlled nodes are retained in the network as identity</span>
<span class="sd">            nodes with self-loops. If False (default), controlled nodes are</span>
<span class="sd">            eliminated as constants.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BooleanNetwork</span>
<span class="sd">            A new BooleanNetwork with the specified node controls applied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_controlled_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values_controlled_nodes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The number of controlled nodes (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">indices_controlled_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">) &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;must match the number of values provided (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">values_controlled_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>
    
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">indices_controlled_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">node</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">node</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid node index: </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values_controlled_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Controlled node values must be 0 or 1.&quot;</span><span class="p">)</span>
    
        <span class="n">F</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices_controlled_nodes</span><span class="p">,</span> <span class="n">values_controlled_nodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">KEEP_CONTROLLED_NODES</span><span class="p">:</span>
                <span class="c1"># Identity-clamped node</span>
                <span class="n">F</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">I</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">node</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Structural constant (to be removed)</span>
                <span class="n">F</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">value</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">I</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    
        <span class="n">bn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
    
        <span class="c1"># Preserve previously removed constants if controlled nodes are eliminated</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">KEEP_CONTROLLED_NODES</span><span class="p">:</span>
            <span class="n">bn</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">bn</span></div>



<div class="viewcode-block" id="BooleanNetwork.get_network_with_edge_controls">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.get_network_with_edge_controls">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_network_with_edge_controls</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">control_targets</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">control_sources</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">values_edge_controls</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanNetwork&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a Boolean network with specified regulatory edges controlled.</span>
<span class="sd">    </span>
<span class="sd">        This method fixes the influence of selected source nodes on selected target</span>
<span class="sd">        nodes by restricting the target&#39;s Boolean update function to entries where</span>
<span class="sd">        the source assumes a specified value, and then removing the corresponding</span>
<span class="sd">        regulatory edge.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        control_targets : sequence of int</span>
<span class="sd">            Indices of target nodes.</span>
<span class="sd">        control_sources : sequence of int</span>
<span class="sd">            Indices of source nodes whose influence on the corresponding targets</span>
<span class="sd">            is to be controlled.</span>
<span class="sd">        values_edge_controls : sequence of int, optional</span>
<span class="sd">            Fixed values (0 or 1) imposed on each controlled edge. If None, all</span>
<span class="sd">            controlled edges are fixed to 0.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BooleanNetwork</span>
<span class="sd">            A new BooleanNetwork with the specified edge controls applied.</span>
<span class="sd">    </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If input lengths do not match, indices are invalid, or edge values are</span>
<span class="sd">            not in {0, 1}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">control_targets</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">control_sources</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;control_targets and control_sources must have equal length.&quot;</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">values_edge_controls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values_edge_controls</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">control_targets</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values_edge_controls</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">control_targets</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;values_edge_controls must have the same length as control_targets.&quot;</span>
            <span class="p">)</span>
    
        <span class="n">F_new</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">)</span>
        <span class="n">I_new</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">fixed_value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">control_targets</span><span class="p">,</span> <span class="n">control_sources</span><span class="p">,</span> <span class="n">values_edge_controls</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">fixed_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Edge control values must be 0 or 1.&quot;</span><span class="p">)</span>
    
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid target index: </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">source</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid source index: </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
            <span class="k">if</span> <span class="n">source</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">I_new</span><span class="p">[</span><span class="n">target</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Source node </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2"> is not a regulator of target node </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
    
            <span class="n">idx_reg</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">I_new</span><span class="p">[</span><span class="n">target</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="n">n_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
    
            <span class="n">truth_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">truth_indices</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n_inputs</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">idx_reg</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">fixed_value</span>
    
            <span class="c1"># Restrict truth table</span>
            <span class="n">F_new</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">F_new</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">F_new</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
    
            <span class="c1"># Remove regulator</span>
            <span class="n">I_new</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">I_new</span><span class="p">[</span><span class="n">target</span><span class="p">],</span> <span class="n">idx_reg</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">F_new</span><span class="p">,</span> <span class="n">I_new</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span></div>


            
<div class="viewcode-block" id="BooleanNetwork.update_single_node">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.update_single_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_single_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">states_regulators</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the state of a single node.</span>
<span class="sd">    </span>
<span class="sd">        The new state is obtained by applying the Boolean update function to the</span>
<span class="sd">        states of its regulators.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>
<span class="sd">            Index of the node to update.</span>
<span class="sd">        states_regulators : sequence of int</span>
<span class="sd">            Binary states of the node&#39;s regulators.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Updated state of the node (0 or 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">states_regulators</span><span class="p">)]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span></div>



<div class="viewcode-block" id="BooleanNetwork.update_network_synchronously">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.update_network_synchronously">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_network_synchronously</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a synchronous update of the Boolean network.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state : sequence of int</span>
<span class="sd">            Binary state vector of length ``N``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Updated state vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;State vector must have length </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
    
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;State vector must be binary (0 or 1).&quot;</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_network_synchronously_unchecked</span><span class="p">(</span><span class="n">state</span><span class="p">)</span></div>

    

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_network_synchronously_unchecked</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal fast path. Assumes validated binary state.&quot;&quot;&quot;</span>
        <span class="n">next_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="n">next_state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]])]</span>
        <span class="k">return</span> <span class="n">next_state</span>


<div class="viewcode-block" id="BooleanNetwork.update_network_SDDS">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.update_network_SDDS">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_network_SDDS</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">P</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a stochastic discrete dynamical system (SDDS) update of the network.</span>
<span class="sd">    </span>
<span class="sd">        This update scheme follows the SDDS formalism: for each node, the</span>
<span class="sd">        deterministic Boolean update is first computed. If the update would</span>
<span class="sd">        increase the node&#39;s state, the change occurs with the node-specific</span>
<span class="sd">        activation probability. If the update would decrease the node&#39;s state,</span>
<span class="sd">        the change occurs with the node-specific degradation probability.</span>
<span class="sd">        Otherwise, the node&#39;s state remains unchanged.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state : sequence of int</span>
<span class="sd">            Current network state (binary vector of length ``N``).</span>
<span class="sd">        P : np.ndarray</span>
<span class="sd">            Array of shape ``(N, 2)``, where ``P[i, 0]`` is the activation</span>
<span class="sd">            probability and ``P[i, 1]`` is the degradation probability for node ``i``.</span>
<span class="sd">        rng : optional</span>
<span class="sd">            Random number generator or seed, passed to ``utils._coerce_rng``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Updated network state after one stochastic SDDS update.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This implementation follows the SDDS framework introduced in:</span>
<span class="sd">    </span>
<span class="sd">        Murrugarra, D., Veliz-Cuba, A., Aguilar, B., Arat, S., &amp; Laubenbacher, R.</span>
<span class="sd">        (2012). *Modeling stochasticity and variability in gene regulatory networks*.</span>
<span class="sd">        EURASIP Journal on Bioinformatics and Systems Biology, 2012(1), 5.</span>
<span class="sd">    </span>
<span class="sd">        The method assumes that ``state`` is a valid binary vector and that</span>
<span class="sd">        ``P`` has the correct shape; no additional validation is performed</span>
<span class="sd">        for performance reasons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_coerce_rng</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    
        <span class="n">Fx</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="n">nextstep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_single_node</span><span class="p">(</span>
                <span class="n">index</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                <span class="n">states_regulators</span><span class="o">=</span><span class="n">state</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
            <span class="p">)</span>
    
            <span class="k">if</span> <span class="n">nextstep</span> <span class="o">&gt;</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
                    <span class="n">Fx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextstep</span>
            <span class="k">elif</span> <span class="n">nextstep</span> <span class="o">&lt;</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">Fx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextstep</span>
    
        <span class="k">return</span> <span class="n">Fx</span></div>




<div class="viewcode-block" id="BooleanNetwork.get_steady_states_asynchronous_exact">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.get_steady_states_asynchronous_exact">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_steady_states_asynchronous_exact</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stochastic_weights</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-9</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the steady states and basin probabilities under general asynchronous update.</span>
<span class="sd">        </span>
<span class="sd">        This method exhaustively constructs the asynchronous state transition graph</span>
<span class="sd">        (STG) of the Boolean network under a general asynchronous update scheme,</span>
<span class="sd">        where nodes are selected for update according to given propensities.</span>
<span class="sd">        The resulting Markov chain is solved exactly using an iterative</span>
<span class="sd">        Gauss–Seidel scheme to obtain absorption probabilities into steady states.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stochastic_weights : sequence of float or None, optional</span>
<span class="sd">            Relative update propensities for each node. If None (default),</span>
<span class="sd">            all nodes are updated with equal probability. The weights are</span>
<span class="sd">            normalized internally.</span>
<span class="sd">        max_iterations : int, optional</span>
<span class="sd">            Maximum number of Gauss–Seidel iterations used to compute absorption</span>
<span class="sd">            probabilities before declaring non-convergence.</span>
<span class="sd">        tol : float, optional</span>
<span class="sd">            Convergence tolerance for the infinity norm of probability updates.</span>
<span class="sd">        s</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary with the following entries:</span>
<span class="sd">        </span>
<span class="sd">            - ``&quot;SteadyStates&quot;`` : list of int  </span>
<span class="sd">              Decimal representations of steady states.</span>
<span class="sd">        </span>
<span class="sd">            - ``&quot;NumberOfSteadyStates&quot;`` : int  </span>
<span class="sd">              Total number of steady states.</span>
<span class="sd">        </span>
<span class="sd">            - ``&quot;BasinSizes&quot;`` : np.ndarray  </span>
<span class="sd">              Fraction of the state space converging to each steady state.</span>
<span class="sd">        </span>
<span class="sd">            - ``&quot;STGAsynchronous&quot;`` : dict  </span>
<span class="sd">              Asynchronous state transition graph represented as a Markov kernel.</span>
<span class="sd">        </span>
<span class="sd">            - ``&quot;FinalTransitionProbabilities&quot;`` : np.ndarray  </span>
<span class="sd">              Absorption probabilities from each state into each steady state.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If the iterative solver does not converge within ``max_iterations``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">left_side_of_truth_table</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_left_side_of_truth_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stochastic_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stochastic_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">stochastic_weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stochastic_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stochastic_weights must have length N.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">stochastic_weights</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stochastic_weights must be strictly positive.&quot;</span><span class="p">)</span>
            <span class="n">stochastic_weights</span> <span class="o">=</span> <span class="n">stochastic_weights</span> <span class="o">/</span> <span class="n">stochastic_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stochastic_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
            
        <span class="n">steady_states</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">steady_state_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">STG</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]))</span>
        <span class="n">sped_up_STG</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),[[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]))</span>
        <span class="k">for</span> <span class="n">xdec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">left_side_of_truth_table</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1">#important: must create a copy here!</span>
            <span class="n">to_be_distributed</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="n">fx_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_single_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="k">if</span> <span class="n">fx_i</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">fxdec</span> <span class="o">=</span> <span class="n">xdec</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">fx_i</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">fxdec</span> <span class="o">=</span> <span class="n">xdec</span> <span class="o">-</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fxdec</span> <span class="o">=</span> <span class="n">xdec</span>
                <span class="k">if</span> <span class="n">fxdec</span> <span class="ow">in</span> <span class="n">STG</span><span class="p">[</span><span class="n">xdec</span><span class="p">]:</span>
                    <span class="n">STG</span><span class="p">[</span><span class="n">xdec</span><span class="p">][</span><span class="n">fxdec</span><span class="p">]</span> <span class="o">+=</span> <span class="n">stochastic_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">STG</span><span class="p">[</span><span class="n">xdec</span><span class="p">][</span><span class="n">fxdec</span><span class="p">]</span> <span class="o">=</span> <span class="n">stochastic_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">fxdec</span><span class="o">!=</span><span class="n">xdec</span><span class="p">:</span>
                    <span class="n">sped_up_STG</span><span class="p">[</span><span class="n">xdec</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sped_up_STG</span><span class="p">[</span><span class="n">xdec</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">fxdec</span><span class="p">)</span>
                    <span class="n">sped_up_STG</span><span class="p">[</span><span class="n">xdec</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sped_up_STG</span><span class="p">[</span><span class="n">xdec</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">stochastic_weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">to_be_distributed</span> <span class="o">+=</span> <span class="n">stochastic_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">to_be_distributed</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sped_up_STG</span><span class="p">[</span><span class="n">xdec</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">to_be_distributed</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">STG</span><span class="p">[</span><span class="n">xdec</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">steady_state_dict</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">steady_states</span><span class="p">)</span>
                <span class="n">steady_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xdec</span><span class="p">)</span>
                <span class="n">sped_up_STG</span><span class="p">[</span><span class="n">xdec</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sped_up_STG</span><span class="p">[</span><span class="n">xdec</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">xdec</span><span class="p">)</span>
                <span class="n">sped_up_STG</span><span class="p">[</span><span class="n">xdec</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sped_up_STG</span><span class="p">[</span><span class="n">xdec</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                
        <span class="c1"># Probability vectors for all states</span>
        <span class="n">final_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">steady_states</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    
        <span class="c1"># Boundary conditions: absorbing states have probability 1 of themselves</span>
        <span class="k">for</span> <span class="n">xdec</span> <span class="ow">in</span> <span class="n">steady_states</span><span class="p">:</span>
            <span class="n">final_probabilities</span><span class="p">[</span><span class="n">xdec</span><span class="p">,</span> <span class="n">steady_state_dict</span><span class="p">[</span><span class="n">xdec</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">transient_states</span> <span class="o">=</span> <span class="p">[</span><span class="n">xdec</span> <span class="k">for</span> <span class="n">xdec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="k">if</span> <span class="n">xdec</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">steady_state_dict</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_iterations</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">max_delta</span> <span class="o">=</span> <span class="mf">0.0</span>
    
            <span class="c1"># In-place Gauss–Seidel  update:</span>
            <span class="k">for</span> <span class="n">xdec</span> <span class="ow">in</span> <span class="n">transient_states</span><span class="p">:</span>
                <span class="n">nxt</span><span class="p">,</span> <span class="n">pr</span> <span class="o">=</span> <span class="n">sped_up_STG</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span>

                <span class="n">old</span> <span class="o">=</span> <span class="n">final_probabilities</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">final_probabilities</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">final_probabilities</span><span class="p">[</span><span class="n">nxt</span><span class="p">,</span> <span class="p">:])</span>   <span class="c1"># weighted average of successor probability vectors</span>
    
                <span class="c1"># track convergence (infinity norm per row)</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">final_probabilities</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span> <span class="o">-</span> <span class="n">old</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="n">max_delta</span><span class="p">:</span>
                    <span class="n">max_delta</span> <span class="o">=</span> <span class="n">delta</span>
    
            <span class="k">if</span> <span class="n">max_delta</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">basin_sizes</span> <span class="o">=</span> <span class="n">final_probabilities</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span>
                
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s2">&quot;SteadyStates&quot;</span><span class="p">:</span> <span class="n">steady_states</span><span class="p">,</span>
                    <span class="s2">&quot;NumberOfSteadyStates&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">steady_states</span><span class="p">),</span>
                    <span class="s2">&quot;BasinSizes&quot;</span><span class="p">:</span> <span class="n">basin_sizes</span><span class="p">,</span>
                    <span class="s2">&quot;STGAsynchronous&quot;</span><span class="p">:</span> <span class="n">STG</span><span class="p">,</span>
                    <span class="s2">&quot;FinalTransitionProbabilities&quot;</span><span class="p">:</span> <span class="n">final_probabilities</span><span class="p">,</span>
                <span class="p">}</span>
            
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Did not converge in </span><span class="si">{</span><span class="n">max_iterations</span><span class="si">}</span><span class="s2"> iterations; last max_delta=</span><span class="si">{</span><span class="n">max_delta</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

        

<div class="viewcode-block" id="BooleanNetwork.get_steady_states_asynchronous">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.get_steady_states_asynchronous">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_steady_states_asynchronous</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nsim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
        <span class="n">initial_states</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">search_depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
        <span class="n">DEBUG</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Approximate steady states of a Boolean network under asynchronous updates.</span>
<span class="sd">    </span>
<span class="sd">        This method performs a Monte Carlo–style exploration of the asynchronous</span>
<span class="sd">        state space by simulating asynchronous updates from a collection of initial</span>
<span class="sd">        states. Each simulation proceeds until a steady state is reached or until</span>
<span class="sd">        a maximum search depth is exceeded.</span>
<span class="sd">    </span>
<span class="sd">        Unlike ``get_steady_states_asynchronous_exact``, this method does *not*</span>
<span class="sd">        exhaustively explore the full state space and does not guarantee that all</span>
<span class="sd">        steady states will be found. It is intended for large networks where exact</span>
<span class="sd">        enumeration is infeasible.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsim : int, optional</span>
<span class="sd">            Number of asynchronous simulations to perform (default is 500).</span>
<span class="sd">        initial_states : sequence of int or None, optional</span>
<span class="sd">            Initial states to use for the simulations, given as decimal</span>
<span class="sd">            representations of network states. If None (default), ``nsim``</span>
<span class="sd">            random initial states are generated.</span>
<span class="sd">        search_depth : int, optional</span>
<span class="sd">            Maximum number of asynchronous update steps per simulation before</span>
<span class="sd">            giving up on convergence (default is 50).</span>
<span class="sd">        DEBUG : bool, optional</span>
<span class="sd">            If True, print detailed debugging information during simulation.</span>
<span class="sd">        rng : optional</span>
<span class="sd">            Random number generator or seed, passed to ``utils._coerce_rng``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary with the following entries:</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;SteadyStates&quot;`` : list of int  </span>
<span class="sd">              Decimal representations of steady states encountered.</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;NumberOfSteadyStates&quot;`` : int  </span>
<span class="sd">              Number of unique steady states found.</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;BasinSizes&quot;`` : list of int  </span>
<span class="sd">              Counts of how many simulations converged to each steady state.</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;STGAsynchronous&quot;`` : dict  </span>
<span class="sd">              Partial cache of asynchronous transitions encountered during</span>
<span class="sd">              simulation. Keys are ``(state, node_index)`` and values are</span>
<span class="sd">              successor states (all in decimal form).</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;InitialSamplePoints&quot;`` : list of int  </span>
<span class="sd">              Decimal initial states used in the simulations (either provided</span>
<span class="sd">              explicitly or generated randomly).</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method detects only *steady states* (fixed points). If the</span>
<span class="sd">          asynchronous dynamics contain limit cycles, simulations may fail</span>
<span class="sd">          to converge within ``search_depth``.</span>
<span class="sd">        - The returned asynchronous transition graph is generally incomplete</span>
<span class="sd">          and should be interpreted as a cache of explored transitions rather</span>
<span class="sd">          than the full STG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_coerce_rng</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
    
        <span class="n">sampled_states</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">STG_asynchronous</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    
        <span class="n">steady_states</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">basin_sizes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">steady_state_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    
        <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsim</span><span class="p">):</span>
            <span class="c1"># Initialize state</span>
            <span class="k">if</span> <span class="n">initial_states</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
                <span class="n">xdec</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">sampled_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xdec</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xdec</span> <span class="o">=</span> <span class="n">initial_states</span><span class="p">[</span><span class="n">iteration</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">xdec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
    
            <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">iteration</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">xdec</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    
            <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">search_depth</span><span class="p">):</span>
                <span class="n">FOUND_NEW_STATE</span> <span class="o">=</span> <span class="kc">False</span>
    
                <span class="c1"># Check if state is already known to be steady</span>
                <span class="k">if</span> <span class="n">xdec</span> <span class="ow">in</span> <span class="n">steady_state_dict</span><span class="p">:</span>
                    <span class="n">basin_sizes</span><span class="p">[</span><span class="n">steady_state_dict</span><span class="p">[</span><span class="n">xdec</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">break</span>
    
                <span class="n">update_order</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">update_order</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">fxdec</span> <span class="o">=</span> <span class="n">STG_asynchronous</span><span class="p">[(</span><span class="n">xdec</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">fx_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_single_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                        <span class="k">if</span> <span class="n">fx_i</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="n">fxdec</span> <span class="o">=</span> <span class="n">xdec</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
                            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">FOUND_NEW_STATE</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">elif</span> <span class="n">fx_i</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="n">fxdec</span> <span class="o">=</span> <span class="n">xdec</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
                            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">FOUND_NEW_STATE</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">fxdec</span> <span class="o">=</span> <span class="n">xdec</span>
                        <span class="n">STG_asynchronous</span><span class="p">[(</span><span class="n">xdec</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fxdec</span>
    
                    <span class="k">if</span> <span class="n">fxdec</span> <span class="o">!=</span> <span class="n">xdec</span><span class="p">:</span>
                        <span class="n">xdec</span> <span class="o">=</span> <span class="n">fxdec</span>
                        <span class="n">FOUND_NEW_STATE</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
    
                <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">iteration</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">FOUND_NEW_STATE</span><span class="p">,</span> <span class="n">xdec</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    
                <span class="k">if</span> <span class="ow">not</span> <span class="n">FOUND_NEW_STATE</span><span class="p">:</span>
                    <span class="c1"># New steady state found</span>
                    <span class="k">if</span> <span class="n">xdec</span> <span class="ow">in</span> <span class="n">steady_state_dict</span><span class="p">:</span>
                        <span class="n">basin_sizes</span><span class="p">[</span><span class="n">steady_state_dict</span><span class="p">[</span><span class="n">xdec</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">steady_state_dict</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">steady_states</span><span class="p">)</span>
                        <span class="n">steady_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xdec</span><span class="p">)</span>
                        <span class="n">basin_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">break</span>
    
            <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">()</span>
    
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">basin_sizes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nsim</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Warning: only </span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="n">basin_sizes</span><span class="p">)</span><span class="si">}</span><span class="s2"> of the </span><span class="si">{</span><span class="n">nsim</span><span class="si">}</span><span class="s2"> simulations &quot;</span>
                <span class="s2">&quot;reached a steady state. Consider increasing search_depth. &quot;</span>
                <span class="s2">&quot;The network may also contain asynchronous limit cycles.&quot;</span>
            <span class="p">)</span>
    
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;SteadyStates&quot;</span><span class="p">:</span> <span class="n">steady_states</span><span class="p">,</span>
            <span class="s2">&quot;NumberOfSteadyStates&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">steady_states</span><span class="p">),</span>
            <span class="s2">&quot;BasinSizes&quot;</span><span class="p">:</span> <span class="n">basin_sizes</span><span class="p">,</span>
            <span class="s2">&quot;STGAsynchronous&quot;</span><span class="p">:</span> <span class="n">STG_asynchronous</span><span class="p">,</span>
            <span class="s2">&quot;InitialSamplePoints&quot;</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">initial_states</span> <span class="k">if</span> <span class="n">initial_states</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sampled_states</span>
            <span class="p">),</span>
        <span class="p">}</span></div>



<div class="viewcode-block" id="BooleanNetwork.get_steady_states_asynchronous_given_one_initial_condition">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.get_steady_states_asynchronous_given_one_initial_condition">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_steady_states_asynchronous_given_one_initial_condition</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">initial_condition</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">nsim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
        <span class="n">stochastic_weights</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">search_depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
        <span class="n">DEBUG</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Approximate steady states reachable from a single initial condition under</span>
<span class="sd">        asynchronous updates.</span>
<span class="sd">    </span>
<span class="sd">        This method performs multiple asynchronous simulations starting from the</span>
<span class="sd">        same initial condition. In each simulation, nodes are updated one at a time</span>
<span class="sd">        according to either a uniform random order or node-specific stochastic</span>
<span class="sd">        update propensities. The simulation proceeds until a steady state is reached</span>
<span class="sd">        or a maximum number of update steps is exceeded.</span>
<span class="sd">    </span>
<span class="sd">        The method is sampling-based and does *not* guarantee that all reachable</span>
<span class="sd">        steady states are found. It is intended for exploratory analysis and for</span>
<span class="sd">        networks where exhaustive asynchronous analysis is infeasible.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        initial_condition : int or sequence of int, optional</span>
<span class="sd">            Initial network state. If an integer is provided, it is interpreted as</span>
<span class="sd">            the decimal encoding of a Boolean state. If a sequence is provided, it</span>
<span class="sd">            must be a binary vector of length ``N``. Default is 0.</span>
<span class="sd">        nsim : int, optional</span>
<span class="sd">            Number of asynchronous simulation runs (default is 500).</span>
<span class="sd">        stochastic_weights : sequence of float or None, optional</span>
<span class="sd">            Relative update propensities for each node. If provided, must have</span>
<span class="sd">            length ``N`` and be strictly positive. The weights are normalized</span>
<span class="sd">            internally. If None (default), nodes are updated uniformly at random.</span>
<span class="sd">        search_depth : int, optional</span>
<span class="sd">            Maximum number of asynchronous update steps per simulation.</span>
<span class="sd">        DEBUG : bool, optional</span>
<span class="sd">            If True, print detailed debugging information during simulation.</span>
<span class="sd">        rng : optional</span>
<span class="sd">            Random number generator or seed, passed to ``utils._coerce_rng``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary with the following entries:</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;SteadyStates&quot;`` : list of int  </span>
<span class="sd">              Decimal representations of steady states reached.</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;NumberOfSteadyStates&quot;`` : int  </span>
<span class="sd">              Number of unique steady states found.</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;BasinSizes&quot;`` : list of int  </span>
<span class="sd">              Number of simulations converging to each steady state.</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;TransientTimes&quot;`` : list of list of int  </span>
<span class="sd">              For each steady state, a list of transient lengths (number of update</span>
<span class="sd">              steps before convergence).</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;STGAsynchronous&quot;`` : dict  </span>
<span class="sd">              Partial cache of asynchronous transitions encountered during</span>
<span class="sd">              simulation. Keys are ``(state, node_index)`` and values are successor</span>
<span class="sd">              states (all in decimal form).</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;UpdateQueues&quot;`` : list of list of int  </span>
<span class="sd">              For each simulation, the sequence of visited states (in decimal form).</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Only steady states (fixed points) are detected. If the asynchronous</span>
<span class="sd">          dynamics contain limit cycles, simulations may fail to converge within</span>
<span class="sd">          ``search_depth``.</span>
<span class="sd">        - The returned asynchronous transition graph is incomplete and represents</span>
<span class="sd">          only transitions encountered during sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_coerce_rng</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
    
        <span class="c1"># --- Initialize initial condition ---</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial_condition</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">initial_condition</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
            <span class="n">x0dec</span> <span class="o">=</span> <span class="n">initial_condition</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">initial_condition</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Initial condition must have length </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="n">x0dec</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    
        <span class="c1"># --- Handle stochastic weights ---</span>
        <span class="k">if</span> <span class="n">stochastic_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stochastic_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">stochastic_weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stochastic_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stochastic_weights must have length N.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">stochastic_weights</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stochastic_weights must be strictly positive.&quot;</span><span class="p">)</span>
            <span class="n">stochastic_weights</span> <span class="o">=</span> <span class="n">stochastic_weights</span> <span class="o">/</span> <span class="n">stochastic_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    
        <span class="c1"># --- Bookkeeping ---</span>
        <span class="n">STG_async</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">steady_states</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">basin_sizes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">transient_times</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">steady_state_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">queues</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    
        <span class="c1"># --- Simulations ---</span>
        <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsim</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">xdec</span> <span class="o">=</span> <span class="n">x0dec</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">xdec</span><span class="p">]</span>
    
            <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">search_depth</span><span class="p">):</span>
                <span class="n">FOUND_NEW_STATE</span> <span class="o">=</span> <span class="kc">False</span>
    
                <span class="c1"># If already known steady state, stop</span>
                <span class="k">if</span> <span class="n">xdec</span> <span class="ow">in</span> <span class="n">steady_state_dict</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">steady_state_dict</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span>
                    <span class="n">basin_sizes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">transient_times</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
                    <span class="n">queues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
                    <span class="k">break</span>
    
                <span class="c1"># Choose update order</span>
                <span class="k">if</span> <span class="n">stochastic_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">update_order</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">update_order</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">stochastic_weights</span>
                    <span class="p">)</span>
    
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">update_order</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">fxdec</span> <span class="o">=</span> <span class="n">STG_async</span><span class="p">[(</span><span class="n">xdec</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">fx_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_single_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                        <span class="k">if</span> <span class="n">fx_i</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="n">fxdec</span> <span class="o">=</span> <span class="n">xdec</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
                            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">elif</span> <span class="n">fx_i</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="n">fxdec</span> <span class="o">=</span> <span class="n">xdec</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
                            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">fxdec</span> <span class="o">=</span> <span class="n">xdec</span>
                        <span class="n">STG_async</span><span class="p">[(</span><span class="n">xdec</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fxdec</span>
    
                    <span class="k">if</span> <span class="n">fxdec</span> <span class="o">!=</span> <span class="n">xdec</span><span class="p">:</span>
                        <span class="n">xdec</span> <span class="o">=</span> <span class="n">fxdec</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xdec</span><span class="p">)</span>
                        <span class="n">FOUND_NEW_STATE</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
    
                <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">iteration</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">FOUND_NEW_STATE</span><span class="p">,</span> <span class="n">xdec</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    
                <span class="k">if</span> <span class="ow">not</span> <span class="n">FOUND_NEW_STATE</span><span class="p">:</span>
                    <span class="c1"># New steady state reached</span>
                    <span class="k">if</span> <span class="n">xdec</span> <span class="ow">in</span> <span class="n">steady_state_dict</span><span class="p">:</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="n">steady_state_dict</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span>
                        <span class="n">basin_sizes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">transient_times</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">steady_state_dict</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">steady_states</span><span class="p">)</span>
                        <span class="n">steady_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xdec</span><span class="p">)</span>
                        <span class="n">basin_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">transient_times</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">step</span><span class="p">])</span>
                    <span class="n">queues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
                    <span class="k">break</span>
    
            <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">()</span>
    
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">basin_sizes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nsim</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Warning: only </span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="n">basin_sizes</span><span class="p">)</span><span class="si">}</span><span class="s2"> of the </span><span class="si">{</span><span class="n">nsim</span><span class="si">}</span><span class="s2"> simulations &quot;</span>
                <span class="s2">&quot;reached a steady state. Consider increasing search_depth. &quot;</span>
                <span class="s2">&quot;The network may contain asynchronous limit cycles.&quot;</span>
            <span class="p">)</span>
    
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;SteadyStates&quot;</span><span class="p">:</span> <span class="n">steady_states</span><span class="p">,</span>
            <span class="s2">&quot;NumberOfSteadyStates&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">steady_states</span><span class="p">),</span>
            <span class="s2">&quot;BasinSizes&quot;</span><span class="p">:</span> <span class="n">basin_sizes</span><span class="p">,</span>
            <span class="s2">&quot;TransientTimes&quot;</span><span class="p">:</span> <span class="n">transient_times</span><span class="p">,</span>
            <span class="s2">&quot;STGAsynchronous&quot;</span><span class="p">:</span> <span class="n">STG_async</span><span class="p">,</span>
            <span class="s2">&quot;UpdateQueues&quot;</span><span class="p">:</span> <span class="n">queues</span><span class="p">,</span>
        <span class="p">}</span></div>



<div class="viewcode-block" id="BooleanNetwork.get_attractors_synchronous">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_attractors_synchronous</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nsim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
        <span class="n">initial_sample_points</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_steps_timeout</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">INITIAL_SAMPLE_POINTS_AS_BINARY_VECTORS</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">USE_NUMBA</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Approximate synchronous attractors of a Boolean network via sampling.</span>
<span class="sd">    </span>
<span class="sd">        This method estimates the synchronous attractors (fixed points and cycles)</span>
<span class="sd">        of a Boolean network by simulating synchronous updates from a collection</span>
<span class="sd">        of initial states. For each simulation, the network is updated until an</span>
<span class="sd">        attractor is reached or a maximum number of update steps is exceeded.</span>
<span class="sd">    </span>
<span class="sd">        The method is sampling-based and does *not* guarantee that all attractors</span>
<span class="sd">        are found. Basin sizes are lower-bound estimates based on the sampled</span>
<span class="sd">        initial conditions.</span>
<span class="sd">    </span>
<span class="sd">        If Numba is available and ``USE_NUMBA=True``, synchronous updates are</span>
<span class="sd">        accelerated using a compiled kernel.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsim : int, optional</span>
<span class="sd">            Number of initial conditions to simulate (default is 500). Ignored if</span>
<span class="sd">            ``initial_sample_points`` is provided.</span>
<span class="sd">        initial_sample_points : sequence of int or sequence of sequence of int, optional</span>
<span class="sd">            Initial states to use. If provided, its length determines the number</span>
<span class="sd">            of simulations. Interpretation depends on</span>
<span class="sd">            ``INITIAL_SAMPLE_POINTS_AS_BINARY_VECTORS``.</span>
<span class="sd">        n_steps_timeout : int, optional</span>
<span class="sd">            Maximum number of synchronous update steps per simulation before</span>
<span class="sd">            declaring a timeout (default is 1000).</span>
<span class="sd">        INITIAL_SAMPLE_POINTS_AS_BINARY_VECTORS : bool, optional</span>
<span class="sd">            If True, ``initial_sample_points`` are interpreted as binary vectors;</span>
<span class="sd">            otherwise they are interpreted as decimal-encoded states.</span>
<span class="sd">        USE_NUMBA : bool, optional</span>
<span class="sd">            If True (default) and Numba is available, use a Numba-accelerated</span>
<span class="sd">            synchronous update kernel.</span>
<span class="sd">        rng : optional</span>
<span class="sd">            Random number generator or seed, passed to ``utils._coerce_rng``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary with the following entries:</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;Attractors&quot;`` : list of list of int  </span>
<span class="sd">              Attractors found, each represented as a list of decimal states</span>
<span class="sd">              (cycles are given in cyclic order).</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;NumberOfAttractors&quot;`` : int  </span>
<span class="sd">              Number of distinct attractors found.</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;BasinSizes&quot;`` : list of int  </span>
<span class="sd">              Number of sampled initial conditions converging to each attractor.</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;AttractorDict&quot;`` : dict  </span>
<span class="sd">              Mapping from visited states (decimal) to attractor index.</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;InitialSamplePoints&quot;`` : list of int  </span>
<span class="sd">              Decimal initial states used for sampling.</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;STG&quot;`` : dict  </span>
<span class="sd">              Sampled synchronous state transition graph</span>
<span class="sd">              (state → successor state).</span>
<span class="sd">    </span>
<span class="sd">            - ``&quot;NumberOfTimeouts&quot;`` : int  </span>
<span class="sd">              Number of simulations that did not converge within</span>
<span class="sd">              ``n_steps_timeout``.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method is intended for networks with long transient dynamics, where</span>
<span class="sd">          exhaustive synchronous analysis is infeasible.</span>
<span class="sd">        - Basin sizes are *sampling-based estimates* and should not be interpreted</span>
<span class="sd">          as exact proportions of the state space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_coerce_rng</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
    
        <span class="c1"># --- Bookkeeping ---</span>
        <span class="n">dictF</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>        <span class="c1"># memorized synchronous transitions</span>
        <span class="n">attractors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># attractor cycles</span>
        <span class="n">basin_sizes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>       <span class="c1"># basin counts</span>
        <span class="n">attr_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>    <span class="c1"># state -&gt; attractor index</span>
        <span class="n">STG</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>           <span class="c1"># sampled synchronous STG</span>
        <span class="n">n_timeout</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sampled_points</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    
        <span class="n">INITIAL_SAMPLE_POINTS_EMPTY</span> <span class="o">=</span> <span class="n">initial_sample_points</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">INITIAL_SAMPLE_POINTS_EMPTY</span><span class="p">:</span>
            <span class="n">nsim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_sample_points</span><span class="p">)</span>
    
        <span class="c1"># --- Decide update backend ---</span>
        <span class="n">use_numba</span> <span class="o">=</span> <span class="n">__LOADED_NUMBA__</span> <span class="ow">and</span> <span class="n">USE_NUMBA</span>
    
        <span class="k">if</span> <span class="n">use_numba</span><span class="p">:</span>
            <span class="n">F_array_list</span> <span class="o">=</span> <span class="n">List</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bf</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="k">for</span> <span class="n">bf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">])</span>
            <span class="n">I_array_list</span> <span class="o">=</span> <span class="n">List</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="k">for</span> <span class="n">regs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">])</span>
    
        <span class="c1"># --- Main simulation loop ---</span>
        <span class="k">for</span> <span class="n">sim_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsim</span><span class="p">):</span>
            <span class="c1"># Initialize state</span>
            <span class="k">if</span> <span class="n">INITIAL_SAMPLE_POINTS_EMPTY</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                <span class="n">xdec</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">sampled_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xdec</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">INITIAL_SAMPLE_POINTS_AS_BINARY_VECTORS</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">initial_sample_points</span><span class="p">[</span><span class="n">sim_idx</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Initial state must have length </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
                        <span class="p">)</span>
                    <span class="n">xdec</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xdec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">initial_sample_points</span><span class="p">[</span><span class="n">sim_idx</span><span class="p">])</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">xdec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    
            <span class="n">visited</span> <span class="o">=</span> <span class="p">{</span><span class="n">xdec</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
            <span class="n">trajectory</span> <span class="o">=</span> <span class="p">[</span><span class="n">xdec</span><span class="p">]</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    
            <span class="c1"># --- Iterate until attractor or timeout ---</span>
            <span class="k">while</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">n_steps_timeout</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">xdec</span> <span class="ow">in</span> <span class="n">dictF</span><span class="p">:</span>
                    <span class="n">fxdec</span> <span class="o">=</span> <span class="n">dictF</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">use_numba</span><span class="p">:</span>
                        <span class="n">fx</span> <span class="o">=</span> <span class="n">_update_network_synchronously_numba</span><span class="p">(</span>
                            <span class="n">x</span><span class="p">,</span> <span class="n">F_array_list</span><span class="p">,</span> <span class="n">I_array_list</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_network_synchronously_unchecked</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    
                    <span class="n">fxdec</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">fx</span><span class="p">)</span>
                    <span class="n">dictF</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span> <span class="o">=</span> <span class="n">fxdec</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">fx</span>
    
                <span class="c1"># record sampled STG edge (first visit only)</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">STG</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span> <span class="o">=</span> <span class="n">fxdec</span>
    
                <span class="c1"># already assigned to known attractor</span>
                <span class="k">if</span> <span class="n">fxdec</span> <span class="ow">in</span> <span class="n">attr_dict</span><span class="p">:</span>
                    <span class="n">idx_attr</span> <span class="o">=</span> <span class="n">attr_dict</span><span class="p">[</span><span class="n">fxdec</span><span class="p">]</span>
                    <span class="n">basin_sizes</span><span class="p">[</span><span class="n">idx_attr</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="p">:</span>
                        <span class="n">attr_dict</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_attr</span>
                    <span class="k">break</span>
    
                <span class="c1"># new attractor detected</span>
                <span class="k">if</span> <span class="n">fxdec</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">cycle_start</span> <span class="o">=</span> <span class="n">visited</span><span class="p">[</span><span class="n">fxdec</span><span class="p">]</span>
                    <span class="n">attractor_states</span> <span class="o">=</span> <span class="n">trajectory</span><span class="p">[</span><span class="n">cycle_start</span><span class="p">:]</span>
                    <span class="n">attractors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attractor_states</span><span class="p">)</span>
                    <span class="n">basin_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">idx_attr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">attractors</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">attractor_states</span><span class="p">:</span>
                        <span class="n">attr_dict</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_attr</span>
                    <span class="k">break</span>
    
                <span class="c1"># continue traversal</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">fxdec</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>
                <span class="n">trajectory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fxdec</span><span class="p">)</span>
                <span class="n">xdec</span> <span class="o">=</span> <span class="n">fxdec</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    
                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">n_steps_timeout</span><span class="p">:</span>
                    <span class="n">n_timeout</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">break</span>
    
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;Attractors&quot;</span><span class="p">:</span> <span class="n">attractors</span><span class="p">,</span>
            <span class="s2">&quot;NumberOfAttractors&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">attractors</span><span class="p">),</span>
            <span class="s2">&quot;BasinSizes&quot;</span><span class="p">:</span> <span class="n">basin_sizes</span><span class="p">,</span>
            <span class="s2">&quot;AttractorDict&quot;</span><span class="p">:</span> <span class="n">attr_dict</span><span class="p">,</span>
            <span class="s2">&quot;InitialSamplePoints&quot;</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">sampled_points</span> <span class="k">if</span> <span class="n">INITIAL_SAMPLE_POINTS_EMPTY</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">initial_sample_points</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="s2">&quot;STG&quot;</span><span class="p">:</span> <span class="n">STG</span><span class="p">,</span>
            <span class="s2">&quot;NumberOfTimeouts&quot;</span><span class="p">:</span> <span class="n">n_timeout</span><span class="p">,</span>
        <span class="p">}</span></div>



    
<div class="viewcode-block" id="BooleanNetwork.compute_synchronous_state_transition_graph">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.compute_synchronous_state_transition_graph">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_synchronous_state_transition_graph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">USE_NUMBA</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the exact synchronous state transition graph (STG).</span>
<span class="sd">    </span>
<span class="sd">        The STG is stored in ``self.STG`` as a one-dimensional NumPy array of length</span>
<span class="sd">        ``2**N``, where ``self.STG[x]`` is the decimal representation of the successor</span>
<span class="sd">        state reached from state ``x`` under synchronous updating.</span>
<span class="sd">    </span>
<span class="sd">        This computation is exact and requires memory proportional to ``2**N``.</span>
<span class="sd">        It is therefore intended for small-to-moderate networks only.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        USE_NUMBA : bool, optional</span>
<span class="sd">            If True (default) and Numba is available, use a compiled kernel to</span>
<span class="sd">            accelerate computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Optional: avoid recomputation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">STG</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
    
        <span class="k">if</span> <span class="n">__LOADED_NUMBA__</span> <span class="ow">and</span> <span class="n">USE_NUMBA</span><span class="p">:</span>
            <span class="c1"># Preprocess data into Numba-friendly types</span>
            <span class="n">F_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bf</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="k">for</span> <span class="n">bf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">]</span>
            <span class="n">I_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="k">for</span> <span class="n">regs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">]</span>
    
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">22</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">STG</span> <span class="o">=</span> <span class="n">_compute_synchronous_stg_numba</span><span class="p">(</span><span class="n">F_list</span><span class="p">,</span> <span class="n">I_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">STG</span> <span class="o">=</span> <span class="n">_compute_synchronous_stg_numba_low_memory</span><span class="p">(</span>
                    <span class="n">F_list</span><span class="p">,</span> <span class="n">I_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
                <span class="p">)</span>
            <span class="k">return</span>
    
        <span class="c1"># -------- Pure NumPy implementation --------</span>
    
        <span class="c1"># 1. Enumerate all states (binary)</span>
        <span class="n">states</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_left_side_of_truth_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
    
        <span class="c1"># 2. Allocate next-state matrix</span>
        <span class="n">next_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    
        <span class="c1"># Binary-to-decimal weights</span>
        <span class="n">powers_of_two</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
        <span class="c1"># 3. Compute next state for each node</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">bf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">):</span>
            <span class="n">regulators</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">regulators</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Constant node</span>
                <span class="n">next_states</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">continue</span>
    
            <span class="n">subspace</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,</span> <span class="n">regulators</span><span class="p">]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">subspace</span><span class="p">,</span> <span class="n">powers_of_two</span><span class="p">[</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">regulators</span><span class="p">):])</span>
            <span class="n">next_states</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    
        <span class="c1"># 4. Convert next states to decimal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">STG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">next_states</span><span class="p">,</span> <span class="n">powers_of_two</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span></div>



<div class="viewcode-block" id="BooleanNetwork.get_attractors_synchronous_exact">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous_exact">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_attractors_synchronous_exact</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">USE_NUMBA</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute all attractors and their exact basin sizes under synchronous updating.</span>
<span class="sd">    </span>
<span class="sd">        This method computes the exact synchronous state transition graph (STG) and</span>
<span class="sd">        analyzes it as a functional graph on ``2**N`` states. All attractors (cycles),</span>
<span class="sd">        their basin sizes, and the attractor reached from each state are determined</span>
<span class="sd">        exactly.</span>
<span class="sd">    </span>
<span class="sd">        This computation requires memory and time proportional to ``2**N`` and is</span>
<span class="sd">        intended for small-to-moderate networks only.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        USE_NUMBA : bool, optional</span>
<span class="sd">            If True (default) and Numba is available, use a compiled kernel for</span>
<span class="sd">            attractor detection.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary with keys:</span>
<span class="sd">    </span>
<span class="sd">            - Attractors : list[list[int]]</span>
<span class="sd">                Each attractor represented as a list of decimal states forming a cycle.</span>
<span class="sd">            - NumberOfAttractors : int</span>
<span class="sd">                Total number of attractors.</span>
<span class="sd">            - BasinSizes : np.ndarray[float]</span>
<span class="sd">                Fraction of all states belonging to each attractor basin.</span>
<span class="sd">            - AttractorID : np.ndarray[int]</span>
<span class="sd">                For each of the ``2**N`` states, the index of the attractor it reaches.</span>
<span class="sd">            - STG : np.ndarray[int]</span>
<span class="sd">                The synchronous state transition graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">STG</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_synchronous_state_transition_graph</span><span class="p">(</span><span class="n">USE_NUMBA</span><span class="o">=</span><span class="n">USE_NUMBA</span><span class="p">)</span>
    
        <span class="n">attractors</span> <span class="o">=</span> <span class="p">[]</span>
    
        <span class="k">if</span> <span class="n">__LOADED_NUMBA__</span> <span class="ow">and</span> <span class="n">USE_NUMBA</span><span class="p">:</span>
            <span class="n">attractor_id</span><span class="p">,</span> <span class="n">basin_sizes</span><span class="p">,</span> <span class="n">cycle_rep</span><span class="p">,</span> <span class="n">cycle_len</span><span class="p">,</span> <span class="n">n_attr</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">_attractors_functional_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">STG</span><span class="p">)</span>
            <span class="p">)</span>
    
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_attr</span><span class="p">)):</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cycle_rep</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">L</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cycle_len</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">cyc</span> <span class="o">=</span> <span class="p">[</span><span class="n">rep</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">rep</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">STG</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
                    <span class="n">cyc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">attractors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cyc</span><span class="p">)</span>
    
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attractor_id</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">basin_sizes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">n_attr</span> <span class="o">=</span> <span class="mi">0</span>
    
            <span class="k">for</span> <span class="n">xdec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">attractor_id</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
    
                <span class="n">cur</span> <span class="o">=</span> <span class="n">xdec</span>
                <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">cur</span><span class="p">]</span>
    
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">fxdec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">STG</span><span class="p">[</span><span class="n">cur</span><span class="p">])</span>
    
                    <span class="k">if</span> <span class="n">attractor_id</span><span class="p">[</span><span class="n">fxdec</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">idx_attr</span> <span class="o">=</span> <span class="n">attractor_id</span><span class="p">[</span><span class="n">fxdec</span><span class="p">]</span>
                        <span class="n">basin_sizes</span><span class="p">[</span><span class="n">idx_attr</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
                            <span class="n">attractor_id</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_attr</span>
                        <span class="k">break</span>
    
                    <span class="k">if</span> <span class="n">fxdec</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">fxdec</span><span class="p">)</span>
                        <span class="n">cycle</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="n">idx</span><span class="p">:]</span>
                        <span class="n">attractors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
                        <span class="n">basin_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
                            <span class="n">attractor_id</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_attr</span>
                        <span class="n">n_attr</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">break</span>
    
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fxdec</span><span class="p">)</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="n">fxdec</span>
    
        <span class="n">basin_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">basin_sizes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;Attractors&quot;</span><span class="p">:</span> <span class="n">attractors</span><span class="p">,</span>
            <span class="s2">&quot;NumberOfAttractors&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">attractors</span><span class="p">),</span>
            <span class="s2">&quot;BasinSizes&quot;</span><span class="p">:</span> <span class="n">basin_sizes</span><span class="p">,</span>
            <span class="s2">&quot;AttractorID&quot;</span><span class="p">:</span> <span class="n">attractor_id</span><span class="p">,</span>
            <span class="s2">&quot;STG&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">STG</span><span class="p">,</span>
        <span class="p">}</span></div>




    <span class="c1">## Robustness measures: synchronous Derrida value, entropy of basin size distribution, coherence, fragility</span>
<div class="viewcode-block" id="BooleanNetwork.get_attractors_and_robustness_measures_synchronous_exact">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.get_attractors_and_robustness_measures_synchronous_exact">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_attractors_and_robustness_measures_synchronous_exact</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">USE_NUMBA</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the attractors and exact robustness measures of a synchronously</span>
<span class="sd">        updated Boolean network.</span>
<span class="sd">    </span>
<span class="sd">        This method computes the exact synchronous state transition graph (STG)</span>
<span class="sd">        and analyzes it as a functional graph on ``2**N`` states. All attractors</span>
<span class="sd">        (cycles), their basin sizes, and the attractor reached from each state</span>
<span class="sd">        are determined exactly. Based on this decomposition, exact coherence</span>
<span class="sd">        and fragility measures are computed for the full network, for each basin</span>
<span class="sd">        of attraction, and for each attractor.</span>
<span class="sd">    </span>
<span class="sd">        This computation requires memory and time proportional to ``2**N`` and is</span>
<span class="sd">        intended for small-to-moderate networks only.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        USE_NUMBA : bool, optional</span>
<span class="sd">            If True (default) and Numba is available, use a compiled kernel for</span>
<span class="sd">            robustness computation.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary with keys:</span>
<span class="sd">    </span>
<span class="sd">            - Attractors : list[list[int]]</span>
<span class="sd">                Each attractor represented as a list of decimal states forming a cycle.</span>
<span class="sd">            - NumberOfAttractors : int</span>
<span class="sd">                Total number of attractors.</span>
<span class="sd">            - BasinSizes : np.ndarray[float]</span>
<span class="sd">                Fraction of all states belonging to each attractor basin.</span>
<span class="sd">            - AttractorID : np.ndarray[int]</span>
<span class="sd">                For each of the ``2**N`` states, the index of the attractor it reaches.</span>
<span class="sd">            - Coherence : float</span>
<span class="sd">                Exact global network coherence.</span>
<span class="sd">            - Fragility : float</span>
<span class="sd">                Exact global network fragility.</span>
<span class="sd">            - BasinCoherence : np.ndarray[float]</span>
<span class="sd">                Exact coherence of each basin of attraction.</span>
<span class="sd">            - BasinFragility : np.ndarray[float]</span>
<span class="sd">                Exact fragility of each basin of attraction.</span>
<span class="sd">            - AttractorCoherence : np.ndarray[float]</span>
<span class="sd">                Exact coherence of each attractor.</span>
<span class="sd">            - AttractorFragility : np.ndarray[float]</span>
<span class="sd">                Exact fragility of each attractor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># 0) Attractors and basins</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attractors_synchronous_exact</span><span class="p">(</span><span class="n">USE_NUMBA</span><span class="o">=</span><span class="n">USE_NUMBA</span><span class="p">)</span>
    
        <span class="n">attractors</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;Attractors&quot;</span><span class="p">]</span>
        <span class="n">n_attractors</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;NumberOfAttractors&quot;</span><span class="p">])</span>
    
        <span class="n">basin_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;BasinSizes&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">attractor_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;AttractorID&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    
        <span class="n">n_states</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># Single-attractor shortcut</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="k">if</span> <span class="n">n_attractors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;Attractors&quot;</span><span class="p">:</span> <span class="n">attractors</span><span class="p">,</span>
                <span class="s2">&quot;NumberOfAttractors&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s2">&quot;BasinSizes&quot;</span><span class="p">:</span> <span class="n">basin_sizes</span><span class="p">,</span>
                <span class="s2">&quot;AttractorID&quot;</span><span class="p">:</span> <span class="n">attractor_id</span><span class="p">,</span>
                <span class="s2">&quot;Coherence&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                <span class="s2">&quot;Fragility&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                <span class="s2">&quot;BasinCoherence&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                <span class="s2">&quot;BasinFragility&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                <span class="s2">&quot;AttractorCoherence&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                <span class="s2">&quot;AttractorFragility&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
            <span class="p">}</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># 1) Attractor membership and lengths</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="n">is_attr_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">len_attractors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_attractors</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">states</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">attractors</span><span class="p">):</span>
            <span class="n">states_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="n">len_attractors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">states_arr</span><span class="o">.</span><span class="n">size</span>
            <span class="n">is_attr_mask</span><span class="p">[</span><span class="n">states_arr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># 2) Mean binary vector per attractor</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="n">mean_states_attractors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_attractors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">states</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">attractors</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mean_states_attractors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                    <span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">states</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
                <span class="p">)</span>
                <span class="n">mean_states_attractors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># 3) Distance matrix between attractors</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">mean_states_attractors</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">mean_states_attractors</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="n">distance_between_attractors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">distance_between_attractors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="n">distance_between_attractors</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="p">)</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># 4) Hypercube edge traversal</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="k">if</span> <span class="n">__LOADED_NUMBA__</span> <span class="ow">and</span> <span class="n">USE_NUMBA</span><span class="p">:</span>
            <span class="p">(</span>
                <span class="n">basin_coherences</span><span class="p">,</span>
                <span class="n">basin_fragilities</span><span class="p">,</span>
                <span class="n">attractor_coherences</span><span class="p">,</span>
                <span class="n">attractor_fragilities</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">_robustness_edge_traversal_numba</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span>
                <span class="n">attractor_id</span><span class="p">,</span>
                <span class="n">is_attr_mask</span><span class="p">,</span>
                <span class="n">distance_between_attractors</span><span class="p">,</span>
            <span class="p">)</span>
    
            <span class="n">basin_coherences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">basin_coherences</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">basin_fragilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">basin_fragilities</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">attractor_coherences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">attractor_coherences</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">attractor_fragilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">attractor_fragilities</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    
        <span class="k">else</span><span class="p">:</span>
            <span class="n">basin_coherences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_attractors</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">basin_fragilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_attractors</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">attractor_coherences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_attractors</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">attractor_fragilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_attractors</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    
            <span class="k">for</span> <span class="n">xdec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bitpos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">xdec</span> <span class="o">&gt;&gt;</span> <span class="n">bitpos</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">continue</span>
    
                    <span class="n">ydec</span> <span class="o">=</span> <span class="n">xdec</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bitpos</span><span class="p">)</span>
    
                    <span class="n">idx_x</span> <span class="o">=</span> <span class="n">attractor_id</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span>
                    <span class="n">idx_y</span> <span class="o">=</span> <span class="n">attractor_id</span><span class="p">[</span><span class="n">ydec</span><span class="p">]</span>
    
                    <span class="k">if</span> <span class="n">idx_x</span> <span class="o">==</span> <span class="n">idx_y</span><span class="p">:</span>
                        <span class="n">basin_coherences</span><span class="p">[</span><span class="n">idx_x</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">2.0</span>
                        <span class="k">if</span> <span class="n">is_attr_mask</span><span class="p">[</span><span class="n">xdec</span><span class="p">]:</span>
                            <span class="n">attractor_coherences</span><span class="p">[</span><span class="n">idx_x</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span>
                        <span class="k">if</span> <span class="n">is_attr_mask</span><span class="p">[</span><span class="n">ydec</span><span class="p">]:</span>
                            <span class="n">attractor_coherences</span><span class="p">[</span><span class="n">idx_y</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dxy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">distance_between_attractors</span><span class="p">[</span><span class="n">idx_x</span><span class="p">,</span> <span class="n">idx_y</span><span class="p">])</span>
                        <span class="n">basin_fragilities</span><span class="p">[</span><span class="n">idx_x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dxy</span>
                        <span class="n">basin_fragilities</span><span class="p">[</span><span class="n">idx_y</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dxy</span>
                        <span class="k">if</span> <span class="n">is_attr_mask</span><span class="p">[</span><span class="n">xdec</span><span class="p">]:</span>
                            <span class="n">attractor_fragilities</span><span class="p">[</span><span class="n">idx_x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dxy</span>
                        <span class="k">if</span> <span class="n">is_attr_mask</span><span class="p">[</span><span class="n">ydec</span><span class="p">]:</span>
                            <span class="n">attractor_fragilities</span><span class="p">[</span><span class="n">idx_y</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dxy</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># 5) Normalization</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="n">basin_counts</span> <span class="o">=</span> <span class="n">basin_sizes</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_attractors</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">basin_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">basin_coherences</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">basin_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
                <span class="n">basin_fragilities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">basin_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
    
            <span class="k">if</span> <span class="n">len_attractors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">attractor_coherences</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">len_attractors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
                <span class="n">attractor_fragilities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">len_attractors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
    
        <span class="n">coherence</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">basin_sizes</span><span class="p">,</span> <span class="n">basin_coherences</span><span class="p">))</span>
        <span class="n">fragility</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">basin_sizes</span><span class="p">,</span> <span class="n">basin_fragilities</span><span class="p">))</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># Final return</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;Attractors&quot;</span><span class="p">:</span> <span class="n">attractors</span><span class="p">,</span>
            <span class="s2">&quot;NumberOfAttractors&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_attractors</span><span class="p">),</span>
            <span class="s2">&quot;BasinSizes&quot;</span><span class="p">:</span> <span class="n">basin_sizes</span><span class="p">,</span>
            <span class="s2">&quot;AttractorID&quot;</span><span class="p">:</span> <span class="n">attractor_id</span><span class="p">,</span>
            <span class="s2">&quot;Coherence&quot;</span><span class="p">:</span> <span class="n">coherence</span><span class="p">,</span>
            <span class="s2">&quot;Fragility&quot;</span><span class="p">:</span> <span class="n">fragility</span><span class="p">,</span>
            <span class="s2">&quot;BasinCoherence&quot;</span><span class="p">:</span> <span class="n">basin_coherences</span><span class="p">,</span>
            <span class="s2">&quot;BasinFragility&quot;</span><span class="p">:</span> <span class="n">basin_fragilities</span><span class="p">,</span>
            <span class="s2">&quot;AttractorCoherence&quot;</span><span class="p">:</span> <span class="n">attractor_coherences</span><span class="p">,</span>
            <span class="s2">&quot;AttractorFragility&quot;</span><span class="p">:</span> <span class="n">attractor_fragilities</span><span class="p">,</span>
        <span class="p">}</span></div>



<div class="viewcode-block" id="BooleanNetwork.get_attractors_and_robustness_measures_synchronous">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.get_attractors_and_robustness_measures_synchronous">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_attractors_and_robustness_measures_synchronous</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">number_different_IC</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
        <span class="n">RETURN_ATTRACTOR_COHERENCE</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Approximate attractors and robustness measures under synchronous updating.</span>
<span class="sd">    </span>
<span class="sd">        This method samples the attractor landscape by simulating the network from</span>
<span class="sd">        multiple random initial conditions (ICs) and their single-bit perturbations.</span>
<span class="sd">        It returns Monte-Carlo approximations of global coherence, fragility, and a</span>
<span class="sd">        final Hamming-distance-based measure, along with per-basin approximations.</span>
<span class="sd">        Optionally, it additionally estimates attractor-level coherence and fragility</span>
<span class="sd">        by perturbing attractor states found during sampling.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The attractor set returned is a *lower bound* on the true number of</span>
<span class="sd">          attractors, because only the sampled portion of state space is explored.</span>
<span class="sd">        - For ``N &gt;= 64``, decimal encoding of states may exceed ``np.int64`` and</span>
<span class="sd">          this method uses bitstrings (type ``str``) as state identifiers.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_different_IC : int, optional</span>
<span class="sd">            Number of random initial conditions to sample (default is 500). For each</span>
<span class="sd">            IC, the method also simulates one randomly chosen single-bit perturbation.</span>
<span class="sd">        RETURN_ATTRACTOR_COHERENCE : bool, optional</span>
<span class="sd">            If True (default), also compute attractor-level coherence and fragility</span>
<span class="sd">            by perturbing attractor states found during sampling.</span>
<span class="sd">        rng : None or numpy.random.Generator, optional</span>
<span class="sd">            Random number generator or seed-like object. Passed to</span>
<span class="sd">            ``utils._coerce_rng``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary with keys:</span>
<span class="sd">    </span>
<span class="sd">            - Attractors : list[list[int]] or list[list[str]]</span>
<span class="sd">                List of discovered attractors, each represented as a list of states</span>
<span class="sd">                forming a cycle. States are decimals (``int``) for ``N &lt; 64`` and</span>
<span class="sd">                bitstrings (``str``) for ``N &gt;= 64``.</span>
<span class="sd">            - LowerBoundOfNumberOfAttractors : int</span>
<span class="sd">                Number of distinct attractors discovered (a lower bound on the true</span>
<span class="sd">                number of attractors).</span>
<span class="sd">            - BasinSizesApproximation : np.ndarray[float]</span>
<span class="sd">                Approximate basin size (fraction of sampled trajectories that end in</span>
<span class="sd">                each attractor). Sums to ~1 over discovered attractors.</span>
<span class="sd">            - CoherenceApproximation : float</span>
<span class="sd">                Approximate global coherence: probability that a random IC and its</span>
<span class="sd">                single-bit perturbation reach the same attractor.</span>
<span class="sd">            - FragilityApproximation : float</span>
<span class="sd">                Approximate global fragility: expected normalized difference between</span>
<span class="sd">                reached attractors when the IC and perturbation reach different</span>
<span class="sd">                attractors. Normalized by ``N``.</span>
<span class="sd">            - FinalHammingDistanceApproximation : float</span>
<span class="sd">                Approximate final Hamming distance between the two periodic</span>
<span class="sd">                trajectories when comparing the IC and its perturbation. This is a</span>
<span class="sd">                *distance* in [0, 1], where 0 means identical and 1 means completely</span>
<span class="sd">                different.</span>
<span class="sd">            - BasinCoherenceApproximation : np.ndarray[float]</span>
<span class="sd">                Approximate coherence per basin (same definition as coherence but</span>
<span class="sd">                conditioned on having reached that basin).</span>
<span class="sd">            - BasinFragilityApproximation : np.ndarray[float]</span>
<span class="sd">                Approximate fragility per basin (same definition as fragility but</span>
<span class="sd">                conditioned on having reached that basin).</span>
<span class="sd">            - AttractorCoherence : np.ndarray[float], optional</span>
<span class="sd">                If ``RETURN_ATTRACTOR_COHERENCE`` is True: estimated attractor-level</span>
<span class="sd">                coherence (probability that a single-bit perturbation of an attractor</span>
<span class="sd">                state returns to the same attractor).</span>
<span class="sd">            - AttractorFragility : np.ndarray[float], optional</span>
<span class="sd">                If ``RETURN_ATTRACTOR_COHERENCE`` is True: estimated attractor-level</span>
<span class="sd">                fragility based on differences between the original attractor and the</span>
<span class="sd">                attractor reached after perturbation.</span>
<span class="sd">    </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Park, K. H., Costa, F. X., Rocha, L. M., Albert, R., &amp; Rozum, J. C. (2023).</span>
<span class="sd">        Models of cell processes are far from the edge of chaos. PRX Life, 1(2), 023009.</span>
<span class="sd">    </span>
<span class="sd">        Bavisetty, V. S. N., Wheeler, M., &amp; Kadelka, C. (2025).</span>
<span class="sd">        Attractors are less stable than their basins: Canalization creates a coherence</span>
<span class="sd">        gap in gene regulatory networks. bioRxiv 2025-11.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_coerce_rng</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
    
        <span class="k">def</span><span class="w"> </span><span class="nf">lcm</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="o">//</span> <span class="n">math</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># Initialization</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="n">dictF</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">attractors</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ICs_per_attractor_state</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">basin_sizes</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">attractor_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">attractor_state_dict</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">distance_from_attractor_state_dict</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">counter_phase_shifts</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
    
        <span class="n">height</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
    
        <span class="n">powers_of_2s</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NN</span><span class="p">)][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">NN</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span>
    
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">:</span>
            <span class="n">powers_of_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    
        <span class="n">robustness_approximation</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fragility_sum</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">basin_robustness</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">basin_fragility</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">final_hamming_distance_approximation</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
    
        <span class="n">mean_states_attractors</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">states_attractors</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># Main sampling loop</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_different_IC</span><span class="p">):</span>
            <span class="n">index_attractors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">index_of_state_within_attractor_reached</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">distance_from_attractor</span> <span class="o">=</span> <span class="p">[]</span>
    
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">:</span>
                        <span class="n">xdec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">powers_of_2</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">xdec</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bit</span><span class="p">))</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">x</span><span class="p">)</span>
                    <span class="n">x_old</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">x_old</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">bit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">bit</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">bit</span><span class="p">]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">:</span>
                        <span class="n">xdec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">powers_of_2</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">xdec</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bit</span><span class="p">))</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">x</span><span class="p">)</span>
    
                <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">xdec</span><span class="p">]</span>
    
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">index_attr</span> <span class="o">=</span> <span class="n">attractor_dict</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">fxdec</span> <span class="o">=</span> <span class="n">dictF</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">fx</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span><span class="o">.</span><span class="n">f</span><span class="p">[</span>
                                        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">jj</span><span class="p">]],</span> <span class="n">powers_of_2s</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indegrees</span><span class="p">[</span><span class="n">jj</span><span class="p">]]))</span>
                                    <span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">fx</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">:</span>
                                <span class="n">fxdec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">powers_of_2</span><span class="p">))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">fxdec</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bit</span><span class="p">))</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">fx</span><span class="p">)</span>
    
                            <span class="n">dictF</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span> <span class="o">=</span> <span class="n">fxdec</span>
    
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">index_attr</span> <span class="o">=</span> <span class="n">attractor_dict</span><span class="p">[</span><span class="n">fxdec</span><span class="p">]</span>
                            <span class="n">idx_state</span> <span class="o">=</span> <span class="n">attractor_state_dict</span><span class="p">[</span><span class="n">index_attr</span><span class="p">][</span><span class="n">fxdec</span><span class="p">]</span>
                            <span class="n">dist_state</span> <span class="o">=</span> <span class="n">distance_from_attractor_state_dict</span><span class="p">[</span><span class="n">index_attr</span><span class="p">][</span><span class="n">fxdec</span><span class="p">]</span>
    
                            <span class="n">attractor_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">q</span><span class="p">:</span> <span class="n">index_attr</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">})</span>
                            <span class="n">attractor_state_dict</span><span class="p">[</span><span class="n">index_attr</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                                <span class="p">{</span><span class="n">q</span><span class="p">:</span> <span class="n">idx_state</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">}</span>
                            <span class="p">)</span>
                            <span class="n">distance_from_attractor_state_dict</span><span class="p">[</span><span class="n">index_attr</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                                <span class="p">{</span>
                                    <span class="n">q</span><span class="p">:</span> <span class="n">d</span>
                                    <span class="k">for</span> <span class="n">q</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                                        <span class="n">queue</span><span class="p">,</span>
                                        <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">+</span> <span class="n">dist_state</span><span class="p">,</span> <span class="n">dist_state</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                    <span class="p">)</span>
                                <span class="p">}</span>
                            <span class="p">)</span>
                            <span class="k">break</span>
    
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">fxdec</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
                                <span class="n">idx</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">fxdec</span><span class="p">)</span>
                                <span class="n">index_attr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">attractors</span><span class="p">)</span>
    
                                <span class="n">attractors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">queue</span><span class="p">[</span><span class="n">idx</span><span class="p">:])</span>
                                <span class="n">basin_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                                <span class="n">ICs_per_attractor_state</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">attractors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                                <span class="p">)</span>
                                <span class="n">counter_phase_shifts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">attractors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                                <span class="p">)</span>
    
                                <span class="n">attractor_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">q</span><span class="p">:</span> <span class="n">index_attr</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">})</span>
                                <span class="n">attractor_state_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">{</span><span class="n">q</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span> <span class="k">else</span> <span class="n">queue</span><span class="p">[</span><span class="n">idx</span><span class="p">:]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
                                     <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">}</span>
                                <span class="p">)</span>
                                <span class="n">distance_from_attractor_state_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">{</span>
                                        <span class="n">q</span><span class="p">:</span> <span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="n">queue</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="k">if</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span>
                                        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queue</span>
                                    <span class="p">}</span>
                                <span class="p">)</span>
    
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attractors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">:</span>
                                        <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                                            <span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">queue</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span>
                                            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                        <span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                                            <span class="nb">list</span><span class="p">(</span><span class="n">queue</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
                                        <span class="p">)</span>
                                    <span class="n">states_attractors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
                                    <span class="n">mean_states_attractors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">:</span>
                                        <span class="n">lc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                                            <span class="p">[</span>
                                                <span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
                                                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">[</span><span class="n">idx</span><span class="p">:]</span>
                                            <span class="p">],</span>
                                            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                        <span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">lc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                                            <span class="p">[</span>
                                                <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">[</span><span class="n">idx</span><span class="p">:]</span>
                                            <span class="p">],</span>
                                            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                        <span class="p">)</span>
                                    <span class="n">states_attractors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
                                    <span class="n">mean_states_attractors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                                <span class="k">break</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">x</span> <span class="o">=</span> <span class="n">fx</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fxdec</span><span class="p">)</span>
                                <span class="n">xdec</span> <span class="o">=</span> <span class="n">fxdec</span>
    
                <span class="n">index_attractors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_attr</span><span class="p">)</span>
                <span class="n">index_of_state_within_attractor_reached</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">attractor_state_dict</span><span class="p">[</span><span class="n">index_attr</span><span class="p">][</span><span class="n">xdec</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">distance_from_attractor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">distance_from_attractor_state_dict</span><span class="p">[</span><span class="n">index_attr</span><span class="p">][</span><span class="n">xdec</span><span class="p">]</span>
                <span class="p">)</span>
    
                <span class="n">basin_sizes</span><span class="p">[</span><span class="n">index_attr</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">ICs_per_attractor_state</span><span class="p">[</span><span class="n">index_attr</span><span class="p">][</span>
                    <span class="n">attractor_state_dict</span><span class="p">[</span><span class="n">index_attr</span><span class="p">][</span><span class="n">xdec</span><span class="p">]</span>
                <span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    
            <span class="k">if</span> <span class="n">index_attractors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">index_attractors</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">robustness_approximation</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">basin_robustness</span><span class="p">[</span><span class="n">index_attractors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
    
                <span class="n">ps</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">max</span><span class="p">(</span><span class="n">index_of_state_within_attractor_reached</span><span class="p">)</span>
                    <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">index_of_state_within_attractor_reached</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">counter_phase_shifts</span><span class="p">[</span><span class="n">index_attr</span><span class="p">][</span><span class="n">ps</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                        <span class="n">mean_states_attractors</span><span class="p">[</span><span class="n">index_attractors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                        <span class="o">-</span> <span class="n">mean_states_attractors</span><span class="p">[</span><span class="n">index_attractors</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">fragility_sum</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">basin_fragility</span><span class="p">[</span><span class="n">index_attractors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    
                <span class="n">L</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">attractors</span><span class="p">[</span><span class="n">index_attractors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">attractors</span><span class="p">[</span><span class="n">index_attractors</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
                <span class="p">)</span>
    
                <span class="n">s0</span> <span class="o">=</span> <span class="n">states_attractors</span><span class="p">[</span><span class="n">index_attractors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">states_attractors</span><span class="p">[</span><span class="n">index_attractors</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    
                <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="p">(</span><span class="n">L</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))[</span>
                    <span class="n">index_of_state_within_attractor_reached</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span>
                    <span class="n">index_of_state_within_attractor_reached</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">L</span>
                <span class="p">]</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="p">(</span><span class="n">L</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))[</span>
                    <span class="n">index_of_state_within_attractor_reached</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span>
                    <span class="n">index_of_state_within_attractor_reached</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">L</span>
                <span class="p">]</span>
    
                <span class="n">final_hamming_distance_approximation</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">p0</span> <span class="o">==</span> <span class="n">p1</span><span class="p">)</span>
                <span class="p">)</span>
    
            <span class="n">height</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">distance_from_attractor</span><span class="p">)</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># Aggregation</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="n">lower_bound_number_of_attractors</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">attractors</span><span class="p">))</span>
    
        <span class="n">approximate_basin_sizes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">basin_sizes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">number_different_IC</span><span class="p">))</span>
        <span class="p">)</span>
    
        <span class="n">approximate_coherence</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
            <span class="n">robustness_approximation</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">number_different_IC</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">approximate_fragility</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
            <span class="n">fragility_sum</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">number_different_IC</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="p">)</span>
    
        <span class="n">approximate_basin_coherence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="mf">2.0</span> <span class="o">*</span> <span class="n">basin_robustness</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">basin_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lower_bound_number_of_attractors</span><span class="p">)</span>
            <span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="p">)</span>
    
        <span class="n">approximate_basin_fragility</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="mf">2.0</span> <span class="o">*</span> <span class="n">basin_fragility</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">basin_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lower_bound_number_of_attractors</span><span class="p">)</span>
            <span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="p">)</span>
    
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lower_bound_number_of_attractors</span><span class="p">):</span>
            <span class="n">periodic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">states_attractors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">shift</span><span class="p">,</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">counter_phase_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">shift</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">final_hamming_distance_approximation</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span>
                        <span class="n">cnt</span>
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                            <span class="n">states_attractors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="o">==</span> <span class="n">periodic</span><span class="p">[</span><span class="n">shift</span> <span class="p">:</span> <span class="n">shift</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">attractors</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
    
        <span class="n">final_hamming_distance_approximation</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
            <span class="n">final_hamming_distance_approximation</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">number_different_IC</span><span class="p">)</span>
        <span class="p">)</span>
    
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">attractors</span><span class="p">,</span>
            <span class="n">lower_bound_number_of_attractors</span><span class="p">,</span>
            <span class="n">approximate_basin_sizes</span><span class="p">,</span>
            <span class="n">approximate_coherence</span><span class="p">,</span>
            <span class="n">approximate_fragility</span><span class="p">,</span>
            <span class="n">final_hamming_distance_approximation</span><span class="p">,</span>
            <span class="n">approximate_basin_coherence</span><span class="p">,</span>
            <span class="n">approximate_basin_fragility</span><span class="p">,</span>
        <span class="p">]</span>
    
        <span class="k">if</span> <span class="ow">not</span> <span class="n">RETURN_ATTRACTOR_COHERENCE</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="s2">&quot;Attractors&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;LowerBoundOfNumberOfAttractors&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;BasinSizesApproximation&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;CoherenceApproximation&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;FragilityApproximation&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;FinalHammingDistanceApproximation&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;BasinCoherenceApproximation&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;BasinFragilityApproximation&quot;</span><span class="p">,</span>
                    <span class="p">],</span>
                    <span class="n">results</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># Attractor-level coherence / fragility</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="n">attractor_coherence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">lower_bound_number_of_attractors</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="p">)</span>
        <span class="n">attractor_fragility</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">lower_bound_number_of_attractors</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="p">)</span>
    
        <span class="n">attractors_original</span> <span class="o">=</span> <span class="n">attractors</span><span class="p">[:]</span>
    
        <span class="k">for</span> <span class="n">idx0</span><span class="p">,</span> <span class="n">attractor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">attractors_original</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">attractor</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">state</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">:</span>
                        <span class="n">xdec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">powers_of_2</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">xdec</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bit</span><span class="p">))</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">x</span><span class="p">)</span>
    
                    <span class="n">idx1</span> <span class="o">=</span> <span class="n">attractor_dict</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span>
    
                    <span class="k">if</span> <span class="n">idx0</span> <span class="o">==</span> <span class="n">idx1</span><span class="p">:</span>
                        <span class="n">attractor_coherence</span><span class="p">[</span><span class="n">idx0</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">attractor_fragility</span><span class="p">[</span><span class="n">idx0</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                                    <span class="n">mean_states_attractors</span><span class="p">[</span><span class="n">idx0</span><span class="p">]</span>
                                    <span class="o">-</span> <span class="n">mean_states_attractors</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
    
        <span class="n">attractor_coherence</span> <span class="o">/=</span> <span class="p">(</span>
            <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">attractors_original</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="p">)</span>
    
        <span class="n">attractor_fragility</span> <span class="o">/=</span> <span class="p">(</span>
            <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">attractors_original</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="p">)</span>
    
        <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">attractors_original</span>
    
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="s2">&quot;Attractors&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;LowerBoundOfNumberOfAttractors&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;BasinSizesApproximation&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;CoherenceApproximation&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;FragilityApproximation&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;FinalHammingDistanceApproximation&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;BasinCoherenceApproximation&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;BasinFragilityApproximation&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;AttractorCoherence&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;AttractorFragility&quot;</span><span class="p">,</span>
                <span class="p">],</span>
                <span class="n">results</span> <span class="o">+</span> <span class="p">[</span><span class="n">attractor_coherence</span><span class="p">,</span> <span class="n">attractor_fragility</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

    
    
<div class="viewcode-block" id="BooleanNetwork.get_derrida_value">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.get_derrida_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_derrida_value</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nsim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">EXACT</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">USE_NUMBA</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Derrida value of a Boolean network.</span>
<span class="sd">    </span>
<span class="sd">        The Derrida value measures the average Hamming distance between the</span>
<span class="sd">        one-step synchronous updates of two states that differ by a single-bit</span>
<span class="sd">        perturbation. It quantifies the short-term sensitivity of the network</span>
<span class="sd">        dynamics to small perturbations.</span>
<span class="sd">    </span>
<span class="sd">        If ``EXACT`` is True, the Derrida value is computed exactly as the mean</span>
<span class="sd">        (unnormalized) average sensitivity of the Boolean update functions.</span>
<span class="sd">        Otherwise, it is approximated via Monte Carlo simulation.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsim : int, optional</span>
<span class="sd">            Number of Monte Carlo simulations to perform (default is 1000).</span>
<span class="sd">            Ignored if ``EXACT`` is True.</span>
<span class="sd">        EXACT : bool, optional</span>
<span class="sd">            If True, compute the exact Derrida value. If False (default),</span>
<span class="sd">            approximate the Derrida value using Monte Carlo simulation.</span>
<span class="sd">        USE_NUMBA : bool, optional</span>
<span class="sd">            If True (default) and Numba is available, use a compiled kernel for</span>
<span class="sd">            Monte Carlo simulation.</span>
<span class="sd">        rng : None or np.random.Generator, optional</span>
<span class="sd">            Random number generator, passed through ``utils._coerce_rng``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The Derrida value, defined as the average Hamming distance after</span>
<span class="sd">            one synchronous update following a single-bit perturbation.</span>
<span class="sd">    </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Derrida, B., &amp; Pomeau, Y. (1986).</span>
<span class="sd">        Random networks of automata: a simple annealed approximation.</span>
<span class="sd">        *Europhysics Letters*, 1(2), 45.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># Exact computation</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="k">if</span> <span class="n">EXACT</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">bf</span><span class="o">.</span><span class="n">get_average_sensitivity</span><span class="p">(</span>
                            <span class="n">EXACT</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">NORMALIZED</span><span class="o">=</span><span class="kc">False</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">bf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># Monte Carlo approximation</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_coerce_rng</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">__LOADED_NUMBA__</span> <span class="ow">and</span> <span class="n">USE_NUMBA</span><span class="p">:</span>
            <span class="c1"># Prepare Numba-friendly inputs</span>
            <span class="n">F_array_list</span> <span class="o">=</span> <span class="n">List</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bf</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="k">for</span> <span class="n">bf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">I_array_list</span> <span class="o">=</span> <span class="n">List</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="k">for</span> <span class="n">regs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">]</span>
            <span class="p">)</span>
    
            <span class="n">seed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span>
                <span class="n">_derrida_simulation</span><span class="p">(</span>
                    <span class="n">F_array_list</span><span class="p">,</span>
                    <span class="n">I_array_list</span><span class="p">,</span>
                    <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">nsim</span><span class="p">),</span>
                    <span class="n">seed</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
    
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="c1"># Pure Python fallback</span>
        <span class="c1"># ------------------------------------------------------------------</span>
        <span class="n">total_dist</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
    
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nsim</span><span class="p">)):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
            <span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">^=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    
            <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_network_synchronously_unchecked</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">fy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_network_synchronously_unchecked</span><span class="p">(</span><span class="n">y</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
            <span class="p">)</span>
    
            <span class="n">total_dist</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fx</span> <span class="o">!=</span> <span class="n">fy</span><span class="p">))</span>
    
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">total_dist</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nsim</span><span class="p">))</span></div>


<span class="c1"># ===================== #</span>
<span class="c1">#   Modular BoolForge   #</span>
<span class="c1"># ===================== #</span>

<span class="c1"># TODO: Product of Trajectories</span>
<span class="c1"># TODO: Product of STG</span>

<span class="c1"># 2.8</span>
<span class="c1"># attr: [[(1, 0), (0, 0)], [(1, 1), (0, 2)]]</span>
<span class="c1"># stg: {(1, 0): (0, 0),</span>
<span class="c1">#       (0, 0): (1, 0),</span>
<span class="c1">#       (1, 1): (0, 2),</span>
<span class="c1">#       (0, 2): (1, 1),</span>
<span class="c1">#       (1, 2): (0, 1),</span>
<span class="c1">#       (0, 1): (1, 0),</span>
<span class="c1">#       (1, 3): (0, 3),</span>
<span class="c1">#       (0, 3): (1, 1)}</span>

<span class="c1"># 2.9</span>
<span class="c1"># attr: [[(1, 0), (0, 1), (1, 1), (0, 3)]]</span>
<span class="c1"># stg: {(1, 0): (0, 1),</span>
<span class="c1">#       (0, 1): (1, 1),</span>
<span class="c1">#       (1, 1): (0, 3),</span>
<span class="c1">#       (0, 3): (1, 0),</span>
<span class="c1">#       (1, 2): (0, 0),</span>
<span class="c1">#       (0, 0): (1, 1),</span>
<span class="c1">#       (1, 3): (0, 2),</span>
<span class="c1">#       (0, 2): (1, 0)}</span>

<span class="c1"># 2.8 x 2.9</span>
<span class="c1"># attr: [[(3, 0), (0, 1), (3, 1), (0, 3)],</span>
<span class="c1">#       [(3, 4), (0, 9), (3, 5), (0, 11)]]</span>
    
<div class="viewcode-block" id="BooleanNetwork.get_attractors_synchronous_exact_non_autonomous">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous_exact_non_autonomous">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_attractors_synchronous_exact_non_autonomous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">non_periodic_component</span><span class="p">,</span> <span class="n">periodic_component</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        desc.</span>
<span class="sd">        </span>
<span class="sd">        **Parameters:**</span>
<span class="sd">            </span>
<span class="sd">            - non_periodic_component (list | np.array): desc.</span>
<span class="sd">            </span>
<span class="sd">            - periodic_component (list | np.array): desc.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">        </span>
<span class="sd">            - dict[str:Variant]: A dictionary containing:</span>
<span class="sd">                </span>
<span class="sd">                - Attractors (list[list[tuple[int, int]]]): List of attractors</span>
<span class="sd">                  where each attractor is repesented as a list of integer pairs</span>
<span class="sd">                  forming the cycle. The first value in each pair represents</span>
<span class="sd">                  the decimal value of the input pattern, and the second value</span>
<span class="sd">                  represents the decimal value of the state.</span>
<span class="sd">                  </span>
<span class="sd">                - NumberOfAttractors (int): Total number of unique attractors.</span>
<span class="sd">                - BasinSizes (list[int]): List of counts for each attractor.</span>
<span class="sd">                - AttractorDict (dict[tuple[int, int]:int]): Dictionary mapping</span>
<span class="sd">                  each state value pair (in decimal) to its attractor index.</span>
<span class="sd">                  </span>
<span class="sd">                - STG (dict[int:int]): The state transition graph as a dictionary,</span>
<span class="sd">                  with each state represented by its decimal pair representation.</span>
<span class="sd">                  </span>
<span class="sd">                - InitialStatesPeriodic (list[int]): The set of unique initial</span>
<span class="sd">                  states in decimal format after evaluating the non-periodic</span>
<span class="sd">                  component of the input sequence. Used as initial states for</span>
<span class="sd">                  the evaluation of the periodic component.</span>
<span class="sd">                  </span>
<span class="sd">                - FormattedAttractors (list[list[list[int]]]): List of attractors</span>
<span class="sd">                  represented as a list of binary vectors. The values of the</span>
<span class="sd">                  attractor decimal pairs are concatenated into a single vector.</span>
<span class="sd">        &quot;&quot;&quot;</span> <span class="c1">#TODO: type hints, docstring</span>
        <span class="c1"># Convert components into single argument? tuple|list|arr, str, etc.?</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_identity_nodes</span><span class="p">(</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_periodic_component</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">initial_states</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># stores initial states for periodic computation</span>
            <span class="n">len_np_comp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_periodic_component</span><span class="p">)</span>
            <span class="n">max_len_pattern</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">non_periodic_component</span><span class="p">))))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">fixed_source_networks</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">N</span><span class="p">):</span>
                <span class="n">fxvec</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="c1"># initialize binary vector</span>
                <span class="k">for</span> <span class="n">iii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_len_pattern</span><span class="p">):</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span> <span class="n">non_periodic_component</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">iii</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_np_comp</span><span class="p">)</span> <span class="p">]</span>
                    <span class="n">values_decimal</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">values_decimal</span> <span class="ow">in</span> <span class="n">fixed_source_networks</span><span class="p">:</span>
                        <span class="n">fixed_source_network</span> <span class="o">=</span> <span class="n">fixed_source_networks</span><span class="p">[</span><span class="n">values_decimal</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fixed_source_network</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_network_with_fixed_identity_nodes</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                        <span class="n">fixed_source_networks</span><span class="p">[</span><span class="n">values_decimal</span><span class="p">]</span> <span class="o">=</span> <span class="n">fixed_source_network</span>
                    <span class="n">fxvec</span> <span class="o">=</span> <span class="n">fixed_source_network</span><span class="o">.</span><span class="n">update_network_synchronously</span><span class="p">(</span><span class="n">fxvec</span><span class="p">)</span>
                <span class="n">initial_states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">fxvec</span><span class="p">))</span>
            <span class="n">initial_states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">initial_states</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">initial_states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">N</span><span class="p">))</span>
        
        <span class="n">attr_computation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attractors_synchronous_exact_with_external_inputs</span><span class="p">(</span><span class="n">periodic_component</span><span class="p">,</span> <span class="n">initial_states</span><span class="p">)</span>
        
        <span class="n">bvec_attractors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">len_pattern</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">periodic_component</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attr_computation</span><span class="p">[</span><span class="s2">&quot;Attractors&quot;</span><span class="p">]:</span>
            <span class="n">bvec_attractors</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">decimal_external</span><span class="p">,</span> <span class="n">decimal_module</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">len_pattern</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">bvec</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">decimal_external</span><span class="p">,</span> <span class="n">len_pattern</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bvec</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">bvec</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">decimal_module</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
                <span class="n">bvec_attractors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bvec</span><span class="p">)</span>
        
        <span class="n">attr_computation</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;InitialStatesPeriodic&quot;</span><span class="p">:</span><span class="n">initial_states</span><span class="p">,</span><span class="s2">&quot;FormattedAttractors&quot;</span><span class="p">:</span><span class="n">bvec_attractors</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">attr_computation</span></div>

    
<div class="viewcode-block" id="BooleanNetwork.get_attractors_synchronous_exact_with_external_inputs">
<a class="viewcode-back" href="../../boolean_network.html#boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous_exact_with_external_inputs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_attractors_synchronous_exact_with_external_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">input_patterns</span> <span class="p">:</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">],</span>
        <span class="n">starting_states</span> <span class="p">:</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        desc.</span>
<span class="sd">        </span>
<span class="sd">        **Parameters:**</span>
<span class="sd">            </span>
<span class="sd">            - input_patterns (list | np.array): desc.</span>
<span class="sd">            </span>
<span class="sd">            - starting_states (list | np.array | None, optional): desc.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">        </span>
<span class="sd">            - dict[str:Variant]: A dictionary containing:</span>
<span class="sd">                </span>
<span class="sd">                - Attractors (list[list[tuple[int, int]]]): List of attractors</span>
<span class="sd">                  (each attractor is repesented as a list of integer pairs</span>
<span class="sd">                  forming the cycle). The first value in each pair represents</span>
<span class="sd">                  the decimal value of the input pattern, and the second value</span>
<span class="sd">                  represents the decimal value of the state.</span>
<span class="sd">                  </span>
<span class="sd">                - NumberOfAttractors (int): Total number of unique attractors.</span>
<span class="sd">                - BasinSizes (list[int]): List of counts for each attractor.</span>
<span class="sd">                - AttractorDict (dict[tuple[int, int]:int]): Dictionary mapping</span>
<span class="sd">                  each state value pair (in decimal) to its attractor index.</span>
<span class="sd">                  </span>
<span class="sd">                - STG (dict[int:int]): The state transition graph as a dictionary,</span>
<span class="sd">                  with each state represented by its decimal pair representation.</span>
<span class="sd">        &quot;&quot;&quot;</span> <span class="c1">#TODO: docstring</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_identity_nodes</span><span class="p">(</span><span class="kc">False</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">starting_states</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">starting_states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">N</span><span class="p">))</span>
        
        <span class="n">len_patterns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_patterns</span><span class="p">)</span>
        <span class="n">lcm</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">lcm</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">input_patterns</span><span class="p">)))</span>
        <span class="n">periodic_pattern_of_external_inputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">lcm</span><span class="p">,</span> <span class="n">len_patterns</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_patterns</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">lcm</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">))):</span>
                <span class="n">periodic_pattern_of_external_inputs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span><span class="o">*</span><span class="n">j</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pattern</span>
        <span class="n">n_initial_values</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">periodic_pattern_of_external_inputs</span><span class="p">)</span>
        
        <span class="n">fixed_source_networks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">input_values</span> <span class="ow">in</span> <span class="n">periodic_pattern_of_external_inputs</span><span class="p">:</span>
            <span class="n">fixed_source_networks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_network_with_fixed_identity_nodes</span><span class="p">(</span><span class="n">input_values</span><span class="p">))</span>
        
        <span class="n">lstt</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_left_side_of_truth_table</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">po2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">dictF_fixed_source</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">iii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_initial_values</span><span class="p">):</span>
            <span class="n">state_space</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">**</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">fixed_source_networks</span><span class="p">[</span><span class="n">iii</span><span class="p">]</span><span class="o">.</span><span class="n">indegrees</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                    <span class="k">if</span> <span class="n">fixed_source_networks</span><span class="p">[</span><span class="n">iii</span><span class="p">]</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># For rows in left_side_of_truth_table where the columns I[i] equal x, set state_space accordingly.</span>
                        <span class="n">state_space</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">lstt</span><span class="p">[:,</span> <span class="n">fixed_source_networks</span><span class="p">[</span><span class="n">iii</span><span class="p">]</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">dictF_fixed_source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">N</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">state_space</span><span class="p">,</span> <span class="n">po2</span><span class="p">))))</span>
        
        <span class="n">attractors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">basin_sizes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">attractor_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">stg</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">iii_start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lcm</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">xdec</span> <span class="ow">in</span> <span class="n">starting_states</span><span class="p">:</span>
                <span class="n">iii</span> <span class="o">=</span> <span class="n">iii_start</span>
                <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">xdec</span><span class="p">]</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">fxdec</span> <span class="o">=</span> <span class="n">dictF_fixed_source</span><span class="p">[</span><span class="n">iii</span> <span class="o">%</span> <span class="n">n_initial_values</span><span class="p">][</span><span class="n">xdec</span><span class="p">]</span>
                    <span class="n">stg</span><span class="o">.</span><span class="n">update</span><span class="p">({(</span><span class="nb">int</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">periodic_pattern_of_external_inputs</span><span class="p">[</span><span class="n">iii</span> <span class="o">%</span> <span class="n">n_initial_values</span><span class="p">])),</span><span class="nb">int</span><span class="p">(</span><span class="n">xdec</span><span class="p">)):(</span><span class="nb">int</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">periodic_pattern_of_external_inputs</span><span class="p">[(</span><span class="n">iii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_initial_values</span><span class="p">])),</span><span class="nb">int</span><span class="p">(</span><span class="n">fxdec</span><span class="p">))})</span>
                    <span class="n">iii</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">index_attr</span> <span class="o">=</span> <span class="n">attractor_dict</span><span class="p">[(</span><span class="n">iii</span> <span class="o">%</span> <span class="n">n_initial_values</span><span class="p">,</span><span class="n">fxdec</span><span class="p">)]</span>
                        <span class="n">basin_sizes</span><span class="p">[</span><span class="n">index_attr</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">attractor_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">iii_start</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="o">+</span><span class="n">iii_start</span><span class="p">)</span><span class="o">%</span><span class="n">n_initial_values</span><span class="p">,</span><span class="n">queue</span><span class="p">),</span> <span class="p">[</span><span class="n">index_attr</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">))))</span>
                        <span class="k">break</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span> 
                            <span class="n">index</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="n">n_initial_values</span><span class="p">::</span><span class="o">-</span><span class="n">n_initial_values</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">fxdec</span><span class="p">)</span>
                            <span class="n">dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">iii_start</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="o">+</span><span class="n">iii_start</span><span class="p">)</span><span class="o">%</span><span class="n">n_initial_values</span>
                            <span class="c1">#print(iii_start,j,list(zip(dummy[-n_initial_values*(index+1):],queue[-n_initial_values*(index+1):])))</span>
                            <span class="n">attractor_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dummy</span><span class="p">,</span><span class="n">queue</span><span class="p">),</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">attractors</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">))))</span>
                            <span class="n">attractors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dummy</span><span class="p">[</span><span class="o">-</span><span class="n">n_initial_values</span><span class="o">*</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">):],</span><span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="n">n_initial_values</span><span class="o">*</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">):])))</span>
                            <span class="n">basin_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                            <span class="k">break</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="k">pass</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fxdec</span><span class="p">)</span>
                    <span class="n">xdec</span> <span class="o">=</span> <span class="n">fxdec</span>
        
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">attr_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">attractor_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">attr_dict</span><span class="p">[(</span><span class="nb">int</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">periodic_pattern_of_external_inputs</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]])),</span> <span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]))]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">attractor_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attractors</span><span class="p">:</span>
            <span class="n">formatted_attr</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">:</span>
                <span class="n">formatted_attr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">periodic_pattern_of_external_inputs</span><span class="p">[</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]])),</span> <span class="nb">int</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">formatted_attr</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">{</span> <span class="s2">&quot;Attractors&quot;</span><span class="p">:</span><span class="n">attrs</span><span class="p">,</span> <span class="s2">&quot;NumberOfAttractors&quot;</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">),</span>
                <span class="s2">&quot;BasinSizes&quot;</span><span class="p">:</span><span class="n">basin_sizes</span><span class="p">,</span> <span class="s2">&quot;AttractorDict&quot;</span><span class="p">:</span><span class="n">attr_dict</span><span class="p">,</span>
                <span class="s2">&quot;STG&quot;</span><span class="p">:</span><span class="n">stg</span> <span class="p">}</span><span class="c1">#, &quot;StateSpace&quot;:state_space} # state space is not properly maintained, so it is not returned</span></div>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">get_trajectories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">non_periodic_component</span><span class="p">,</span> <span class="n">periodic_component</span><span class="p">,</span>
        <span class="n">MERGE_TRAJECTORIES</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_identity_nodes</span><span class="p">(</span><span class="kc">False</span><span class="p">))</span>
        
        <span class="c1"># Helper method: get the network with fixed source nodes</span>
        <span class="c1"># associated with the given values vector.</span>
        <span class="n">fixed_networks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_get_fnet_</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="n">values_dec</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">values_dec</span> <span class="ow">in</span> <span class="n">fixed_networks</span><span class="p">:</span>
                <span class="n">fixed_network</span> <span class="o">=</span> <span class="n">fixed_networks</span><span class="p">[</span><span class="n">values_dec</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fixed_network</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_network_with_fixed_identity_nodes</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                <span class="n">fixed_networks</span><span class="p">[</span><span class="n">values_dec</span><span class="p">]</span> <span class="o">=</span> <span class="n">fixed_network</span>
            <span class="k">return</span> <span class="n">fixed_network</span>
        
        <span class="c1"># Helper method: calculate the trajectory of this network given</span>
        <span class="c1"># a starting state represented in decimal.</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_calc_traj_</span><span class="p">(</span><span class="n">starting</span><span class="p">):</span>
            <span class="n">trajectory</span> <span class="o">=</span> <span class="p">[</span><span class="n">starting</span><span class="p">]</span>
            <span class="n">latest_state</span> <span class="o">=</span> <span class="n">starting</span>
            <span class="c1"># Compute the non-periodic component of the trajectory.</span>
            <span class="n">len_np</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_periodic_component</span><span class="p">)</span>
            <span class="n">max_len_pattern</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">non_periodic_component</span><span class="p">))))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_len_pattern</span><span class="p">):</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span> <span class="n">non_periodic_component</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_np</span><span class="p">)</span> <span class="p">]</span>
                <span class="n">fixed_network</span> <span class="o">=</span> <span class="n">_get_fnet_</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                <span class="n">latest_state</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">fixed_network</span><span class="o">.</span><span class="n">update_network_synchronously</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">latest_state</span><span class="p">,</span> <span class="n">N</span><span class="p">)))</span>
                <span class="n">trajectory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">latest_state</span><span class="p">)</span>
            <span class="c1"># Compute the periodic component of the trajectory.</span>
            <span class="n">len_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">periodic_component</span><span class="p">)</span>
            <span class="n">lcm</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">lcm</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">periodic_component</span><span class="p">)))</span>
            <span class="n">idx_p</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">not_cyclic</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">cycle_len</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">while</span> <span class="n">not_cyclic</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span> <span class="n">periodic_component</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">idx_p</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">periodic_component</span><span class="p">[</span><span class="n">node</span><span class="p">])]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_p</span><span class="p">)</span> <span class="p">]</span>
                <span class="n">fixed_network</span> <span class="o">=</span> <span class="n">_get_fnet_</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                <span class="n">latest_state</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">fixed_network</span><span class="o">.</span><span class="n">update_network_synchronously</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">latest_state</span><span class="p">,</span> <span class="n">N</span><span class="p">)))</span>
                <span class="n">trajectory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">latest_state</span><span class="p">)</span>
                <span class="n">idx_p</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">len_traj</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">idx_p</span> <span class="o">&gt;=</span> <span class="n">lcm</span><span class="p">:</span> <span class="c1"># Cycle detection can probably be optimized</span>
                    <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">len_traj</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">supposed_pattern</span> <span class="o">=</span> <span class="n">trajectory</span><span class="p">[</span><span class="n">len_traj</span> <span class="o">-</span> <span class="n">L</span> <span class="p">:</span> <span class="n">len_traj</span><span class="p">]</span>
                        <span class="c1"># If we find a cycle that is repeated three times consecutively,</span>
                        <span class="c1"># it must be the periodic component.</span>
                        <span class="c1"># Note that this assumes that no sub-pattern will be repeated</span>
                        <span class="c1"># three or more times.</span>
                        <span class="k">if</span> <span class="n">supposed_pattern</span> <span class="o">==</span> <span class="n">trajectory</span><span class="p">[</span><span class="n">len_traj</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">L</span> <span class="p">:</span> <span class="n">len_traj</span> <span class="o">-</span> <span class="n">L</span><span class="p">]</span> <span class="ow">and</span> <span class="n">supposed_pattern</span> <span class="o">==</span> <span class="n">trajectory</span><span class="p">[</span><span class="n">len_traj</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">L</span> <span class="p">:</span> <span class="n">len_traj</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">L</span><span class="p">]:</span>
                            <span class="n">not_cyclic</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="n">cycle_len</span> <span class="o">=</span> <span class="n">L</span>
            <span class="c1"># Compress the trajectory&#39;s representation to be minimal.</span>
            <span class="c1"># That is, only the non-periodic component and a single</span>
            <span class="c1"># cycle of the periodic component.</span>
            <span class="k">if</span> <span class="n">len_traj</span> <span class="o">&gt;=</span> <span class="n">cycle_len</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span>
               <span class="n">cycle</span> <span class="o">=</span> <span class="n">trajectory</span><span class="p">[</span><span class="o">-</span><span class="n">cycle_len</span><span class="p">:]</span>
               <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>
               <span class="n">i</span> <span class="o">=</span> <span class="n">len_traj</span>
               <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">cycle_len</span> <span class="ow">and</span> <span class="n">trajectory</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">cycle_len</span><span class="p">:</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">cycle</span><span class="p">:</span>
                   <span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>
                   <span class="n">i</span> <span class="o">-=</span> <span class="n">cycle_len</span>
               <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                   <span class="n">new_len</span> <span class="o">=</span> <span class="n">len_traj</span> <span class="o">-</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">cycle_len</span>
                   <span class="n">trajectory</span> <span class="o">=</span> <span class="n">trajectory</span><span class="p">[:</span><span class="n">new_len</span><span class="p">]</span>
            <span class="c1"># Return the compressed trajectory array and the length of the</span>
            <span class="c1"># periodic component.</span>
            <span class="c1"># Note that the periodic component will ALWAYS be the last</span>
            <span class="c1"># cycle_len values in the array. The periodic components</span>
            <span class="c1"># also correspond with the attractors of the network.</span>
            <span class="k">return</span> <span class="n">trajectory</span><span class="p">,</span> <span class="n">cycle_len</span>
        
        <span class="c1"># Compute the trajectory for every initial state of the network.</span>
        <span class="n">trajectories</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">N</span><span class="p">):</span>
            <span class="n">trajectories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_calc_traj_</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        
        <span class="c1"># If the MERGE_TRAJECTORIES flag is set, return the merged representation</span>
        <span class="c1"># of the trajectories, which is of type nx.DiGraph.</span>
        <span class="k">if</span> <span class="n">MERGE_TRAJECTORIES</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">compress_trajectories</span><span class="p">(</span><span class="n">trajectories</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
        <span class="c1"># If the flag is not set, then just return the trajectory arrays</span>
        <span class="c1"># without further modification.</span>
        <span class="k">return</span> <span class="n">trajectories</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Claus Kadelka, Benjamin Coberly.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>


<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>boolforge.boolean_function &mdash; BoolForge 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            BoolForge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../docs.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">BoolForge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">boolforge.boolean_function</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for boolforge.boolean_function</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Tue Aug 12 11:03:49 2025</span>

<span class="sd">@author: Benjamin Coberly, Claus Kadelka</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">boolforge.utils</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">utils</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">utils</span>
    
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">cana.boolean_node</span>
    <span class="n">__LOADED_CANA__</span><span class="o">=</span><span class="kc">True</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The module cana cannot be found. Ensure it is installed to use all functionality of this toolbox.&quot;</span><span class="p">)</span>
    <span class="n">__LOADED_CANA__</span><span class="o">=</span><span class="kc">False</span>
    

<div class="viewcode-block" id="get_layer_structure_from_canalized_outputs">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.get_layer_structure_from_canalized_outputs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_layer_structure_from_canalized_outputs</span><span class="p">(</span><span class="n">can_outputs</span> <span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Composes the layer structure when given canalized outputs.</span>
<span class="sd">    </span>
<span class="sd">    **Parameters**:</span>
<span class="sd">        </span>
<span class="sd">        - can_outputs (list[int] | np.array[int]): Array of canalized output</span>
<span class="sd">          values.</span>
<span class="sd">    </span>
<span class="sd">    **Returns**:</span>
<span class="sd">        </span>
<span class="sd">        - list[int]: The composed layer structure for the provided canalized</span>
<span class="sd">          outputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">canalizing_depth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">can_outputs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">canalizing_depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">size_of_layer</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">layer_structure</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">canalizing_depth</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">can_outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">can_outputs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">size_of_layer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">layer_structure</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size_of_layer</span><span class="p">)</span>
            <span class="n">size_of_layer</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">layer_structure</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size_of_layer</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">layer_structure</span></div>



<div class="viewcode-block" id="BooleanFunction">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BooleanFunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class representing a Boolean function.</span>

<span class="sd">    **Constructor Parameters:**</span>
<span class="sd">        </span>
<span class="sd">        - f (list[int] | np.array[int] | str): A list of length 2^n</span>
<span class="sd">          representing the outputs of a Boolean function with n inputs, or a</span>
<span class="sd">          string that can be properly evaluated, see utils.f_from_expression.</span>
<span class="sd">        </span>
<span class="sd">        - name (str, optional): The name of the node regulated by the Boolean</span>
<span class="sd">          function (default &#39;&#39;).</span>
<span class="sd">        </span>
<span class="sd">    **Members:**</span>
<span class="sd">        </span>
<span class="sd">        - f (np.array[int]): A numpy array of length 2^n representing the</span>
<span class="sd">          outputs of a Boolean function with n inputs.</span>
<span class="sd">          </span>
<span class="sd">        - n (int): The number of inputs for the Boolean function.</span>
<span class="sd">        - variables (np.array[str]): A numpy array of n strings with variable</span>
<span class="sd">          names, default x0, ..., x_{n-1}.</span>
<span class="sd">          </span>
<span class="sd">        - name (str): The name of the node regulated by the Boolean function</span>
<span class="sd">          (default &#39;&#39;).</span>
<span class="sd">          </span>
<span class="sd">        - properties (dict[str:Variant]): Dynamically created dictionary with</span>
<span class="sd">          additional information about the function (canalizing layer</span>
<span class="sd">          structure, type of inputs, etc.).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">,</span><span class="s1">&#39;variables&#39;</span><span class="p">,</span><span class="s1">&#39;name&#39;</span><span class="p">,</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span> <span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">name</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">f_from_expression</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)),</span> <span class="s2">&quot;f must be a list, numpy array or interpretable string&quot;</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;f cannot be empty&quot;</span>
            
            <span class="n">_n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
            <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="o">-</span> <span class="n">_n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="s2">&quot;f must be of size 2^n, n &gt;= 0&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">_n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;x</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)])</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="BooleanFunction.from_cana">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.from_cana">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_cana</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cana_BooleanNode</span> <span class="p">:</span> <span class="s2">&quot;cana.boolean_node.BooleanNode&quot;</span><span class="p">)</span><span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **Compatability Method:**</span>
<span class="sd">        </span>
<span class="sd">            Converts an instance of cana.boolean_node.BooleanNode from the</span>
<span class="sd">            cana module into a Boolforge BooleanFunction object.</span>
<span class="sd">        </span>
<span class="sd">        **Returns**:</span>
<span class="sd">            </span>
<span class="sd">                - A BooleanFunction object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cana_BooleanNode</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="c1">#return f&quot;{self.f.tolist()}&quot;</span>
        
<div class="viewcode-block" id="BooleanFunction.str_expr">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.str_expr">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">str_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Boolean function converted into polynomial format in</span>
<span class="sd">        non-reduced DNF.</span>
<span class="sd">        </span>
<span class="sd">        **Returns**:</span>
<span class="sd">            </span>
<span class="sd">            - str: Polynomial format in non-reduced DNF of the Boolean function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">bool_to_poly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span><span class="n">variables</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span></div>

    
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(f=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(f=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="si">}</span><span class="s2">)&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    
<div class="viewcode-block" id="BooleanFunction.to_cana">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.to_cana">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_cana</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;cana.boolean_node.BooleanNode&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **Compatability method:**</span>
<span class="sd">            </span>
<span class="sd">            Returns an instance of cana.boolean_node.BooleanNode from the</span>
<span class="sd">            cana module.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - An instance of cana.boolean_node.BooleanNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__LOADED_CANA__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cana</span><span class="o">.</span><span class="n">boolean_node</span><span class="o">.</span><span class="n">BooleanNode</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The method </span><span class="se">\&#39;</span><span class="s1">to_cana_BooleanNode</span><span class="se">\&#39;</span><span class="s1"> requires the module cana, which cannot be found. Ensure it is installed to use this functionality.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    
<div class="viewcode-block" id="BooleanFunction.to_expression">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.to_expression">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">AND</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">,</span> <span class="n">OR</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="n">NOT</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;!&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a Boolean function from truth table format to logical expression</span>
<span class="sd">        format using the Quine-McCluskey algorithm.</span>

<span class="sd">        **Parameters:**</span>
<span class="sd">            </span>
<span class="sd">            - AND (str, optional): Character(s) to use for the And operator.</span>
<span class="sd">              Defaults to &#39;&amp;&#39;.</span>
<span class="sd">            </span>
<span class="sd">            - OR (str, optional): Character(s) to use for the Or operator. Defaults</span>
<span class="sd">              to &#39;|&#39;.</span>
<span class="sd">            </span>
<span class="sd">            - NOT (str, optional): Character(s) to use for the Not operator.</span>
<span class="sd">              Defaults to &#39;!&#39;.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - str: A string representing the Boolean function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">bool_to_poly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; * &#39;</span><span class="p">,</span> <span class="n">AND</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; + &#39;</span><span class="p">,</span> <span class="n">OR</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;1 - &#39;</span><span class="p">,</span> <span class="n">NOT</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="BooleanFunction.get_hamming_weight">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_hamming_weight">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_hamming_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the number of non-zero bits in the bit vector representing</span>
<span class="sd">        a Boolean function.</span>
<span class="sd">        </span>
<span class="sd">        **Returns:**</span>
<span class="sd">        </span>
<span class="sd">            - int: The number of non-zero bits in the bit vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span></div>

    
<div class="viewcode-block" id="BooleanFunction.is_constant">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.is_constant">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether a Boolean function is constant.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - bool: True if f is constant (all outputs are 0 or all are 1),</span>
<span class="sd">              False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hamming_weight</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">]</span></div>

    
<div class="viewcode-block" id="BooleanFunction.is_degenerated">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.is_degenerated">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_degenerated</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if a Boolean function contains non-essential variables.</span>

<span class="sd">        A variable is non-essential if the function&#39;s output does not depend</span>
<span class="sd">        on it.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - bool: True if f contains at least one non-essential variable,</span>
<span class="sd">              False if all variables are essential.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">dummy_add</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">))</span>
            <span class="n">dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">))</span> <span class="o">//</span> <span class="n">dummy_add</span>
            <span class="n">depends_on_i</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dummy</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">dummy_add</span><span class="p">]:</span>
                        <span class="n">depends_on_i</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="n">depends_on_i</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="BooleanFunction.get_essential_variables">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_essential_variables">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_essential_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the indices of essential variables in a Boolean function.</span>

<span class="sd">        A variable is essential if changing its value (while holding the others</span>
<span class="sd">        constant) can change the output of f.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - list[int]: List of indices corresponding to the essential variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">essential_variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">dummy_add</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">))</span>
            <span class="n">dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">))</span> <span class="o">//</span> <span class="n">dummy_add</span>
            <span class="n">depends_on_i</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dummy</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">dummy_add</span><span class="p">]:</span>
                        <span class="n">depends_on_i</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="n">depends_on_i</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">essential_variables</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">essential_variables</span> </div>


<div class="viewcode-block" id="BooleanFunction.get_number_of_essential_variables">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_number_of_essential_variables">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_number_of_essential_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number of essential variables in a Boolean function.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - int: The number of essential variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_essential_variables</span><span class="p">())</span></div>

    
    
<div class="viewcode-block" id="BooleanFunction.get_type_of_inputs">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_type_of_inputs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_type_of_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine for each input of the Boolean function whether it is</span>
<span class="sd">        positive, negative, conditional or non-essential.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - np.ndarray[str]: The type of each input of the Boolean function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="s1">&#39;InputTypes&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;InputTypes&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="n">dummy_add</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">))</span>
                <span class="n">dummy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">))</span><span class="o">//</span><span class="n">dummy_add</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">dummy</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">dummy</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">min_diff</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
                <span class="n">max_diff</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">min_diff</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">max_diff</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;non-essential&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">min_diff</span><span class="o">==-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">max_diff</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;conditional&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">min_diff</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">max_diff</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;positive&#39;</span><span class="p">)</span>            
                <span class="k">elif</span> <span class="n">min_diff</span><span class="o">==-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">max_diff</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;negative&#39;</span><span class="p">)</span>
            <span class="n">types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;InputTypes&#39;</span><span class="p">:</span><span class="n">types</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">types</span></div>



<div class="viewcode-block" id="BooleanFunction.is_monotonic">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.is_monotonic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_monotonic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if a Boolean function is monotonic.</span>

<span class="sd">        A Boolean function is monotonic if it is monotonic in each variable. </span>
<span class="sd">        That is, if for all i=1,...,n: f(x_1, ..., x_i=0, ..., x_n) &gt;= f(x_1,</span>
<span class="sd">        ..., x_i=1, ..., x_n) for all (x_1, ..., x_n) or f(x_1, ..., x_i=0,</span>
<span class="sd">        ..., x_n) &lt;= f(x_1, ..., x_i=1, ..., x_n) for all (x_1, ..., x_n).</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - bool: True if f contains no conditional variables, False if at</span>
<span class="sd">              least one variable is conditional.</span>
<span class="sd">        &quot;&quot;&quot;</span>            
        <span class="k">return</span> <span class="s1">&#39;conditional&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type_of_inputs</span><span class="p">()</span></div>

    
    
<div class="viewcode-block" id="BooleanFunction.get_symmetry_groups">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_symmetry_groups">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_symmetry_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine all symmetry groups of input variables for a Boolean function.</span>

<span class="sd">        Two variables are in the same symmetry group if swapping their values</span>
<span class="sd">        does not change the output of the function for any input of the other</span>
<span class="sd">        variables.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - list[list[int]]: A list of lists where each inner list contains</span>
<span class="sd">              indices of variables that form a symmetry group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">symmetry_groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">left_to_check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left_to_check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">symmetry_groups</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
                <span class="n">left_to_check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">get_left_side_of_truth_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">diff</span><span class="p">]:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">left_to_check</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">symmetry_groups</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">symmetry_groups</span></div>

    
<div class="viewcode-block" id="BooleanFunction.get_absolute_bias">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_absolute_bias">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_absolute_bias</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the absolute bias of a Boolean function.</span>

<span class="sd">        The absolute bias is defined as `|(self.get_hamming_weight() /</span>
<span class="sd">        2^(n-1)) - 1|`, which quantifies how far the function&#39;s output</span>
<span class="sd">        distribution deviates from being balanced.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - float: The absolute bias of the Boolean function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_hamming_weight</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="BooleanFunction.get_average_sensitivity">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_average_sensitivity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_average_sensitivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsim</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">EXACT</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">NORMALIZED</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">rng</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the average sensitivity of a Boolean function.</span>

<span class="sd">        The average sensitivity is equivalent to the Derrida value D(F,1) when</span>
<span class="sd">        the update rule is sampled from the same space. This function can</span>
<span class="sd">        compute the exact sensitivity by exhaustively iterating over all inputs</span>
<span class="sd">        (if EXACT is True) or estimate it via Monte Carlo sampling (if EXACT</span>
<span class="sd">        is False). The result can be normalized by the number of inputs.</span>

<span class="sd">        **Parameters:**</span>
<span class="sd">            </span>
<span class="sd">            - nsim (int, optional): Number of random samples (default is 10000,</span>
<span class="sd">              used when EXACT is False).</span>
<span class="sd">            </span>
<span class="sd">            - EXACT (bool, optional): If True, compute the exact sensitivity by</span>
<span class="sd">              iterating over all inputs; otherwise, use sampling (default).</span>
<span class="sd">              </span>
<span class="sd">            - NORMALIZED (bool, optional): If True, return the normalized</span>
<span class="sd">              sensitivity (divided by the number of function inputs);</span>
<span class="sd">              otherwise, return the total count.</span>
<span class="sd">              </span>
<span class="sd">            - rng (None, optional): Argument for the random number generator,</span>
<span class="sd">              implemented in &#39;utils._coerce_rng&#39;.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - float: The (normalized) average sensitivity of the Boolean function.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">size_state_space</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">EXACT</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">X</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">get_left_side_of_truth_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">Ydec</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">Ydec</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">NORMALIZED</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span> <span class="o">/</span> <span class="p">(</span><span class="n">size_state_space</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span> <span class="o">/</span> <span class="n">size_state_space</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_coerce_rng</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsim</span><span class="p">):</span>
                <span class="n">xdec</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="n">size_state_space</span><span class="p">)</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">xdec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                <span class="n">Y</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Y</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="n">Ybin</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">Ybin</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">NORMALIZED</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span> <span class="o">/</span> <span class="n">nsim</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="n">s</span> <span class="o">/</span> <span class="n">nsim</span></div>

    
    
<div class="viewcode-block" id="BooleanFunction.is_canalizing">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.is_canalizing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_canalizing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if a Boolean function is canalizing.</span>

<span class="sd">        A Boolean function f(x_1, ..., x_n) is canalizing if there exists at</span>
<span class="sd">        least one variable x_i and a value a  {0, 1} such that f(x_1, ...,</span>
<span class="sd">        x_i = a, ..., x_n) is constant.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - bool: True if f is canalizing, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desired_value</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">]</span>
        <span class="n">Atimesf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Atimesf</span> <span class="o">==</span> <span class="n">desired_value</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Atimesf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

    
<div class="viewcode-block" id="BooleanFunction.is_k_canalizing">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.is_k_canalizing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_k_canalizing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if a Boolean function is k-canalizing.</span>

<span class="sd">        A Boolean function is k-canalizing if it has at least k conditionally</span>
<span class="sd">        canalizing variables. This is checked recursively: after fixing a</span>
<span class="sd">        canalizing variable (with a fixed canalizing input that forces the</span>
<span class="sd">        output), the subfunction (core function) must itself be canalizing for</span>
<span class="sd">        the next variable, and so on.</span>

<span class="sd">        **Parameters:**</span>
<span class="sd">            </span>
<span class="sd">            - k (int): The desired canalizing depth (0  k  n).</span>
<span class="sd">              Note: every function is 0-canalizing.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - bool: True if f is k-canalizing, False otherwise.</span>

<span class="sd">        **References:**</span>
<span class="sd">            </span>
<span class="sd">            #. He, Q., &amp; Macauley, M. (2016). Stratification and enumeration of</span>
<span class="sd">               Boolean functions by canalizing depth. Physica D: Nonlinear</span>
<span class="sd">               Phenomena, 314, 1-8.</span>
<span class="sd">            </span>
<span class="sd">            #. Dimitrova, E., Stigler, B., Kadelka, C., &amp; Murrugarra, D.</span>
<span class="sd">               (2022). Revealing the canalizing structure of Boolean functions:</span>
<span class="sd">               Algorithms and applications. Automatica, 146, 110630.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hamming_weight</span><span class="p">()</span>  <span class="c1"># Hamming weight of f</span>
        <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>  <span class="c1"># constant function</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">desired_value</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>  <span class="c1"># check for canalizing output 1</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">))</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">desired_value</span><span class="p">)</span>
            <span class="n">new_bf</span> <span class="o">=</span> <span class="n">BooleanFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">return</span> <span class="n">new_bf</span><span class="o">.</span><span class="n">is_k_canalizing</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># check for canalizing output 0</span>
                <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">))</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">desired_value</span><span class="p">)</span>
                <span class="n">new_bf</span> <span class="o">=</span> <span class="n">BooleanFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="k">return</span> <span class="n">new_bf</span><span class="o">.</span><span class="n">is_k_canalizing</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_layer_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">can_inputs</span><span class="p">,</span> <span class="n">can_outputs</span><span class="p">,</span> <span class="n">can_order</span><span class="p">,</span>
                             <span class="n">variables</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">number_layers</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Only for internal use by recursively defined get_layer_structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hamming_weight</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="p">:</span>  <span class="c1">#eventually the recursion will end here (if self.f is a constant function)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">number_layers</span><span class="p">,</span> <span class="n">can_inputs</span><span class="p">,</span> <span class="n">can_outputs</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">can_order</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">variables</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">desired_value</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">n</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">]</span>

        <span class="n">indices1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="n">desired_value</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">indices0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="n">desired_value</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sorted_order</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices1</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">indices1</span> <span class="o">%</span> <span class="n">n</span><span class="p">)[</span><span class="n">x</span><span class="p">])</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">indices1</span> <span class="o">//</span> <span class="n">n</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sorted_order</span><span class="p">)]</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">new_canalizing_variables</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">indices1</span> <span class="o">%</span> <span class="n">n</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">new_canalizing_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variables</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
            <span class="n">new_canalizing_variables</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">new_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">[]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">INPUT</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices1</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)])))]</span>
            <span class="n">new_bf</span> <span class="o">=</span> <span class="n">BooleanFunction</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_f</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">new_bf</span><span class="o">.</span><span class="n">_get_layer_structure</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">can_inputs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">can_outputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">can_order</span><span class="p">,</span> <span class="n">new_canalizing_variables</span><span class="p">),</span> <span class="n">variables</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_canalizing_variables</span><span class="p">),</span>
                               <span class="n">number_layers</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices0</span><span class="p">):</span>
            <span class="n">sorted_order</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices0</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">indices0</span> <span class="o">%</span> <span class="n">n</span><span class="p">)[</span><span class="n">x</span><span class="p">])</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">indices0</span> <span class="o">//</span> <span class="n">n</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sorted_order</span><span class="p">)]</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">new_canalizing_variables</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">indices0</span> <span class="o">%</span> <span class="n">n</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">new_canalizing_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variables</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
            <span class="n">new_canalizing_variables</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">new_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">[]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">INPUT</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices0</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)])))]</span>
            <span class="n">new_bf</span> <span class="o">=</span> <span class="n">BooleanFunction</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_f</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">new_bf</span><span class="o">.</span><span class="n">_get_layer_structure</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">can_inputs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">can_outputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">can_order</span><span class="p">,</span> <span class="n">new_canalizing_variables</span><span class="p">),</span> <span class="n">variables</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_canalizing_variables</span><span class="p">),</span>
                               <span class="n">number_layers</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1">#or the recursion will end here (if self.f is non-canalizing)</span>
        
            <span class="k">return</span> <span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">number_layers</span><span class="p">,</span> <span class="n">can_inputs</span><span class="p">,</span> <span class="n">can_outputs</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">can_order</span><span class="p">)</span>        

<div class="viewcode-block" id="BooleanFunction.get_layer_structure">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_layer_structure">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_layer_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the canalizing layer structure of a Boolean function.</span>

<span class="sd">        This function decomposes a Boolean function into its canalizing layers</span>
<span class="sd">        (standard monomial form) by recursively identifying and removing</span>
<span class="sd">        conditionally canalizing variables. The output includes the canalizing</span>
<span class="sd">        depth, the number of layers, the canalizing inputs and outputs, the</span>
<span class="sd">        core function of the non-canalizing variables, and the order of the</span>
<span class="sd">        canalizing variables.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - dict: A dictionary (self.properties) containing:</span>
<span class="sd">                </span>
<span class="sd">                - CanalizingDepth (int): Canalizing depth (number of</span>
<span class="sd">                  conditionally canalizing variables).</span>
<span class="sd">                </span>
<span class="sd">                - NumberOfLayers (int): Number of distinct canalizing layers.</span>
<span class="sd">                - CanalizingInputs (np.array[int]): Array of canalizing input</span>
<span class="sd">                  values.</span>
<span class="sd">                  </span>
<span class="sd">                - CanalizedOutputs (np.array[int]): Array of canalized output</span>
<span class="sd">                  values.</span>
<span class="sd">                  </span>
<span class="sd">                - CoreFunction (BooleanFunction): The core function (truth</span>
<span class="sd">                  table) after removing canalizing variables. Inputs:</span>
<span class="sd">                  non-canalizing variables.</span>
<span class="sd">                  </span>
<span class="sd">                - OrderOfCanalizingVariables (np.array[int]): Array of indices</span>
<span class="sd">                  representing the order of canalizing variables.</span>
<span class="sd">                  </span>
<span class="sd">                - LayerStructure (np.array[int]): Indicates the number of</span>
<span class="sd">                  variables in each canalizing layer.</span>
<span class="sd">                </span>
<span class="sd">        **References:**</span>
<span class="sd">            </span>
<span class="sd">            #. He, Q., &amp; Macauley, M. (2016). Stratification and enumeration</span>
<span class="sd">               of Boolean functions by canalizing depth. Physica D: Nonlinear</span>
<span class="sd">               Phenomena, 314, 1-8.</span>
<span class="sd">               </span>
<span class="sd">            #. Dimitrova, E., Stigler, B., Kadelka, C., &amp; Murrugarra, D.</span>
<span class="sd">               (2022). Revealing the canalizing structure of Boolean functions:</span>
<span class="sd">               Algorithms and applications. Automatica, 146, 110630.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;CanalizingDepth&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
            <span class="n">dummy</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s2">&quot;CanalizingDepth&quot;</span><span class="p">,</span> <span class="s2">&quot;NumberOfLayers&quot;</span><span class="p">,</span> <span class="s2">&quot;CanalizingInputs&quot;</span><span class="p">,</span> <span class="s2">&quot;CanalizedOutputs&quot;</span><span class="p">,</span> <span class="s2">&quot;CoreFunction&quot;</span><span class="p">,</span> <span class="s2">&quot;OrderOfCanalizingVariables&quot;</span><span class="p">],</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_get_layer_structure</span><span class="p">(</span><span class="n">can_inputs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">can_outputs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
                                                                      <span class="n">can_order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">variables</span><span class="o">=</span><span class="p">[],</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">number_layers</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
            <span class="n">dummy</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;LayerStructure&#39;</span><span class="p">:</span> <span class="n">get_layer_structure_from_canalized_outputs</span><span class="p">(</span><span class="n">dummy</span><span class="p">[</span><span class="s2">&quot;CanalizedOutputs&quot;</span><span class="p">])})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dummy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CanalizingDepth&quot;</span><span class="p">,</span> <span class="s2">&quot;NumberOfLayers&quot;</span><span class="p">,</span> <span class="s2">&quot;CanalizingInputs&quot;</span><span class="p">,</span> <span class="s2">&quot;CanalizedOutputs&quot;</span><span class="p">,</span> <span class="s2">&quot;CoreFunction&quot;</span><span class="p">,</span> <span class="s2">&quot;OrderOfCanalizingVariables&quot;</span><span class="p">,</span><span class="s1">&#39;LayerStructure&#39;</span><span class="p">]}</span></div>



<div class="viewcode-block" id="BooleanFunction.get_canalizing_depth">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_canalizing_depth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_canalizing_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the canalizing depth of the function.</span>
<span class="sd">        </span>
<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - int: The canalizing depth (number of conditionally canalizing</span>
<span class="sd">              variables).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;CanalizingDepth&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_layer_structure</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;CanalizingDepth&quot;</span><span class="p">]</span></div>


    
<div class="viewcode-block" id="BooleanFunction.get_kset_canalizing_proportion">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_kset_canalizing_proportion">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_kset_canalizing_proportion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the proportion of k-set canalizing input sets for a Boolean</span>
<span class="sd">        function.</span>

<span class="sd">        For a given k, this function calculates the probability that a randomly</span>
<span class="sd">        chosen set of k inputs canalizes the function, i.e., forces the output</span>
<span class="sd">        regardless of the remaining variables.</span>

<span class="sd">        **Parameters:**</span>
<span class="sd">            </span>
<span class="sd">            - k (int): The size of the variable set (0  k  n).</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - float: The proportion of k-set canalizing input sets.</span>

<span class="sd">        **References:**</span>
<span class="sd">            </span>
<span class="sd">            #. Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023). Collectively</span>
<span class="sd">               canalizing Boolean functions. Advances in Applied Mathematics,</span>
<span class="sd">               145, 102475.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span> <span class="ow">and</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">k</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;k must be an integer and satisfy 0 &lt;= k &lt;= degree n&quot;</span>
        
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">())</span>
        <span class="n">desired_value</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_left_side_of_truth_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Tk</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">k</span><span class="p">))</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">]</span>
        <span class="n">Ak</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">canalizing_inputs</span> <span class="ow">in</span> <span class="n">Tk</span><span class="p">:</span>
                <span class="n">indices_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">canalizing_inputs</span><span class="p">)</span>
                <span class="n">dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">indices_values</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span> <span class="o">==</span> <span class="n">desired_value</span><span class="p">:</span>
                    <span class="n">Ak</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span>
        <span class="n">Ak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ak</span><span class="p">)</span>
        <span class="n">is_there_canalization</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ak</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">desired_value</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">is_there_canalization</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">is_there_canalization</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.is_kset_canalizing">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.is_kset_canalizing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_kset_canalizing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if a Boolean function is k-set canalizing.</span>

<span class="sd">        A Boolean function is k-set canalizing if there exists a set of k</span>
<span class="sd">        variables such that setting these variables to specific values forces</span>
<span class="sd">        the output of the function, irrespective of the other n - k inputs.</span>

<span class="sd">        **Parameters:**</span>
<span class="sd">            </span>
<span class="sd">            - k (int): The size of the variable set (with 0  k  n).</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - bool: True if f is k-set canalizing, False otherwise.</span>

<span class="sd">        **References:**</span>
<span class="sd">            </span>
<span class="sd">            #. Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023). Collectively</span>
<span class="sd">               canalizing Boolean functions. Advances in Applied Mathematics,</span>
<span class="sd">               145, 102475.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_kset_canalizing_proportion</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span></div>


<div class="viewcode-block" id="BooleanFunction.get_canalizing_strength">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_canalizing_strength">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_canalizing_strength</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the canalizing strength of a Boolean function via exhaustive</span>
<span class="sd">        enumeration.</span>

<span class="sd">        The canalizing strength is defined as a weighted average of the</span>
<span class="sd">        proportions of k-set canalizing inputs for k = 1 to n-1. It is 0 for</span>
<span class="sd">        minimally canalizing functions (e.g., Boolean parity functions) and 1</span>
<span class="sd">        for maximally canalizing functions (e.g., nested canalizing functions</span>
<span class="sd">        with one layer).</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - tuple:</span>
<span class="sd">                </span>
<span class="sd">                - float: The canalizing strength of f.</span>
<span class="sd">                - list[float]: A list of the k-set canalizing proportions</span>
<span class="sd">                  for k = 1, 2, ..., n-1.</span>

<span class="sd">        **References:**</span>
<span class="sd">            </span>
<span class="sd">            #. Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023). Collectively</span>
<span class="sd">               canalizing Boolean functions. Advances in Applied Mathematics,</span>
<span class="sd">               145, 102475.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning:</span><span class="se">\n</span><span class="s2">Canalizing strength is only properly defined for Boolean functions with n &gt; 1 inputs. Returned 1 for n==1.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_kset_canalizing_proportion</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))),</span> <span class="n">res</span></div>

    
<div class="viewcode-block" id="BooleanFunction.get_input_redundancy">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_input_redundancy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_input_redundancy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. important::</span>
<span class="sd">            This method requires an installation of CANA (See</span>
<span class="sd">            `Extended Functionality`_). If CANA is not found, this method will</span>
<span class="sd">            return None.</span>
<span class="sd">        .. _Extended Functionality: https://ckadelka.github.io/BoolForge/install.html#extended-functionality</span>

<span class="sd">        Compute the input redundancy of a Boolean function.</span>

<span class="sd">        The input redundancy quantifies how many inputs are not required to</span>
<span class="sd">        determine the functions output. Constant functions have an input</span>
<span class="sd">        redundancy of 1 (none of the inputs are needed), whereas parity</span>
<span class="sd">        functions have an input redundancy of 0 (all inputs are necessary).</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - float: Normalized input redundancy in the interval [0, 1].</span>

<span class="sd">        **References:**</span>
<span class="sd">            </span>
<span class="sd">            #. Marques-Pita, M., &amp; Rocha, L. M. (2013). Canalization and</span>
<span class="sd">               control in automata networks: body segmentation in Drosophila</span>
<span class="sd">               melanogaster. PloS One, 8(3), e55946.</span>
<span class="sd">               </span>
<span class="sd">            #. Correia, R. B., Gates, A. J., Wang, X., &amp; Rocha, L. M. (2018).</span>
<span class="sd">               CANA: a python package for quantifying control and canalization</span>
<span class="sd">               in Boolean networks. Frontiers in Physiology, 9, 1046.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__LOADED_CANA__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cana</span><span class="p">()</span><span class="o">.</span><span class="n">input_redundancy</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The method </span><span class="se">\&#39;</span><span class="s1">get_input_redundancy</span><span class="se">\&#39;</span><span class="s1"> requires the module cana, which cannot be found. Ensure it is installed to use this functionality.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    
<div class="viewcode-block" id="BooleanFunction.get_edge_effectiveness">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_edge_effectiveness">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_edge_effectiveness</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. important::</span>
<span class="sd">            This method requires an installation of CANA (See</span>
<span class="sd">            `Extended Functionality`_). If CANA is not found, this method will</span>
<span class="sd">            return None.</span>
<span class="sd">        .. _Extended Functionality: https://ckadelka.github.io/BoolForge/install.html#extended-functionality</span>

<span class="sd">        Compute the edge effectiveness for each regulator of a Boolean function.</span>

<span class="sd">        Edge effectiveness measures how much flipping a given input (regulator)</span>
<span class="sd">        influences the output. Non-essential inputs have an effectiveness of 0,</span>
<span class="sd">        whereas inputs that always flip the output when toggled have an</span>
<span class="sd">        effectiveness of 1.</span>
<span class="sd">        </span>
<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - list[float]: A list of n floats in [0, 1] representing the edge</span>
<span class="sd">              effectiveness for each input.</span>

<span class="sd">        **References:**</span>
<span class="sd">            </span>
<span class="sd">            #. Marques-Pita, M., &amp; Rocha, L. M. (2013). Canalization and</span>
<span class="sd">               control in automata networks: body segmentation in Drosophila</span>
<span class="sd">               melanogaster. PloS One, 8(3), e55946.</span>
<span class="sd">               </span>
<span class="sd">            #. Correia, R. B., Gates, A. J., Wang, X., &amp; Rocha, L. M. (2018).</span>
<span class="sd">               CANA: a python package for quantifying control and canalization</span>
<span class="sd">               in Boolean networks. Frontiers in Physiology, 9, 1046.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__LOADED_CANA__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cana</span><span class="p">()</span><span class="o">.</span><span class="n">edge_effectiveness</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The method </span><span class="se">\&#39;</span><span class="s1">get_edge_effectiveness</span><span class="se">\&#39;</span><span class="s1"> requires the module cana, which cannot be found. Ensure it is installed to use this functionality.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="BooleanFunction.get_effective_degree">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_effective_degree">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_effective_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. important::</span>
<span class="sd">            This method requires an installation of CANA (See</span>
<span class="sd">            `Extended Functionality`_). If CANA is not found, this method will</span>
<span class="sd">            return None.</span>
<span class="sd">        .. _Extended Functionality: https://ckadelka.github.io/BoolForge/install.html#extended-functionality</span>
<span class="sd">        </span>
<span class="sd">        Compute the effective degree, i.e., the sum of the edge effectivenesses</span>
<span class="sd">        of each regulator, of a Boolean function.</span>

<span class="sd">        Edge effectiveness measures how much flipping a given input (regulator)</span>
<span class="sd">        influences the output. Non-essential inputs have an effectiveness of 0,</span>
<span class="sd">        whereas inputs that always flip the output when toggled have an</span>
<span class="sd">        effectiveness of 1.</span>

<span class="sd">        **Returns:**</span>
<span class="sd">            </span>
<span class="sd">            - float: The sum of the edge effectiveness of each regulator.</span>

<span class="sd">        **References:**</span>

<span class="sd">            #. Marques-Pita, M., &amp; Rocha, L. M. (2013). Canalization and</span>
<span class="sd">               control in automata networks: body segmentation in Drosophila</span>
<span class="sd">               melanogaster. PloS One, 8(3), e55946.</span>
<span class="sd">               </span>
<span class="sd">            #. Correia, R. B., Gates, A. J., Wang, X., &amp; Rocha, L. M. (2018).</span>
<span class="sd">               CANA: a python package for quantifying control and canalization</span>
<span class="sd">               in Boolean networks. Frontiers in Physiology, 9, 1046.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__LOADED_CANA__</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_edge_effectiveness</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The method </span><span class="se">\&#39;</span><span class="s1">get_effective_degree</span><span class="se">\&#39;</span><span class="s1"> requires the module cana, which cannot be found. Ensure it is installed to use this functionality.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>
</div>

    
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Claus Kadelka, Benjamin Coberly.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
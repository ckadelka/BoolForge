

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>boolforge.boolean_function &mdash; BoolForge 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../../_static/sphinx_highlight.js?v=6ffebe34"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            BoolForge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../docs.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">BoolForge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">boolforge.boolean_function</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for boolforge.boolean_function</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines the :class:`~boolforge.BooleanFunction` class, which forms</span>
<span class="sd">the foundation of the BoolForge package.</span>

<span class="sd">A :class:`BooleanFunction` represents a Boolean mapping</span>
<span class="sd">:math:`f : \\{0,1\\}^n \\rightarrow \\{0,1\\}` and provides methods for</span>
<span class="sd">evaluating, analyzing, and transforming Boolean functions. Supported operations</span>
<span class="sd">include algebraic manipulation, sensitivity and canalization analysis, truth</span>
<span class="sd">table generation, and function composition.</span>

<span class="sd">Several computationally intensive methods support optional Numba-based</span>
<span class="sd">just-in-time (JIT) acceleration to improve performance for large or repeated</span>
<span class="sd">computations. All functionality remains available without Numba, although</span>
<span class="sd">performance may be reduced.</span>

<span class="sd">This module is part of the core BoolForge library and is intended for both</span>
<span class="sd">direct programmatic use and integration with higher-level Boolean network</span>
<span class="sd">classes.</span>

<span class="sd">Example</span>
<span class="sd">-------</span>
<span class="sd">Basic usage::</span>

<span class="sd">    &gt;&gt;&gt; from boolforge import BooleanFunction</span>
<span class="sd">    &gt;&gt;&gt; f = BooleanFunction(&quot;x1 | (x2 &amp; x3)&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f([1, 0, 1])</span>
<span class="sd">    1</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># load required packages</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">boolforge.utils</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">utils</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">utils</span>


<span class="c1"># load optional packages</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pyeda.inter</span><span class="w"> </span><span class="kn">import</span> <span class="n">exprvar</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">espresso_exprs</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pyeda.boolalg.expr</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrOp</span><span class="p">,</span> <span class="n">AndOp</span><span class="p">,</span> <span class="n">NotOp</span><span class="p">,</span> <span class="n">Complement</span>
    <span class="n">__LOADED_PyEDA__</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="n">__LOADED_PyEDA__</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">cana.boolean_node</span>
    <span class="n">__LOADED_CANA__</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="n">__LOADED_CANA__</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">numba</span><span class="w"> </span><span class="kn">import</span> <span class="n">njit</span>
    <span class="n">__LOADED_NUMBA__</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="n">__LOADED_NUMBA__</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">,</span>
    <span class="s2">&quot;display_truth_table&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_layer_structure_from_canalized_outputs&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="k">if</span> <span class="n">__LOADED_NUMBA__</span><span class="p">:</span>
    <span class="nd">@njit</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_is_degenerate_numba</span><span class="p">(</span><span class="n">f</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">n</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether a Boolean function contains a non-essential variable.</span>

<span class="sd">        This Numba-accelerated helper determines whether there exists at least</span>
<span class="sd">        one input variable whose value can be flipped without affecting the</span>
<span class="sd">        output of the Boolean function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        f : np.ndarray</span>
<span class="sd">            Truth table of the Boolean function, of length ``2**n``.</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of input variables.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the function contains at least one non-essential</span>
<span class="sd">            variable, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span>  <span class="c1"># 2**n</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">stride</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">stride</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>  <span class="c1"># 2 * stride</span>
            <span class="n">depends_on_i</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Iterate in blocks that differ only in bit i</span>
            <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">stride</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">]</span> <span class="o">!=</span> <span class="n">f</span><span class="p">[</span><span class="n">base</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">stride</span><span class="p">]:</span>
                        <span class="n">depends_on_i</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">depends_on_i</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">depends_on_i</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># found non-essential variable</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="display_truth_table">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.display_truth_table">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">display_truth_table</span><span class="p">(</span><span class="o">*</span><span class="n">functions</span> <span class="p">:</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">,</span> <span class="n">labels</span> <span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Display the full truth table of one or more Boolean functions.</span>

<span class="sd">    Each row displays an input configuration ``(x1, ..., xn)`` together with</span>
<span class="sd">    the corresponding output values of the provided Boolean functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *functions : BooleanFunction</span>
<span class="sd">        One or more BooleanFunction objects with the same number of input</span>
<span class="sd">        variables.</span>
<span class="sd">    labels : Sequence[str] or None, optional</span>
<span class="sd">        Column labels for the Boolean functions. If ``None`` (default), labels</span>
<span class="sd">        are generated automatically as ``f0, f1, ...``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If no Boolean functions are provided, if the functions do not all have</span>
<span class="sd">        the same number of variables, or if the number of labels does not match</span>
<span class="sd">        the number of functions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; f = BooleanFunction(&quot;(x1 &amp; ~x2) | x3&quot;)</span>
<span class="sd">    &gt;&gt;&gt; display_truth_table(f)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">functions</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please provide at least one BooleanFunction.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">n</span> <span class="o">!=</span> <span class="n">n</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All BooleanFunction objects must have the same number of variables.&quot;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">functions</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of labels (if provided) must equal the number of functions.&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">variables</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">]):</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">n</span><span class="p">)])</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;x</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">n</span><span class="p">)])</span> 
    <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;f</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">functions</span><span class="p">))]</span>
    <span class="n">header</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">|</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()))</span>

    <span class="k">for</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">get_left_side_of_truth_table</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> 
                               <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">])):</span>
        <span class="n">inputs_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">inputs</span><span class="p">))</span>
        <span class="n">outputs_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">outputs</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs_str</span><span class="si">}</span><span class="se">\t</span><span class="s2">|</span><span class="se">\t</span><span class="si">{</span><span class="n">outputs_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_layer_structure_from_canalized_outputs">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.get_layer_structure_from_canalized_outputs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_layer_structure_from_canalized_outputs</span><span class="p">(</span>
        <span class="n">can_outputs</span> <span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the canalizing layer structure from canalized outputs.</span>

<span class="sd">    Consecutive identical canalized output values are grouped into the same</span>
<span class="sd">    canalizing layer. The size of each layer corresponds to the number of</span>
<span class="sd">    variables in that layer.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    can_outputs : Sequence[int]</span>
<span class="sd">        Sequence of canalized output values in the order in which canalizing</span>
<span class="sd">        variables are identified.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[int]</span>
<span class="sd">        List specifying the number of variables in each canalizing layer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">canalizing_depth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">can_outputs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">canalizing_depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">size_of_layer</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">layer_structure</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">canalizing_depth</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">can_outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">can_outputs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">size_of_layer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">layer_structure</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size_of_layer</span><span class="p">)</span>
            <span class="n">size_of_layer</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">layer_structure</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size_of_layer</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">layer_structure</span></div>



<div class="viewcode-block" id="BooleanFunction">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BooleanFunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Boolean function.</span>

<span class="sd">    This class represents a Boolean function</span>
<span class="sd">    :math:`f : \\{0,1\\}^n \\to \\{0,1\\}` and stores its truth table together</span>
<span class="sd">    with variable names and optional metadata.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : list[int] | np.ndarray | str</span>
<span class="sd">        Truth table of length ``2**n`` representing the outputs of a Boolean</span>
<span class="sd">        function with ``n`` inputs, or a Boolean expression string that can be</span>
<span class="sd">        evaluated. Expression strings are parsed using</span>
<span class="sd">        ``utils.f_from_expression``.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        Name of the node regulated by the Boolean function. Default is ``&quot;&quot;``.</span>
<span class="sd">    variables : list[str] | np.ndarray | None, optional</span>
<span class="sd">        Names of the input variables, given in order. Must have length ``n``.</span>
<span class="sd">        If ``None`` (default), variables are named ``x0, ..., x_{n-1}``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    f : np.ndarray</span>
<span class="sd">        NumPy array of dtype ``uint8`` and length ``2**n`` containing only the</span>
<span class="sd">        values 0 and 1, representing the truth table of the Boolean function.</span>
<span class="sd">    n : int</span>
<span class="sd">        Number of input variables.</span>
<span class="sd">    variables : np.ndarray</span>
<span class="sd">        One-dimensional NumPy array of length ``n`` containing variable names.</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of the node regulated by the Boolean function.</span>
<span class="sd">    properties : dict</span>
<span class="sd">        Dictionary for dynamically computed properties of the Boolean function</span>
<span class="sd">        (e.g., canalizing structure, effective inputs, robustness measures).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">,</span><span class="s1">&#39;variables&#39;</span><span class="p">,</span><span class="s1">&#39;name&#39;</span><span class="p">,</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> 
            <span class="n">f</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">variables</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">name</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a Boolean function.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        f : list[int] or np.ndarray or str</span>
<span class="sd">            Truth table of the Boolean function, given as a list or array</span>
<span class="sd">            of length ``2**n``, or a Boolean expression as a string.</span>
<span class="sd">        variables : list[str] or np.ndarray[str], optional</span>
<span class="sd">            Names of the input variables. Must have length ``n`` if provided.</span>
<span class="sd">            If None, default variable names x0, x1, ... are assigned.</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            Optional name of the Boolean function.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The number of inputs ``n`` is inferred from the length of ``f``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">f_from_expression</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;f must be a list, numpy array or interpretable string&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;f cannot be empty&quot;</span><span class="p">)</span>
            
            <span class="n">_n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="o">-</span> <span class="n">_n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;f must be of size 2^n, n &gt;= 0&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;x</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_n</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;variables must be a 1D array of strings&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_n</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;variables must have length </span><span class="si">{</span><span class="n">_n</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;f must contain only the values 0 and 1.&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_from_f_unchecked</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> 
        <span class="n">f</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
        <span class="o">*</span><span class="p">,</span> 
        <span class="n">variables</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
        <span class="n">name</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a BooleanFunction directly from a truth table *without*</span>
<span class="sd">        validating invariants.</span>
<span class="sd">    </span>
<span class="sd">        This internal constructor bypasses all safety checks and therefore</span>
<span class="sd">        assumes that the input truth table already satisfies all BooleanFunction</span>
<span class="sd">        invariants. In particular, it assumes that:</span>
<span class="sd">    </span>
<span class="sd">            - ``f`` has length ``2**n`` for some integer ``n``,</span>
<span class="sd">            - all entries of ``f`` are in ``{0,1}``,</span>
<span class="sd">            - ``f`` is already in a NumPy-compatible array-like format.</span>
<span class="sd">    </span>
<span class="sd">        This method exists for **performance-critical internal code paths**</span>
<span class="sd">        such as random Boolean function generation, bulk construction, or</span>
<span class="sd">        Numba-accelerated routines, where invariant checks would be prohibitively</span>
<span class="sd">        expensive and correctness is guaranteed by construction.</span>
<span class="sd">    </span>
<span class="sd">        **Warning**</span>
<span class="sd">        -------</span>
<span class="sd">        This method must *never* be called on untrusted input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
    
        <span class="c1"># Core data</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">f</span><span class="p">)))</span>
    
        <span class="c1"># Metadata (match __init__ invariants)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;x</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">n</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
    
        <span class="n">obj</span><span class="o">.</span><span class="n">properties</span> <span class="o">=</span> <span class="p">{}</span>
    
        <span class="k">return</span> <span class="n">obj</span>

<div class="viewcode-block" id="BooleanFunction.from_cana">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.from_cana">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_cana</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">cana_BooleanNode</span><span class="p">:</span> <span class="s2">&quot;cana.boolean_node.BooleanNode&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a BoolForge BooleanFunction from a CANA BooleanNode.</span>
<span class="sd">    </span>
<span class="sd">        This compatibility method converts a</span>
<span class="sd">        ``cana.boolean_node.BooleanNode`` instance into a BoolForge</span>
<span class="sd">        ``BooleanFunction`` by extracting its truth table representation.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cana_BooleanNode : cana.boolean_node.BooleanNode</span>
<span class="sd">            Boolean node object from the CANA library.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BooleanFunction</span>
<span class="sd">            A BoolForge BooleanFunction instance with the same truth table</span>
<span class="sd">            as the input CANA BooleanNode.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is intended for interoperability with the CANA package.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cana_BooleanNode</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span></div>

    
    <span class="c1">## Magic methods:</span>
    
<div class="viewcode-block" id="BooleanFunction.__str__">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.__str__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a human-readable string representation of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        This method returns the underlying truth table as a NumPy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="si">}</span><span class="s2">&quot;</span></div>

        <span class="c1">#return f&quot;{self.f.tolist()}&quot;</span>
    
<div class="viewcode-block" id="BooleanFunction.__repr__">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.__repr__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an unambiguous string representation of the BooleanFunction.</span>
<span class="sd">    </span>
<span class="sd">        For small functions (``n &lt; 6``), the full truth table is shown.</span>
<span class="sd">        For larger functions, only the number of inputs is displayed to</span>
<span class="sd">        avoid excessive output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(f=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(n=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s2">)&quot;</span></div>

    
    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    
<div class="viewcode-block" id="BooleanFunction.__mul__">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.__mul__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Element-wise Boolean multiplication (logical AND).</span>
<span class="sd">    </span>
<span class="sd">        This method implements logical AND between Boolean functions or between</span>
<span class="sd">        a Boolean function and a scalar value in ``{0,1}``.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : BooleanFunction or int</span>
<span class="sd">            BooleanFunction of the same size or an integer value (0 or 1).</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BooleanFunction</span>
<span class="sd">            Result of element-wise Boolean multiplication.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Integer multiplier must be 0 or 1.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">*</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">BooleanFunction</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">*</span> <span class="n">value</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupported operand type(s) for *: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;BooleanFunction&#39; and &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span></div>



<div class="viewcode-block" id="BooleanFunction.__rmul__">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.__rmul__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Right-hand element-wise Boolean multiplication (logical AND).</span>
<span class="sd">    </span>
<span class="sd">        This method enables expressions of the form ``value * BooleanFunction``</span>
<span class="sd">        where ``value`` is an integer in ``{0,1}``.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : int</span>
<span class="sd">            Integer value (0 or 1).</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BooleanFunction</span>
<span class="sd">            Result of element-wise Boolean multiplication.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>


    
<div class="viewcode-block" id="BooleanFunction.__and__">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.__and__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Element-wise logical AND.</span>
<span class="sd">    </span>
<span class="sd">        This method implements element-wise logical AND between Boolean</span>
<span class="sd">        functions or between a Boolean function and a scalar value in ``{0,1}``.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : BooleanFunction or int</span>
<span class="sd">            BooleanFunction of the same size or an integer value (0 or 1).</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BooleanFunction</span>
<span class="sd">            Result of element-wise logical AND.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Integer must be 0 or 1.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">BooleanFunction</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">&amp;</span> <span class="n">value</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupported operand type(s) for &amp;: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;BooleanFunction&#39; and &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.__or__">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.__or__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Element-wise logical OR.</span>
<span class="sd">    </span>
<span class="sd">        This method implements element-wise logical OR between Boolean</span>
<span class="sd">        functions or between a Boolean function and a scalar value in ``{0,1}``.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : BooleanFunction or int</span>
<span class="sd">            BooleanFunction of the same size or an integer value (0 or 1).</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BooleanFunction</span>
<span class="sd">            Result of element-wise logical OR.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Integer must be 0 or 1.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">|</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">BooleanFunction</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">|</span> <span class="n">value</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupported operand type(s) for |: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;BooleanFunction&#39; and &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span></div>

    
    
<div class="viewcode-block" id="BooleanFunction.__xor__">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.__xor__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Element-wise logical XOR.</span>
<span class="sd">    </span>
<span class="sd">        This method implements element-wise logical XOR between Boolean</span>
<span class="sd">        functions or between a Boolean function and a scalar value in ``{0,1}``.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : BooleanFunction or int</span>
<span class="sd">            BooleanFunction of the same size or an integer value (0 or 1).</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BooleanFunction</span>
<span class="sd">            Result of element-wise logical XOR.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Integer must be 0 or 1.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">^</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">BooleanFunction</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">^</span> <span class="n">value</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupported operand type(s) for ^: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;BooleanFunction&#39; and &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span></div>



<div class="viewcode-block" id="BooleanFunction.__invert__">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.__invert__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Element-wise logical negation.</span>
<span class="sd">    </span>
<span class="sd">        This method computes the logical NOT of the Boolean function by</span>
<span class="sd">        flipping all truth table entries.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BooleanFunction</span>
<span class="sd">            Result of element-wise logical negation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span></div>

    
    
<div class="viewcode-block" id="BooleanFunction.__call__">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.__call__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the Boolean function on a given input vector.</span>
<span class="sd">    </span>
<span class="sd">        This method makes BooleanFunction instances callable and returns the</span>
<span class="sd">        output value for a specified binary input configuration.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : list[int] | tuple[int, ...] | np.ndarray</span>
<span class="sd">            Sequence of binary values (0 or 1) of length ``n``, where ``n`` is</span>
<span class="sd">            the number of input variables of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Output value of the Boolean function (0 or 1) for the specified input.</span>
<span class="sd">    </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the input length does not match ``n`` or if non-binary values are</span>
<span class="sd">            provided.</span>
<span class="sd">    </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; f = BooleanFunction(&quot;x1 | (x2 &amp; x3)&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f([1, 0, 1])</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; f([0, 1, 0])</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The argument must be of length </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Binary values required.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">values</span><span class="p">)]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span></div>

    <span class="c1">## Conversions:</span>
    

<div class="viewcode-block" id="BooleanFunction.to_polynomial">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.to_polynomial">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the Boolean function to a polynomial representation.</span>
<span class="sd">    </span>
<span class="sd">        This method returns a polynomial representation of the Boolean function</span>
<span class="sd">        in non-reduced disjunctive normal form (DNF).</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            Polynomial representation of the Boolean function in non-reduced DNF.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">bool_to_poly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span></div>



<div class="viewcode-block" id="BooleanFunction.to_truth_table">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.to_truth_table">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_truth_table</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">RETURN</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return or save the full truth table of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        The truth table is represented as a pandas DataFrame in which each row</span>
<span class="sd">        corresponds to an input configuration and the final column contains the</span>
<span class="sd">        output value of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        RETURN : bool, optional</span>
<span class="sd">            Whether to return the truth table as a DataFrame. If ``False``, the</span>
<span class="sd">            truth table is only written to file when ``filename`` is provided.</span>
<span class="sd">            Default is ``True``.</span>
<span class="sd">        filename : str or None, optional</span>
<span class="sd">            File name (including extension) to which the truth table is saved.</span>
<span class="sd">            Supported formats are ``&#39;csv&#39;``, ``&#39;xls&#39;``, and ``&#39;xlsx&#39;``. If</span>
<span class="sd">            provided, the truth table is automatically written to disk.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame or None</span>
<span class="sd">            The full truth table if ``RETURN=True``; otherwise ``None``.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The column names correspond to the input variable names followed by the</span>
<span class="sd">        function name if provided, or ``&#39;f&#39;`` otherwise. When saving to a file,</span>
<span class="sd">        the output format is determined by the file extension.</span>
<span class="sd">    </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; f = BooleanFunction(&quot;(x1 &amp; ~x2) | x3&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f.to_truth_table()</span>
<span class="sd">           x1  x2  x3  f</span>
<span class="sd">        0   0   0   0  0</span>
<span class="sd">        1   0   0   1  1</span>
<span class="sd">        2   0   1   0  0</span>
<span class="sd">        3   0   1   1  1</span>
<span class="sd">        4   1   0   0  1</span>
<span class="sd">        5   1   0   1  1</span>
<span class="sd">        6   1   1   0  0</span>
<span class="sd">        7   1   1   1  1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
        <span class="n">truth_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">utils</span><span class="o">.</span><span class="n">get_left_side_of_truth_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">],</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
        <span class="p">)</span>
    
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ending</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ending</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;csv&quot;</span><span class="p">,</span> <span class="s2">&quot;xls&quot;</span><span class="p">,</span> <span class="s2">&quot;xlsx&quot;</span><span class="p">}:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;filename must end in &#39;csv&#39;, &#39;xls&#39;, or &#39;xlsx&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ending</span> <span class="o">==</span> <span class="s2">&quot;csv&quot;</span><span class="p">:</span>
                <span class="n">truth_table</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">truth_table</span><span class="o">.</span><span class="n">to_excel</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">RETURN</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">truth_table</span>
        <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="BooleanFunction.to_cana">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.to_cana">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_cana</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;cana.boolean_node.BooleanNode&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the BooleanFunction to a CANA BooleanNode.</span>
<span class="sd">    </span>
<span class="sd">        This compatibility method constructs and returns a</span>
<span class="sd">        ``cana.boolean_node.BooleanNode`` instance corresponding to the</span>
<span class="sd">        Boolean function represented by this object.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cana.boolean_node.BooleanNode</span>
<span class="sd">            Boolean node object from the CANA library representing the same</span>
<span class="sd">            Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ImportError</span>
<span class="sd">            If the CANA package is not installed.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method requires the CANA package to be installed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">__LOADED_CANA__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;CANA is required for to_cana()&quot;</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">cana</span><span class="o">.</span><span class="n">boolean_node</span><span class="o">.</span><span class="n">BooleanNode</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span></div>

    
    
<div class="viewcode-block" id="BooleanFunction.to_logical">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.to_logical">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_logical</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">AND</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&amp;&quot;</span><span class="p">,</span>
        <span class="n">OR</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="p">,</span>
        <span class="n">NOT</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;!&quot;</span><span class="p">,</span>
        <span class="n">MINIMIZE_EXPRESSION</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the Boolean function to a logical expression.</span>
<span class="sd">    </span>
<span class="sd">        This method converts the Boolean function from its truth table</span>
<span class="sd">        representation to a logical expression. If the PyEDA package is</span>
<span class="sd">        available, the expression can optionally be minimized using the</span>
<span class="sd">        Espresso algorithm. Otherwise, a non-minimized expression is</span>
<span class="sd">        generated as a fallback.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        AND : str, optional</span>
<span class="sd">            String used to represent the logical AND operator. Default is ``&quot;&amp;&quot;``.</span>
<span class="sd">        OR : str, optional</span>
<span class="sd">            String used to represent the logical OR operator. Default is ``&quot;|&quot;``.</span>
<span class="sd">        NOT : str, optional</span>
<span class="sd">            String used to represent the logical NOT operator. Default is ``&quot;!&quot;``.</span>
<span class="sd">        MINIMIZE_EXPRESSION : bool, optional</span>
<span class="sd">            Whether to minimize the logical expression using the Espresso</span>
<span class="sd">            algorithm (via PyEDA). If ``False``, the expression is returned</span>
<span class="sd">            in non-minimized disjunctive normal form. Default is ``True``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            Logical expression representing the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the PyEDA package is not installed, the method falls back to a</span>
<span class="sd">        non-minimized expression derived from the polynomial representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__LOADED_PyEDA__</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">exprvar</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">))</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">]</span>
            <span class="n">minterms</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    
            <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">minterms</span><span class="p">:</span>
                <span class="n">bits</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span>
                    <span class="k">else</span> <span class="o">~</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="n">bits</span><span class="p">))</span>
    
            <span class="n">func_expr</span> <span class="o">=</span> <span class="n">Or</span><span class="p">(</span><span class="o">*</span><span class="n">terms</span><span class="p">)</span><span class="o">.</span><span class="n">to_dnf</span><span class="p">()</span>
    
            <span class="k">if</span> <span class="n">func_expr</span><span class="o">.</span><span class="n">is_zero</span><span class="p">():</span>
                <span class="k">return</span> <span class="s2">&quot;0&quot;</span>
    
            <span class="k">if</span> <span class="n">MINIMIZE_EXPRESSION</span><span class="p">:</span>
                <span class="n">func_expr</span><span class="p">,</span> <span class="o">=</span> <span class="n">espresso_exprs</span><span class="p">(</span><span class="n">func_expr</span><span class="p">)</span>
    
            <span class="k">def</span><span class="w"> </span><span class="nf">__pyeda_to_string__</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">OrOp</span><span class="p">):</span>
                    <span class="k">return</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;)</span><span class="si">{</span><span class="n">OR</span><span class="si">}</span><span class="s2">(&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">__pyeda_to_string__</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">xs</span>
                    <span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">AndOp</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">AND</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">__pyeda_to_string__</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">xs</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">NotOp</span><span class="p">):</span>
                    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">NOT</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">__pyeda_to_string__</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Complement</span><span class="p">):</span>
                    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">NOT</span><span class="si">}{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    
            <span class="k">return</span> <span class="n">__pyeda_to_string__</span><span class="p">(</span><span class="n">func_expr</span><span class="p">)</span>
    
        <span class="c1"># Fallback without PyEDA</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_polynomial</span><span class="p">()</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; * &quot;</span><span class="p">,</span> <span class="n">AND</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; + &quot;</span><span class="p">,</span> <span class="n">OR</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;1 - &quot;</span><span class="p">,</span> <span class="n">NOT</span><span class="p">)</span>
        <span class="p">)</span></div>


    
<div class="viewcode-block" id="BooleanFunction.summary">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">AS_DICT</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPUTE_ALL</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a concise summary of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        The summary includes basic structural and statistical properties of the</span>
<span class="sd">        Boolean function and, optionally, additional properties that may require</span>
<span class="sd">        nontrivial computation.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        AS_DICT : bool, optional</span>
<span class="sd">            If ``True``, return the summary as a dictionary. If ``False`` (default),</span>
<span class="sd">            return a formatted string.</span>
<span class="sd">    </span>
<span class="sd">        COMPUTE_ALL : bool, optional</span>
<span class="sd">            If ``True``, additional properties are computed and included in the</span>
<span class="sd">            summary. These computations may be expensive. If ``False`` (default),</span>
<span class="sd">            only already available properties are included.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str or dict</span>
<span class="sd">            Summary of the Boolean function, either as a formatted string or as</span>
<span class="sd">            a dictionary depending on the value of ``AS_DICT``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="n">ones</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
        <span class="n">bias</span> <span class="o">=</span> <span class="n">ones</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">abs_bias</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bias</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">summary</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Number of variables&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span>
            <span class="s2">&quot;Hamming Weight&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">ones</span><span class="p">),</span>
            <span class="s2">&quot;Bias&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">bias</span><span class="p">),</span>
            <span class="s2">&quot;Absolute bias&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">abs_bias</span><span class="p">),</span>
            <span class="s2">&quot;Variables&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span>
        <span class="p">}</span>
    
        <span class="c1"># Optional properties (only if already computed / cached)</span>
        <span class="k">if</span> <span class="n">COMPUTE_ALL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_layer_structure</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_type_of_inputs</span><span class="p">()</span>
            
        <span class="n">summary</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">AS_DICT</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">summary</span>
    
        <span class="c1"># Pretty formatting</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;BooleanFunction summary&quot;</span><span class="p">,</span>
            <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">40</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Number of variables:        </span><span class="si">{</span><span class="n">summary</span><span class="p">[</span><span class="s1">&#39;Number of variables&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Hamming Weight:             </span><span class="si">{</span><span class="n">summary</span><span class="p">[</span><span class="s1">&#39;Hamming Weight&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Bias:                       </span><span class="si">{</span><span class="n">summary</span><span class="p">[</span><span class="s1">&#39;Bias&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Absolute bias:              </span><span class="si">{</span><span class="n">summary</span><span class="p">[</span><span class="s1">&#39;Absolute bias&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Variables:                  </span><span class="si">{</span><span class="n">summary</span><span class="p">[</span><span class="s1">&#39;Variables&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">]</span>
    
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">summary</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span>
                <span class="s2">&quot;Number of variables&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Hamming Weight&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Bias&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Absolute bias&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Variables&quot;</span>
            <span class="p">}:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">:&quot;</span><span class="o">+</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">*</span><span class="p">(</span><span class="mi">27</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)))</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">summary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>


    
<div class="viewcode-block" id="BooleanFunction.is_constant">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.is_constant">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether the Boolean function is constant.</span>
<span class="sd">    </span>
<span class="sd">        A Boolean function is constant if all entries of its truth table are</span>
<span class="sd">        identical (all 0 or all 1).</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the Boolean function is constant, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span></div>

        
<div class="viewcode-block" id="BooleanFunction.is_degenerate">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.is_degenerate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_degenerate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">USE_NUMBA</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether the Boolean function is degenerate.</span>
<span class="sd">    </span>
<span class="sd">        A Boolean function is degenerate if it contains at least one</span>
<span class="sd">        non-essential variable, i.e., a variable on which the function&#39;s</span>
<span class="sd">        output does not depend.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        USE_NUMBA : bool, optional</span>
<span class="sd">            Whether to use Numba-accelerated computation when available.</span>
<span class="sd">            Default is ``True``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the Boolean function contains at least one</span>
<span class="sd">            non-essential variable, ``False`` if all variables are essential.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__LOADED_NUMBA__</span> <span class="ow">and</span> <span class="n">USE_NUMBA</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">_is_degenerate_numba</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="n">dummy_add</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">))</span> <span class="o">//</span> <span class="n">dummy_add</span>
                <span class="n">depends_on_i</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">dummy</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">dummy_add</span><span class="p">]:</span>
                            <span class="n">depends_on_i</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">depends_on_i</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span></div>

        
        
<div class="viewcode-block" id="BooleanFunction.is_monotonic">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.is_monotonic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_monotonic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether the Boolean function is monotonic.</span>
<span class="sd">    </span>
<span class="sd">        A Boolean function is monotonic if it is monotonic in each variable,</span>
<span class="sd">        i.e., for every variable the function is either non-decreasing or</span>
<span class="sd">        non-increasing with respect to that variable.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the Boolean function is monotonic, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;conditional&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type_of_inputs</span><span class="p">()</span></div>

    
    
<div class="viewcode-block" id="BooleanFunction.is_canalizing">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.is_canalizing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_canalizing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether the Boolean function is canalizing.</span>
<span class="sd">    </span>
<span class="sd">        A Boolean function is canalizing if there exists at least one variable</span>
<span class="sd">        and a value in ``{0,1}`` such that fixing that variable to the given</span>
<span class="sd">        value forces the output of the function to be constant.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the Boolean function is canalizing, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>
            <span class="n">bit_is_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">bit_is_1</span> <span class="o">=</span> <span class="o">~</span><span class="n">bit_is_0</span>
    
            <span class="n">f0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">bit_is_0</span><span class="p">]</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">bit_is_1</span><span class="p">]</span>
    
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">f0</span> <span class="o">==</span> <span class="n">f0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">f1</span> <span class="o">==</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">return</span> <span class="kc">True</span>
    
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="BooleanFunction.is_k_canalizing">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.is_k_canalizing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_k_canalizing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether the Boolean function is k-canalizing.</span>
<span class="sd">    </span>
<span class="sd">        A Boolean function is k-canalizing if it has a sequence of at least</span>
<span class="sd">        ``k`` canalizing variables. After fixing a canalizing variable to its</span>
<span class="sd">        canalizing value, the resulting subfunction must itself be</span>
<span class="sd">        (k1)-canalizing, recursively.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int</span>
<span class="sd">            Desired canalizing depth, with ``0 &lt;= k &lt;= n``. Every Boolean</span>
<span class="sd">            function is trivially 0-canalizing.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the Boolean function is k-canalizing, ``False`` otherwise.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method has exponential time complexity in ``n`` and is intended for</span>
<span class="sd">        small Boolean functions.</span>
<span class="sd">    </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        He, Q., &amp; Macauley, M. (2016).</span>
<span class="sd">            Stratification and enumeration of Boolean functions by canalizing depth.</span>
<span class="sd">            *Physica D: Nonlinear Phenomena*, 314, 18.</span>
<span class="sd">    </span>
<span class="sd">        Dimitrova, E., Stigler, B., Kadelka, C., &amp; Murrugarra, D. (2022).</span>
<span class="sd">            Revealing the canalizing structure of Boolean functions:</span>
<span class="sd">            Algorithms and applications.</span>
<span class="sd">            *Automatica*, 146, 110630.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">False</span>
    
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>
            <span class="n">bit_is_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">bit_is_1</span> <span class="o">=</span> <span class="o">~</span><span class="n">bit_is_0</span>
    
            <span class="n">f0</span><span class="p">,</span> <span class="n">f1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">bit_is_0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">bit_is_1</span><span class="p">]</span>
    
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">f0</span> <span class="o">==</span> <span class="n">f0</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">BooleanFunction</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span><span class="o">.</span><span class="n">is_k_canalizing</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">f1</span> <span class="o">==</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">BooleanFunction</span><span class="p">(</span><span class="n">f0</span><span class="p">)</span><span class="o">.</span><span class="n">is_k_canalizing</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="BooleanFunction.is_kset_canalizing">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.is_kset_canalizing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_kset_canalizing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether the Boolean function is k-set canalizing.</span>
<span class="sd">    </span>
<span class="sd">        A Boolean function is k-set canalizing if there exists a set of ``k``</span>
<span class="sd">        variables such that fixing these variables to specific values forces</span>
<span class="sd">        the output of the function, regardless of the remaining ``n - k``</span>
<span class="sd">        variables.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int</span>
<span class="sd">            Size of the variable set, with ``0 &lt;= k &lt;= n``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the Boolean function is k-set canalizing, ``False`` otherwise.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method has exponential time complexity in ``n`` and is intended for</span>
<span class="sd">        small Boolean functions.</span>
<span class="sd">    </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023).</span>
<span class="sd">            Collectively canalizing Boolean functions.</span>
<span class="sd">            *Advances in Applied Mathematics*, 145, 102475.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_kset_canalizing_proportion</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span></div>



    <span class="c1">## Methods with non-binary output</span>

<div class="viewcode-block" id="BooleanFunction.get_hamming_weight">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_hamming_weight">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_hamming_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Hamming weight of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        The Hamming weight is the number of input states for which the function</span>
<span class="sd">        evaluates to ``1`` (i.e., the number of ones in the truth table).</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The Hamming weight of the Boolean function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span></div>

        
    
<div class="viewcode-block" id="BooleanFunction.get_essential_variables">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_essential_variables">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_essential_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the essential variables of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        A variable ``x_i`` is essential if there exists at least one assignment of</span>
<span class="sd">        the remaining variables such that flipping ``x_i`` changes the output of</span>
<span class="sd">        the function.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list[int]</span>
<span class="sd">            Indices of all essential variables. If the truth table is empty, returns</span>
<span class="sd">            an empty list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">essential_variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">dummy_add</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">))</span>
            <span class="n">dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">))</span> <span class="o">//</span> <span class="n">dummy_add</span>
            <span class="n">depends_on_i</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dummy</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">dummy_add</span><span class="p">]:</span>
                        <span class="n">depends_on_i</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="n">depends_on_i</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">essential_variables</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">essential_variables</span> </div>


<div class="viewcode-block" id="BooleanFunction.get_number_of_essential_variables">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_number_of_essential_variables">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_number_of_essential_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number of essential variables of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of essential variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_essential_variables</span><span class="p">())</span></div>

    
    
<div class="viewcode-block" id="BooleanFunction.get_type_of_inputs">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_type_of_inputs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_type_of_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classify each input variable of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        Each variable is classified as one of:</span>
<span class="sd">    </span>
<span class="sd">        - ``&#39;positive&#39;``: flipping the variable from 0 to 1 never decreases the output</span>
<span class="sd">        - ``&#39;negative&#39;``: flipping the variable from 0 to 1 never increases the output</span>
<span class="sd">        - ``&#39;conditional&#39;``: flipping the variable can both increase and decrease the output</span>
<span class="sd">        - ``&#39;non-essential&#39;``: flipping the variable never changes the output</span>
<span class="sd">    </span>
<span class="sd">        The result is cached in ``self.properties[&#39;InputTypes&#39;]``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Array of shape ``(n,)`` with dtype ``str`` giving the type of each input</span>
<span class="sd">            variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;InputTypes&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;InputTypes&#39;</span><span class="p">]</span>
    
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    
        <span class="c1"># Compute all pairwise differences for each bit position simultaneously</span>
        <span class="c1"># Each variable toggles every 2**i entries in the truth table.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">period</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">half</span> <span class="o">=</span> <span class="n">period</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="c1"># Vectorized reshape pattern: consecutive blocks of 0...1 transitions</span>
            <span class="n">f_reshaped</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">period</span><span class="p">)</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">f_reshaped</span><span class="p">[:,</span> <span class="n">half</span><span class="p">:]</span> <span class="o">-</span> <span class="n">f_reshaped</span><span class="p">[:,</span> <span class="p">:</span><span class="n">half</span><span class="p">]</span>
            <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">max_diff</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">min_diff</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">max_diff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;non-essential&#39;</span>
            <span class="k">elif</span> <span class="n">min_diff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">max_diff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;conditional&#39;</span>
            <span class="k">elif</span> <span class="n">min_diff</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">max_diff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;positive&#39;</span>
            <span class="k">elif</span> <span class="n">min_diff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">max_diff</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;negative&#39;</span>
    
        <span class="n">types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;InputTypes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">types</span>
        <span class="k">return</span> <span class="n">types</span></div>



    
<div class="viewcode-block" id="BooleanFunction.get_symmetry_groups">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_symmetry_groups">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_symmetry_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify symmetry groups of input variables.</span>
<span class="sd">    </span>
<span class="sd">        Two variables belong to the same symmetry group if swapping their values</span>
<span class="sd">        leaves the Boolean function invariant for all assignments of the remaining</span>
<span class="sd">        variables.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list[list[int]]</span>
<span class="sd">            A list of symmetry groups, where each group is given by a list of</span>
<span class="sd">            variable indices.</span>
<span class="sd">            </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method has exponential time complexity in ``n`` and is intended for</span>
<span class="sd">        small Boolean functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">symmetry_groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">left_to_check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left_to_check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">symmetry_groups</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
                <span class="n">left_to_check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">get_left_side_of_truth_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">diff</span><span class="p">]:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">left_to_check</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">symmetry_groups</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">symmetry_groups</span></div>

    
<div class="viewcode-block" id="BooleanFunction.get_absolute_bias">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_absolute_bias">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_absolute_bias</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the absolute bias of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        The absolute bias is defined as</span>
<span class="sd">    </span>
<span class="sd">        ``| (H / 2**(n-1)) - 1 |``,</span>
<span class="sd">    </span>
<span class="sd">        where ``H`` is the Hamming weight of the function. It measures how far the</span>
<span class="sd">        output distribution deviates from being perfectly balanced.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The absolute bias of the Boolean function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_hamming_weight</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span></div>



<div class="viewcode-block" id="BooleanFunction.get_activities">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_activities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_activities</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nsim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
        <span class="n">EXACT</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">rng</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the activities of all input variables.</span>
<span class="sd">    </span>
<span class="sd">        The activity of a variable is the probability that flipping this variable</span>
<span class="sd">        (while keeping all others fixed) changes the output of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        Activities can be computed exactly by enumerating all ``2**n`` input states</span>
<span class="sd">        or estimated via Monte Carlo sampling.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsim : int, optional</span>
<span class="sd">            Number of random samples used when ``EXACT=False`` (default: 10000).</span>
<span class="sd">        EXACT : bool, optional</span>
<span class="sd">            If ``True``, compute activities exactly by enumerating all input states.</span>
<span class="sd">            If ``False``, estimate activities via sampling (default: ``False``).</span>
<span class="sd">        rng : None or numpy.random.Generator, optional</span>
<span class="sd">            Random number generator passed to ``utils._coerce_rng``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Array of shape ``(n,)`` containing the activities of all variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>     
        <span class="n">size_state_space</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">activities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">EXACT</span><span class="p">:</span>
            <span class="c1"># Compute all integer representations of inputs (0 .. 2^n - 1)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">size_state_space</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        
            <span class="c1"># For each bit position i, flipping that bit corresponds to XOR with (1 &lt;&lt; self.n-1-i)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="n">flipped</span> <span class="o">=</span> <span class="n">X</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> 
                <span class="n">activities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">flipped</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">activities</span> <span class="o">/</span> <span class="n">size_state_space</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_coerce_rng</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>

            <span class="n">random_states</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">size_state_space</span><span class="p">,</span><span class="n">nsim</span><span class="p">)</span> <span class="c1">#</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="n">flipped_random_states</span> <span class="o">=</span> <span class="n">random_states</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> 
                <span class="n">activities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">random_states</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">flipped_random_states</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">activities</span> <span class="o">/</span> <span class="n">nsim</span></div>

    
    
<div class="viewcode-block" id="BooleanFunction.get_average_sensitivity">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_average_sensitivity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_average_sensitivity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nsim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
        <span class="n">EXACT</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">NORMALIZED</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">rng</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the average sensitivity of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        The (unnormalized) average sensitivity equals the sum of the activities of</span>
<span class="sd">        all variables. If ``NORMALIZED=True``, the result is divided by ``n``.</span>
<span class="sd">    </span>
<span class="sd">        The sensitivity can be computed exactly by enumerating all input states or</span>
<span class="sd">        estimated via Monte Carlo sampling.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsim : int, optional</span>
<span class="sd">            Number of random samples used when ``EXACT=False`` (default: 10000).</span>
<span class="sd">        EXACT : bool, optional</span>
<span class="sd">            If ``True``, compute the exact activities by enumerating all input states.</span>
<span class="sd">            If ``False``, estimate them via sampling (default: ``False``).</span>
<span class="sd">        NORMALIZED : bool, optional</span>
<span class="sd">            If ``True``, return the average sensitivity divided by ``n`` (default:</span>
<span class="sd">            ``True``). If ``False``, return the sum of activities.</span>
<span class="sd">        rng : None or numpy.random.Generator, optional</span>
<span class="sd">            Random number generator passed to ``utils._coerce_rng``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The (optionally normalized) average sensitivity of the Boolean function.</span>
<span class="sd">        &quot;&quot;&quot;</span>      
        <span class="n">activities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_activities</span><span class="p">(</span><span class="n">nsim</span><span class="p">,</span><span class="n">EXACT</span><span class="p">,</span><span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">activities</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">NORMALIZED</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>

    

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_layer_structure</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">can_inputs</span><span class="p">,</span>
        <span class="n">can_outputs</span><span class="p">,</span>
        <span class="n">can_order</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">,</span>
        <span class="n">depth</span><span class="p">,</span>
        <span class="n">number_layers</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal recursive routine for computing the canalizing layer structure.</span>
<span class="sd">    </span>
<span class="sd">        This method identifies all canalizing variables at the current recursion</span>
<span class="sd">        level using bitwise operations, removes them simultaneously, and recurses</span>
<span class="sd">        on the resulting core function.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        can_inputs : np.ndarray</span>
<span class="sd">            Accumulated canalizing input values.</span>
<span class="sd">        can_outputs : np.ndarray</span>
<span class="sd">            Accumulated canalized output values.</span>
<span class="sd">        can_order : np.ndarray</span>
<span class="sd">            Accumulated order of canalizing variables.</span>
<span class="sd">        variables : list[int]</span>
<span class="sd">            Indices of variables remaining in the current subfunction.</span>
<span class="sd">        depth : int</span>
<span class="sd">            Current canalizing depth.</span>
<span class="sd">        number_layers : int</span>
<span class="sd">            Current number of identified canalizing layers.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            A tuple containing the updated canalizing depth, number of layers,</span>
<span class="sd">            canalizing inputs, canalized outputs, core Boolean function, and</span>
<span class="sd">            canalizing variable order.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># base cases</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># recursion ends when function becomes constant</span>
            <span class="k">return</span> <span class="n">depth</span><span class="p">,</span> <span class="n">number_layers</span><span class="p">,</span> <span class="n">can_inputs</span><span class="p">,</span> <span class="n">can_outputs</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">can_order</span>
    
        <span class="k">if</span> <span class="ow">not</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="n">variables</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    
        <span class="c1"># candidate canalizing variables (x_i, a)</span>
        <span class="n">new_canalizing_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_can_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_can_outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_f</span> <span class="o">=</span> <span class="kc">None</span>
    
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
            <span class="n">bit0</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">bit1</span> <span class="o">=</span> <span class="o">~</span><span class="n">bit0</span>
            <span class="n">f0</span><span class="p">,</span> <span class="n">f1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">bit0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">bit1</span><span class="p">]</span>
    
            <span class="c1"># check both possible canalizing directions</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">f0</span> <span class="o">==</span> <span class="n">f0</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">new_canalizing_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_can_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">new_can_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">f0</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">f1</span> <span class="o">==</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">new_canalizing_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_can_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">new_can_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    
        <span class="k">if</span> <span class="ow">not</span> <span class="n">new_canalizing_vars</span><span class="p">:</span>
            <span class="c1"># non-canalizing core function</span>
            <span class="k">return</span> <span class="n">depth</span><span class="p">,</span> <span class="n">number_layers</span><span class="p">,</span> <span class="n">can_inputs</span><span class="p">,</span> <span class="n">can_outputs</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">can_order</span>
    
        <span class="c1"># reduce variable list (remove canalizing ones)</span>
        <span class="n">indices_new_canalizing_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_canalizing_vars</span><span class="p">]</span>
        <span class="n">remaining_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_canalizing_vars</span><span class="p">]</span>
    
        <span class="c1"># build the restricted subfunction (core function)</span>
        <span class="c1"># start with all indices, then keep those where none of the canalizing</span>
        <span class="c1"># variables take their canalizing inputs</span>
        <span class="n">mask_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices_new_canalizing_vars</span><span class="p">,</span> <span class="n">new_can_inputs</span><span class="p">):</span>
            <span class="n">bitmask</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">var</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span>
            <span class="n">mask_keep</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">bitmask</span> <span class="o">!=</span> <span class="n">val</span><span class="p">)</span>
        <span class="n">new_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">mask_keep</span><span class="p">]</span>
    

        <span class="c1"># recurse on reduced function</span>
        <span class="n">new_bf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_f</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_bf</span><span class="o">.</span><span class="n">_get_layer_structure</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">can_inputs</span><span class="p">,</span> <span class="n">new_can_inputs</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">can_outputs</span><span class="p">,</span> <span class="n">new_can_outputs</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">can_order</span><span class="p">,</span> <span class="n">new_canalizing_vars</span><span class="p">),</span>
            <span class="n">remaining_vars</span><span class="p">,</span>
            <span class="n">depth</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_canalizing_vars</span><span class="p">),</span>
            <span class="n">number_layers</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>


<div class="viewcode-block" id="BooleanFunction.get_layer_structure">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_layer_structure">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_layer_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the canalizing layer structure of a Boolean function.</span>
<span class="sd">        </span>
<span class="sd">        This method decomposes a Boolean function into its canalizing layers</span>
<span class="sd">        (standard monomial form) by recursively identifying and removing</span>
<span class="sd">        canalizing variables. All variables that canalize the function at the</span>
<span class="sd">        same recursion step form one canalizing layer and are removed</span>
<span class="sd">        simultaneously.</span>
<span class="sd">        </span>
<span class="sd">        The decomposition yields the canalizing depth, the number of canalizing</span>
<span class="sd">        layers, the canalizing inputs and outputs, the order of canalizing</span>
<span class="sd">        variables, and the remaining non-canalizing core function.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing the canalizing layer structure with the</span>
<span class="sd">            following entries:</span>
<span class="sd">        </span>
<span class="sd">            - ``CanalizingDepth`` : int  </span>
<span class="sd">              Total number of canalizing variables.</span>
<span class="sd">        </span>
<span class="sd">            - ``NumberOfLayers`` : int  </span>
<span class="sd">              Number of distinct canalizing layers.</span>
<span class="sd">        </span>
<span class="sd">            - ``CanalizingInputs`` : np.ndarray  </span>
<span class="sd">              Canalizing input value for each canalizing variable.</span>
<span class="sd">        </span>
<span class="sd">            - ``CanalizedOutputs`` : np.ndarray  </span>
<span class="sd">              Output value forced by each canalizing variable.</span>
<span class="sd">        </span>
<span class="sd">            - ``CoreFunction`` : BooleanFunction  </span>
<span class="sd">              Core Boolean function obtained after removing all canalizing</span>
<span class="sd">              variables.</span>
<span class="sd">        </span>
<span class="sd">            - ``OrderOfCanalizingVariables`` : np.ndarray  </span>
<span class="sd">              Order in which canalizing variables are identified.</span>
<span class="sd">        </span>
<span class="sd">            - ``LayerStructure`` : np.ndarray  </span>
<span class="sd">              Number of canalizing variables in each layer.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The result is cached in ``self.properties`` and recomputed only if the</span>
<span class="sd">        canalizing structure has not been computed previously.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method has exponential time complexity in ``n`` and is intended for</span>
<span class="sd">        smaller Boolean functions.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        He, Q., &amp; Macauley, M. (2016).</span>
<span class="sd">            Stratification and enumeration of Boolean functions by canalizing depth.</span>
<span class="sd">            *Physica D: Nonlinear Phenomena*, 314, 18.</span>
<span class="sd">        </span>
<span class="sd">        Dimitrova, E., Stigler, B., Kadelka, C., &amp; Murrugarra, D. (2022).</span>
<span class="sd">            Revealing the canalizing structure of Boolean functions:</span>
<span class="sd">            Algorithms and applications.</span>
<span class="sd">            *Automatica*, 146, 110630.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;CanalizingDepth&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
            <span class="n">dummy</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s2">&quot;CanalizingDepth&quot;</span><span class="p">,</span> <span class="s2">&quot;NumberOfLayers&quot;</span><span class="p">,</span> <span class="s2">&quot;CanalizingInputs&quot;</span><span class="p">,</span> <span class="s2">&quot;CanalizedOutputs&quot;</span><span class="p">,</span> <span class="s2">&quot;CoreFunction&quot;</span><span class="p">,</span> <span class="s2">&quot;OrderOfCanalizingVariables&quot;</span><span class="p">],</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_get_layer_structure</span><span class="p">(</span><span class="n">can_inputs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">can_outputs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
                                                                      <span class="n">can_order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">variables</span><span class="o">=</span><span class="p">[],</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">number_layers</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
            <span class="n">dummy</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;LayerStructure&#39;</span><span class="p">:</span> <span class="n">get_layer_structure_from_canalized_outputs</span><span class="p">(</span><span class="n">dummy</span><span class="p">[</span><span class="s2">&quot;CanalizedOutputs&quot;</span><span class="p">])})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dummy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CanalizingDepth&quot;</span><span class="p">,</span> <span class="s2">&quot;NumberOfLayers&quot;</span><span class="p">,</span> <span class="s2">&quot;CanalizingInputs&quot;</span><span class="p">,</span> <span class="s2">&quot;CanalizedOutputs&quot;</span><span class="p">,</span> <span class="s2">&quot;CoreFunction&quot;</span><span class="p">,</span> <span class="s2">&quot;OrderOfCanalizingVariables&quot;</span><span class="p">,</span><span class="s1">&#39;LayerStructure&#39;</span><span class="p">]}</span></div>



<div class="viewcode-block" id="BooleanFunction.get_canalizing_depth">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_canalizing_depth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_canalizing_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the canalizing depth of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        The canalizing depth is the total number of canalizing variables identified</span>
<span class="sd">        in the canalizing layer decomposition.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Canalizing depth of the Boolean function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;CanalizingDepth&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_layer_structure</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;CanalizingDepth&quot;</span><span class="p">]</span></div>


    
<div class="viewcode-block" id="BooleanFunction.get_kset_canalizing_proportion">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_kset_canalizing_proportion">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_kset_canalizing_proportion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the proportion of k-set canalizing input sets.</span>
<span class="sd">    </span>
<span class="sd">        For a given ``k``, this method computes the probability that a randomly</span>
<span class="sd">        chosen set of ``k`` variables canalizes the function, i.e., fixing those</span>
<span class="sd">        variables to some values forces the output regardless of the remaining</span>
<span class="sd">        variables.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int</span>
<span class="sd">            Size of the variable set, with ``0 &lt;= k &lt;= n``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Proportion of k-set canalizing input sets.</span>
<span class="sd">            </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method has exponential time complexity in ``n`` and is intended for</span>
<span class="sd">        small Boolean functions.</span>
<span class="sd">    </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023).</span>
<span class="sd">            Collectively canalizing Boolean functions.</span>
<span class="sd">            *Advances in Applied Mathematics*, 145, 102475.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span> <span class="ow">and</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">k</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;k must be an integer and satisfy 0 &lt;= k &lt;= degree n&quot;</span><span class="p">)</span>
        
        <span class="c1"># trivial case</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">())</span>
        
        <span class="c1"># precompute binary representation of all inputs</span>
        <span class="c1">#indices = np.arange(2**self.n, dtype=np.uint32)</span>
        <span class="c1">#bits = ((indices[:, None] &gt;&gt; np.arange(self.n)) &amp; 1).astype(np.uint8)  # shape (2**n, n)</span>
        <span class="n">left_side_of_truth_table</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_left_side_of_truth_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        
        <span class="n">total_tests</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">canalizing_hits</span> <span class="o">=</span> <span class="mi">0</span>
    
        <span class="c1"># iterate over variable subsets of size k</span>
        <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">Xsub</span> <span class="o">=</span> <span class="n">left_side_of_truth_table</span><span class="p">[:,</span> <span class="n">subset</span><span class="p">]</span>  <span class="c1"># shape (2**n, k)</span>
            <span class="c1"># For each possible assignment to this subset</span>
            <span class="k">for</span> <span class="n">assignment</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">k</span><span class="p">):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">Xsub</span> <span class="o">==</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="c1"># If all outputs equal when these vars are fixed  canalizing</span>
                <span class="n">f_sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">f_sub</span> <span class="o">==</span> <span class="n">f_sub</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">canalizing_hits</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">total_tests</span> <span class="o">+=</span> <span class="mi">1</span>
    
        <span class="k">return</span> <span class="n">canalizing_hits</span> <span class="o">/</span> <span class="n">total_tests</span> <span class="k">if</span> <span class="n">total_tests</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span></div>



<div class="viewcode-block" id="BooleanFunction.get_kset_canalizing_proportion_of_variables">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_kset_canalizing_proportion_of_variables">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_kset_canalizing_proportion_of_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the proportion of k-set canalizing input sets per variable.</span>
<span class="sd">    </span>
<span class="sd">        For a given ``k``, this method computes, for each variable, the proportion</span>
<span class="sd">        of k-variable input sets containing that variable which canalize the</span>
<span class="sd">        Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int</span>
<span class="sd">            Size of the variable set, with ``0 &lt;= k &lt;= n``.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Array of length ``n`` giving the proportion of k-set canalizing input</span>
<span class="sd">            sets containing each variable.</span>
<span class="sd">            </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method has exponential time complexity in ``n`` and is intended for</span>
<span class="sd">        small Boolean functions.</span>
<span class="sd">    </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023).</span>
<span class="sd">            Collectively canalizing Boolean functions.</span>
<span class="sd">            *Advances in Applied Mathematics*, 145, 102475.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span> <span class="ow">and</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">k</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;k must be an integer and satisfy 0 &lt;= k &lt;= degree n&quot;</span><span class="p">)</span>
        
        <span class="c1"># trivial case</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">())</span>
        
        <span class="c1"># precompute binary representation of all inputs</span>
        <span class="c1">#indices = np.arange(2**self.n, dtype=np.uint32)</span>
        <span class="c1">#bits = ((indices[:, None] &gt;&gt; np.arange(self.n)) &amp; 1).astype(np.uint8)  # shape (2**n, n)</span>
        <span class="n">left_side_of_truth_table</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_left_side_of_truth_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        
        <span class="n">canalizing_hits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="c1"># iterate over variable subsets of size k</span>
        <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">Xsub</span> <span class="o">=</span> <span class="n">left_side_of_truth_table</span><span class="p">[:,</span> <span class="n">subset</span><span class="p">]</span>  <span class="c1"># shape (2**n, k)</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>
            <span class="c1"># For each possible assignment to this subset</span>
            <span class="k">for</span> <span class="n">assignment</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">k</span><span class="p">):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">Xsub</span> <span class="o">==</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="c1"># If all outputs equal when these vars are fixed  canalizing</span>
                <span class="n">f_sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">f_sub</span> <span class="o">==</span> <span class="n">f_sub</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">canalizing_hits</span><span class="p">[</span><span class="n">subset</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    
        <span class="k">return</span> <span class="n">canalizing_hits</span> <span class="o">/</span> <span class="p">(</span><span class="n">k</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="n">k</span><span class="p">)</span></div>



<div class="viewcode-block" id="BooleanFunction.get_canalizing_strength">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_canalizing_strength">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_canalizing_strength</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the canalizing strength of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        The canalizing strength is defined as a weighted average of the proportions</span>
<span class="sd">        of k-set canalizing inputs for ``k = 1, ..., n-1``. It equals 0 for minimally</span>
<span class="sd">        canalizing functions (e.g., parity functions) and 1 for maximally canalizing</span>
<span class="sd">        functions (e.g., nested canalizing functions with a single layer).</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Canalizing strength of the Boolean function.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method has exponential time complexity in ``n`` and is intended for</span>
<span class="sd">        small Boolean functions.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023).</span>
<span class="sd">            Collectively canalizing Boolean functions.</span>
<span class="sd">            *Advances in Applied Mathematics*, 145, 102475.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Canalizing strength is only defined for Boolean functions with n &gt; 1 inputs. &quot;</span>
                <span class="s2">&quot;Returning 1 for n == 1.&quot;</span><span class="p">,</span>
                <span class="ne">RuntimeWarning</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_kset_canalizing_proportion</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span></div>



<div class="viewcode-block" id="BooleanFunction.get_canalizing_strength_of_variables">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_canalizing_strength_of_variables">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_canalizing_strength_of_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the canalizing strength of each variable.</span>
<span class="sd">    </span>
<span class="sd">        The canalizing strength of a variable is defined as a weighted average of</span>
<span class="sd">        the proportions of k-set canalizing inputs containing that variable for</span>
<span class="sd">        ``k = 1, ..., n-1``.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method has exponential time complexity in ``n`` and is intended for</span>
<span class="sd">        small Boolean functions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Array of length ``n`` containing the canalizing strength of each</span>
<span class="sd">            variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Canalizing strength is only defined for Boolean functions with n &gt; 1 inputs. &quot;</span>
                <span class="s2">&quot;Returning 1 for n == 1.&quot;</span><span class="p">,</span>
                <span class="ne">RuntimeWarning</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">res</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_kset_canalizing_proportion_of_variables</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">multipliers</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">res</span> <span class="o">*</span> <span class="n">multipliers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="BooleanFunction.get_input_redundancy">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_input_redundancy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_input_redundancy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the input redundancy of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        Input redundancy quantifies the fraction of inputs that are not required</span>
<span class="sd">        to determine the output. Constant functions have redundancy 1, whereas</span>
<span class="sd">        parity functions have redundancy 0.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Normalized input redundancy in the interval ``[0, 1]``.</span>
<span class="sd">    </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ImportError</span>
<span class="sd">            If the CANA package is not installed.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method has exponential time complexity in ``n`` and is intended for</span>
<span class="sd">        small Boolean functions.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Marques-Pita, M., &amp; Rocha, L. M. (2013).</span>
<span class="sd">            Canalization and control in automata networks: body segmentation in</span>
<span class="sd">            *Drosophila melanogaster*. *PLoS One*, 8(3), e55946.</span>
<span class="sd">    </span>
<span class="sd">        Correia, R. B., Gates, A. J., Wang, X., &amp; Rocha, L. M. (2018).</span>
<span class="sd">            CANA: a python package for quantifying control and canalization in</span>
<span class="sd">            Boolean networks. *Frontiers in Physiology*, 9, 1046.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">__LOADED_CANA__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;get_input_redundancy requires the CANA package. &quot;</span>
                <span class="s2">&quot;Install BoolForge with extended functionality to enable this method.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cana</span><span class="p">()</span><span class="o">.</span><span class="n">input_redundancy</span><span class="p">()</span></div>

        
<div class="viewcode-block" id="BooleanFunction.get_edge_effectiveness">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_edge_effectiveness">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_edge_effectiveness</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the edge effectiveness of each input variable.</span>
<span class="sd">    </span>
<span class="sd">        Edge effectiveness measures how strongly flipping an input variable</span>
<span class="sd">        influences the output. Non-essential inputs have effectiveness 0, whereas</span>
<span class="sd">        inputs that always flip the output have effectiveness 1.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list[float]</span>
<span class="sd">            List of length ``n`` containing edge effectiveness values in</span>
<span class="sd">            ``[0, 1]``.</span>
<span class="sd">    </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ImportError</span>
<span class="sd">            If the CANA package is not installed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method has exponential time complexity in ``n`` and is intended for</span>
<span class="sd">        small Boolean functions.</span>
<span class="sd">    </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Marques-Pita, M., &amp; Rocha, L. M. (2013).</span>
<span class="sd">            Canalization and control in automata networks: body segmentation in</span>
<span class="sd">            *Drosophila melanogaster*. *PLoS One*, 8(3), e55946.</span>
<span class="sd">    </span>
<span class="sd">        Correia, R. B., Gates, A. J., Wang, X., &amp; Rocha, L. M. (2018).</span>
<span class="sd">            CANA: a python package for quantifying control and canalization in</span>
<span class="sd">            Boolean networks. *Frontiers in Physiology*, 9, 1046.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">__LOADED_CANA__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;get_edge_effectiveness requires the CANA package. &quot;</span>
                <span class="s2">&quot;Install BoolForge with extended functionality to enable this method.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cana</span><span class="p">()</span><span class="o">.</span><span class="n">edge_effectiveness</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="BooleanFunction.get_effective_degree">
<a class="viewcode-back" href="../../boolean_function.html#boolforge.boolean_function.BooleanFunction.get_effective_degree">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_effective_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the effective degree of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        The effective degree is defined as the sum of the edge effectiveness</span>
<span class="sd">        values of all input variables.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Effective degree of the Boolean function.</span>
<span class="sd">    </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ImportError</span>
<span class="sd">            If the CANA package is not installed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method has exponential time complexity in ``n`` and is intended for</span>
<span class="sd">        small Boolean functions.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Marques-Pita, M., &amp; Rocha, L. M. (2013).</span>
<span class="sd">            Canalization and control in automata networks: body segmentation in</span>
<span class="sd">            *Drosophila melanogaster*. *PLoS One*, 8(3), e55946.</span>
<span class="sd">    </span>
<span class="sd">        Correia, R. B., Gates, A. J., Wang, X., &amp; Rocha, L. M. (2018).</span>
<span class="sd">            CANA: a python package for quantifying control and canalization in</span>
<span class="sd">            Boolean networks. *Frontiers in Physiology*, 9, 1046.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">__LOADED_CANA__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;get_effective_degree requires the CANA package. &quot;</span>
                <span class="s2">&quot;Install BoolForge with extended functionality to enable this method.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_edge_effectiveness</span><span class="p">()))</span></div>
</div>




</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Claus Kadelka, Benjamin Coberly.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
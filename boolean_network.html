

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Boolean Network &mdash; BoolForge 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=8d563738"></script>
      <script src="_static/doctools.js?v=fd6eb6e6"></script>
      <script src="_static/sphinx_highlight.js?v=6ffebe34"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Generate" href="generate.html" />
    <link rel="prev" title="Boolean Function" href="boolean_function.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            BoolForge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="docs.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="boolean_function.html">Boolean Function</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Boolean Network</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.boolean_network.get_entropy_of_basin_size_distribution"><code class="docutils literal notranslate"><span class="pre">get_entropy_of_basin_size_distribution()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.remove_constants"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.remove_constants()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.from_cana"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.from_cana()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.from_string"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.from_string()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.from_DiGraph"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.from_DiGraph()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.to_cana"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.to_cana()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.to_bnet"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.to_bnet()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.to_truth_table"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.to_truth_table()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.__str__"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.__str__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.__repr__"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.__repr__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.__call__"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.__call__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.get_types_of_regulation"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.get_types_of_regulation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.simplify_functions"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.simplify_functions()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.get_identity_nodes"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.get_identity_nodes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.get_network_with_fixed_identity_nodes"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.get_network_with_fixed_identity_nodes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.get_network_with_node_controls"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.get_network_with_node_controls()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.get_network_with_edge_controls"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.get_network_with_edge_controls()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.update_single_node"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.update_single_node()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.update_network_synchronously"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.update_network_synchronously()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.update_network_SDDS"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.update_network_SDDS()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.get_steady_states_asynchronous_exact"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.get_steady_states_asynchronous_exact()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.get_steady_states_asynchronous"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.get_steady_states_asynchronous()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.get_steady_states_asynchronous_given_one_initial_condition"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.get_steady_states_asynchronous_given_one_initial_condition()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.get_attractors_synchronous()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.compute_synchronous_state_transition_graph"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.compute_synchronous_state_transition_graph()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous_exact"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.get_attractors_synchronous_exact()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.get_attractors_and_robustness_measures_synchronous_exact"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.get_attractors_and_robustness_measures_synchronous_exact()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.get_attractors_and_robustness_measures_synchronous"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.get_attractors_and_robustness_measures_synchronous()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.get_derrida_value"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.get_derrida_value()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous_exact_non_autonomous"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.get_attractors_synchronous_exact_non_autonomous()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous_exact_with_external_inputs"><code class="docutils literal notranslate"><span class="pre">BooleanNetwork.get_attractors_synchronous_exact_with_external_inputs()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="generate.html">Generate</a></li>
<li class="toctree-l2"><a class="reference internal" href="bio_models.html">Bio Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="utils.html">Utils</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BoolForge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="docs.html">Documentation</a></li>
      <li class="breadcrumb-item active">Boolean Network</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/boolean_network.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="boolean-network">
<h1>Boolean Network<a class="headerlink" href="#boolean-network" title="Link to this heading"></a></h1>
<div class="toctree-wrapper compound">
</div>
<p id="module-boolforge.boolean_network">This module defines the <code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanNetwork</span></code> class, which provides
a high-level framework for modeling, simulating, and analyzing Boolean networks.</p>
<p>A <a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork" title="boolforge.boolean_network.BooleanNetwork"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanNetwork</span></code></a> represents a discrete dynamical system
<span class="math notranslate nohighlight">\(F = (f_1, \ldots, f_N)\)</span> composed of multiple
<code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanFunction</span></code> objects as update rules. The class includes
methods for constructing state transition graphs, identifying attractors,
computing robustness and sensitivity measures, and exporting truth tables.</p>
<p>Several computational routines—particularly those involving state space
exploration, attractor detection, and robustness estimation—offer optional
Numba-based just-in-time (JIT) acceleration. Installing Numba is <strong>recommended</strong>
for optimal performance but <strong>not required</strong>; all features remain functional
without it.</p>
<p>This module serves as the central interface for dynamic Boolean network
analysis within the BoolForge package.</p>
<section id="example">
<h2>Example<a class="headerlink" href="#example" title="Link to this heading"></a></h2>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">boolforge</span><span class="w"> </span><span class="kn">import</span> <span class="n">BooleanNetwork</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span> <span class="o">=</span> <span class="n">BooleanNetwork</span><span class="p">(</span><span class="n">F</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">I</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span><span class="o">.</span><span class="n">get_attractors_synchronous_exact</span><span class="p">()</span>
</pre></div>
</div>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="boolforge.boolean_network.get_entropy_of_basin_size_distribution">
<span class="sig-prename descclassname"><span class="pre">boolforge.boolean_network.</span></span><span class="sig-name descname"><span class="pre">get_entropy_of_basin_size_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basin_sizes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#get_entropy_of_basin_size_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.get_entropy_of_basin_size_distribution" title="Link to this definition"></a></dt>
<dd><p>Compute the Shannon entropy of a basin size distribution.</p>
<p>The basin sizes are first normalized to form a probability distribution.
The Shannon entropy is then computed as</p>
<p><code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">=</span> <span class="pre">-sum(p_i</span> <span class="pre">*</span> <span class="pre">log(p_i))</span></code>,</p>
<p>where <code class="docutils literal notranslate"><span class="pre">p_i</span></code> is the proportion of states in basin <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p>
<section id="parameters">
<h2>Parameters<a class="headerlink" href="#parameters" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>basin_sizes<span class="classifier">Sequence[int] or np.ndarray</span></dt><dd><p>Sizes of the basins of attraction, where each entry corresponds to
the number of initial conditions that converge to a given attractor.</p>
</dd>
</dl>
</section>
<section id="returns">
<h2>Returns<a class="headerlink" href="#returns" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>float</dt><dd><p>Shannon entropy of the basin size distribution.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">boolforge.boolean_network.</span></span><span class="sig-name descname"><span class="pre">BooleanNetwork</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="boolean_function.html#boolforge.boolean_function.BooleanFunction" title="boolforge.boolean_function.BooleanFunction"><span class="pre">BooleanFunction</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">WiringDiagram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SIMPLIFY_FUNCTIONS</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">WiringDiagram</span></code></p>
<p>Representation of a Boolean network.</p>
<p>A Boolean network consists of a wiring diagram specifying regulatory
interactions between nodes and a collection of Boolean update functions
defining the dynamics at each node.</p>
<p>In a BooleanNetwork, constant nodes are removed during initialization, 
so all nodes represent dynamic variables.</p>
<section id="id1">
<h2>Parameters<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>F<span class="classifier">sequence</span></dt><dd><p>Sequence of Boolean update functions or truth tables. Each entry may
be a <code class="docutils literal notranslate"><span class="pre">BooleanFunction</span></code> instance, a truth table, or a Boolean
expression. The length of <code class="docutils literal notranslate"><span class="pre">F</span></code> must match the number of nodes in the
wiring diagram.</p>
</dd>
<dt>I<span class="classifier">sequence of sequences of int or WiringDiagram</span></dt><dd><p>Wiring diagram specifying the regulators of each node, or an existing
<code class="docutils literal notranslate"><span class="pre">WiringDiagram</span></code> instance.</p>
</dd>
<dt>variables<span class="classifier">sequence of str, optional</span></dt><dd><p>Names of the variables corresponding to each node. Ignored if <code class="docutils literal notranslate"><span class="pre">I</span></code> is
provided as a <code class="docutils literal notranslate"><span class="pre">WiringDiagram</span></code>.</p>
</dd>
<dt>SIMPLIFY_FUNCTIONS<span class="classifier">bool, optional</span></dt><dd><p>If True, simplify Boolean update functions after initialization.
Default is False.</p>
</dd>
</dl>
</section>
<section id="attributes">
<h2>Attributes<a class="headerlink" href="#attributes" title="Link to this heading"></a></h2>
<dl class="simple">
<dt>F<span class="classifier">list[BooleanFunction]</span></dt><dd><p>Boolean update functions for each node.</p>
</dd>
<dt>I<span class="classifier">list[np.ndarray[int]]</span></dt><dd><p>Wiring diagram specifying the regulators of each node.</p>
</dd>
<dt>variables<span class="classifier">np.ndarray[str]</span></dt><dd><p>Names of the variables corresponding to each node.</p>
</dd>
<dt>N<span class="classifier">int</span></dt><dd><p>Number of dynamic (non-constant) nodes in the network.</p>
</dd>
<dt>indegrees<span class="classifier">np.ndarray[int]</span></dt><dd><p>Indegree of each node.</p>
</dd>
<dt>outdegrees<span class="classifier">np.ndarray[int]</span></dt><dd><p>Outdegree of each node.</p>
</dd>
<dt>constants<span class="classifier">dict[str, dict[str, int | list[str]]]</span></dt><dd><p>Mapping of node indices to constant values.</p>
</dd>
<dt>weights<span class="classifier">list[np.ndarray[float]] or None</span></dt><dd><p>Interaction weights associated with the wiring diagram.</p>
</dd>
<dt>STG<span class="classifier">dict or None</span></dt><dd><p>State transition graph, initialized to None and computed on demand.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.remove_constants">
<span class="sig-name descname"><span class="pre">remove_constants</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.remove_constants"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.remove_constants" title="Link to this definition"></a></dt>
<dd><p>Remove structurally constant nodes from the Boolean network.</p>
<p>A node is considered constant if it has no regulators (indegree zero).
Such nodes are eliminated from the dynamic network by propagating their
fixed Boolean values to downstream nodes. Eliminated constants and their
effects are recorded in the <code class="docutils literal notranslate"><span class="pre">constants</span></code> attribute.</p>
<section id="notes">
<h3>Notes<a class="headerlink" href="#notes" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>The Boolean value of a constant node is taken from its Boolean function.</p></li>
<li><p>After removal, <code class="docutils literal notranslate"><span class="pre">self.N</span></code> refers to the number of remaining dynamic nodes.</p></li>
<li><p>Nodes that lose all regulators as a result of constant removal are
assigned a non-essential self-loop to preserve network structure.</p></li>
</ul>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.from_cana">
<span class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_cana</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cana_BooleanNetwork</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">cana.boolean_network.BooleanNetwork</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork" title="boolforge.boolean_network.BooleanNetwork"><span class="pre">BooleanNetwork</span></a></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.from_cana"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.from_cana" title="Link to this definition"></a></dt>
<dd><p>Construct a BooleanNetwork from a <code class="docutils literal notranslate"><span class="pre">cana.BooleanNetwork</span></code> instance.</p>
<p>This compatibility method converts a Boolean network defined using the
<code class="docutils literal notranslate"><span class="pre">cana</span></code> package into a BoolForge <code class="docutils literal notranslate"><span class="pre">BooleanNetwork</span></code>.</p>
<section id="id2">
<h3>Parameters<a class="headerlink" href="#id2" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>cana_BooleanNetwork<span class="classifier">cana.boolean_network.BooleanNetwork</span></dt><dd><p>A Boolean network instance from the <code class="docutils literal notranslate"><span class="pre">cana</span></code> package.</p>
</dd>
</dl>
</section>
<section id="id3">
<h3>Returns<a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>BooleanNetwork</dt><dd><p>The corresponding BoolForge BooleanNetwork.</p>
</dd>
</dl>
</section>
<section id="raises">
<h3>Raises<a class="headerlink" href="#raises" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>TypeError</dt><dd><p>If the input object does not appear to be a valid CANA BooleanNetwork.</p>
</dd>
<dt>KeyError</dt><dd><p>If required fields are missing from the CANA logic specification.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.from_string">
<span class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">network_string</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">','</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">24</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">original_not</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'NOT'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">original_and</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'AND'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">original_or</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'OR'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ALLOW_TRUNCATION</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork" title="boolforge.boolean_network.BooleanNetwork"><span class="pre">BooleanNetwork</span></a></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.from_string"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.from_string" title="Link to this definition"></a></dt>
<dd><p>Construct a BooleanNetwork from a textual Boolean rule specification.</p>
<p>This compatibility method parses a string representation of Boolean update
rules and constructs a corresponding BooleanNetwork. The input format is
intended for legacy or trusted sources and supports logical expressions
using AND/OR/NOT operators.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method uses <code class="docutils literal notranslate"><span class="pre">eval</span></code> internally and MUST NOT be used on untrusted
input. It is provided solely for backward compatibility.</p>
</div>
<section id="id4">
<h3>Parameters<a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>network_string<span class="classifier">str</span></dt><dd><p>String encoding Boolean update rules, one per line.</p>
</dd>
<dt>separator<span class="classifier">str or sequence of str, optional</span></dt><dd><p>Separator(s) between variable names and Boolean expressions.</p>
</dd>
<dt>max_degree<span class="classifier">int, optional</span></dt><dd><p>Maximum allowed indegree for explicit truth-table construction.</p>
</dd>
<dt>original_not, original_and, original_or<span class="classifier">str or sequence of str, optional</span></dt><dd><p>Operator strings to be replaced by logical NOT, AND, OR.</p>
</dd>
<dt>ALLOW_TRUNCATION<span class="classifier">bool, optional</span></dt><dd><p>If False (default), nodes with indegree greater than <code class="docutils literal notranslate"><span class="pre">max_degree</span></code>
raise a ValueError. If True, such nodes are replaced by identity
self-loops, allowing fast construction of large networks while
ignoring high-degree functions.</p>
</dd>
</dl>
</section>
<section id="id5">
<h3>Returns<a class="headerlink" href="#id5" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>BooleanNetwork</dt><dd><p>The constructed Boolean network.</p>
</dd>
</dl>
</section>
<section id="id6">
<h3>Raises<a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>ValueError</dt><dd><p>If parsing fails or if <code class="docutils literal notranslate"><span class="pre">ALLOW_TRUNCATION</span></code> is False and 
a node exceeds <code class="docutils literal notranslate"><span class="pre">max_degree</span></code>.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.from_DiGraph">
<span class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_DiGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nx_DiGraph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">DiGraph</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">WiringDiagram</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.from_DiGraph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.from_DiGraph" title="Link to this definition"></a></dt>
<dd><p>Construct a WiringDiagram from a NetworkX directed graph.</p>
<p>Each node in the directed graph represents a Boolean variable, and each
directed edge <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">-&gt;</span> <span class="pre">v</span></code> indicates that variable <code class="docutils literal notranslate"><span class="pre">u</span></code> regulates variable
<code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<section id="id7">
<h3>Parameters<a class="headerlink" href="#id7" title="Link to this heading"></a></h3>
<dl>
<dt>nx_DiGraph<span class="classifier">nx.DiGraph</span></dt><dd><p>Directed graph whose nodes represent variables and whose edges
represent regulatory interactions.</p>
<dl class="simple">
<dt>Node attributes (optional)</dt><dd><dl class="simple">
<dt>name<span class="classifier">str</span></dt><dd><p>Name of the variable. If not provided, the node label is used
when possible.</p>
</dd>
</dl>
</dd>
<dt>Edge attributes (optional)</dt><dd><dl class="simple">
<dt>weight<span class="classifier">float</span></dt><dd><p>Weight of the regulatory interaction from <code class="docutils literal notranslate"><span class="pre">u</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code>.
If present on all edges, weights are stored in the
<code class="docutils literal notranslate"><span class="pre">weights</span></code> attribute of the resulting WiringDiagram.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="id8">
<h3>Returns<a class="headerlink" href="#id8" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>WiringDiagram</dt><dd><p>Wiring diagram representing the topology of the directed graph.</p>
</dd>
</dl>
</section>
<section id="id9">
<h3>Notes<a class="headerlink" href="#id9" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Nodes are ordered according to the iteration order of
<code class="docutils literal notranslate"><span class="pre">nx_DiGraph.nodes</span></code>.</p></li>
<li><p>Regulator lists are constructed from incoming edges
(graph predecessors).</p></li>
<li><p>Edge weights are only stored if <em>all</em> edges define a <code class="docutils literal notranslate"><span class="pre">'weight'</span></code>
attribute.</p></li>
</ul>
</section>
<section id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Link to this heading"></a></h3>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">WD</span> <span class="o">=</span> <span class="n">WiringDiagram</span><span class="o">.</span><span class="n">from_DiGraph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">WD</span><span class="o">.</span><span class="n">I</span>
<span class="go">[array([2]), array([0]), array([1])]</span>
</pre></div>
</div>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.to_cana">
<span class="sig-name descname"><span class="pre">to_cana</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">cana.boolean_network.BooleanNetwork</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.to_cana"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.to_cana" title="Link to this definition"></a></dt>
<dd><p>Export the Boolean network as a <code class="docutils literal notranslate"><span class="pre">cana.BooleanNetwork</span></code> instance.</p>
<p>This compatibility method converts the current BooleanNetwork into an
equivalent representation from the <code class="docutils literal notranslate"><span class="pre">cana</span></code> package. The exported network
reflects the current state of the model, including any removed constants,
simplifications, or identity self-loops.</p>
<section id="id10">
<h3>Returns<a class="headerlink" href="#id10" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>cana.boolean_network.BooleanNetwork</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">cana</span></code> BooleanNetwork instance representing this network.</p>
</dd>
</dl>
</section>
<section id="id11">
<h3>Raises<a class="headerlink" href="#id11" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>ImportError</dt><dd><p>If the <code class="docutils literal notranslate"><span class="pre">cana</span></code> package is not installed.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.to_bnet">
<span class="sig-name descname"><span class="pre">to_bnet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">separator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">',\t'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AS_POLYNOMIAL</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.to_bnet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.to_bnet" title="Link to this definition"></a></dt>
<dd><p>Export the Boolean network in BNET format.</p>
<p>This compatibility method returns a string representation of the Boolean
network in the BNET format used by tools such as BoolNet and PyBoolNet,
with one line per variable of the form <code class="docutils literal notranslate"><span class="pre">variable</span> <span class="pre">&lt;separator&gt;</span> <span class="pre">function</span></code>.</p>
<section id="id12">
<h3>Parameters<a class="headerlink" href="#id12" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>separator<span class="classifier">str, optional</span></dt><dd><p>String used to separate the target variable from its update function.
Default is <cite>“,t”</cite>.</p>
</dd>
<dt>AS_POLYNOMIAL<span class="classifier">bool, optional</span></dt><dd><p>If True (default), return Boolean functions in polynomial form.
If False, return functions as logical expressions.</p>
</dd>
</dl>
</section>
<section id="id13">
<h3>Returns<a class="headerlink" href="#id13" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>str</dt><dd><p>A string containing the BNET representation of the network.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.to_truth_table">
<span class="sig-name descname"><span class="pre">to_truth_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.to_truth_table"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.to_truth_table" title="Link to this definition"></a></dt>
<dd><p>Construct the full synchronous truth table of the Boolean network.</p>
<p>Each row corresponds to a network state at time <code class="docutils literal notranslate"><span class="pre">t</span></code> and its deterministic
successor at time <code class="docutils literal notranslate"><span class="pre">t+1</span></code> under synchronous updating.</p>
<section id="id14">
<h3>Parameters<a class="headerlink" href="#id14" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>filename<span class="classifier">str, optional</span></dt><dd><p>If provided, the truth table is written to a file. The file extension
determines the format and must be one of <code class="docutils literal notranslate"><span class="pre">'csv'</span></code>, <code class="docutils literal notranslate"><span class="pre">'xls'</span></code>, or
<code class="docutils literal notranslate"><span class="pre">'xlsx'</span></code>. If None (default), no file is created.</p>
</dd>
</dl>
</section>
<section id="id15">
<h3>Returns<a class="headerlink" href="#id15" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>pandas.DataFrame</dt><dd><p>The full truth table with shape <code class="docutils literal notranslate"><span class="pre">(2**N,</span> <span class="pre">2*N)</span></code>.</p>
</dd>
</dl>
</section>
<section id="id16">
<h3>Notes<a class="headerlink" href="#id16" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>States are enumerated in lexicographic order, consistent with
<code class="docutils literal notranslate"><span class="pre">utils.get_left_side_of_truth_table</span></code>.</p></li>
<li><p>This method computes and stores the synchronous state transition graph
(<code class="docutils literal notranslate"><span class="pre">self.STG</span></code>) if it has not been computed previously.</p></li>
<li><p>Exporting to Excel requires the <code class="docutils literal notranslate"><span class="pre">openpyxl</span></code> package.</p></li>
</ul>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.__str__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.__str__" title="Link to this definition"></a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.__repr__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.__repr__" title="Link to this definition"></a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.__call__" title="Link to this definition"></a></dt>
<dd><p>Apply one synchronous update step to the Boolean network.</p>
<p>The next state is obtained by evaluating each node’s Boolean update
function on the current values of its regulators.</p>
<section id="id17">
<h3>Parameters<a class="headerlink" href="#id17" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>state<span class="classifier">sequence of int</span></dt><dd><p>Current network state as a binary vector of length <code class="docutils literal notranslate"><span class="pre">N</span></code>, ordered
according to <code class="docutils literal notranslate"><span class="pre">self.variables</span></code>.</p>
</dd>
</dl>
</section>
<section id="id18">
<h3>Returns<a class="headerlink" href="#id18" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>The updated network state after one synchronous update.</p>
</dd>
</dl>
</section>
<section id="id19">
<h3>Notes<a class="headerlink" href="#id19" title="Link to this heading"></a></h3>
<p>This method is equivalent to calling <code class="docutils literal notranslate"><span class="pre">update_network_synchronously</span></code>.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.get_types_of_regulation">
<span class="sig-name descname"><span class="pre">get_types_of_regulation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.get_types_of_regulation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.get_types_of_regulation" title="Link to this definition"></a></dt>
<dd><p>Compute and return regulation types (weights) for all nodes in the network.</p>
<p>For each Boolean function, the type of each input regulation is determined
via <code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_type_of_inputs</span></code> and mapped to numerical weights
using <code class="docutils literal notranslate"><span class="pre">dict_weights</span></code>. The resulting weights are stored in the
<code class="docutils literal notranslate"><span class="pre">self.weights</span></code> attribute and also returned.</p>
<section id="id20">
<h3>Returns<a class="headerlink" href="#id20" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>list of np.ndarray</dt><dd><p>Regulation weights for each node, aligned with the wiring diagram.</p>
</dd>
</dl>
</section>
<section id="id21">
<h3>Notes<a class="headerlink" href="#id21" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>This method recomputes <code class="docutils literal notranslate"><span class="pre">self.weights</span></code> from scratch.</p></li>
<li><p>Calling this method overwrites any existing values in <code class="docutils literal notranslate"><span class="pre">self.weights</span></code>.</p></li>
</ul>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.simplify_functions">
<span class="sig-name descname"><span class="pre">simplify_functions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.simplify_functions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.simplify_functions" title="Link to this definition"></a></dt>
<dd><p>Remove all non-essential regulators from the Boolean network.</p>
<p>For each node, non-essential regulators (identified via <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> entries
in <code class="docutils literal notranslate"><span class="pre">self.weights</span></code>) are removed from the wiring diagram and the associated
Boolean function is restricted to its essential inputs. Nodes that would
otherwise lose all regulators are assigned an identity self-loop to preserve
network structure.</p>
<section id="id22">
<h3>Notes<a class="headerlink" href="#id22" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>This method modifies the network in place.</p></li>
<li><p>Regulation types (<code class="docutils literal notranslate"><span class="pre">self.weights</span></code>) are recomputed if necessary.</p></li>
<li><p>Identity self-loops introduced here are structural artifacts and do not
represent genuine regulatory interactions.</p></li>
</ul>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.get_identity_nodes">
<span class="sig-name descname"><span class="pre">get_identity_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AS_DICT</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.get_identity_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.get_identity_nodes" title="Link to this definition"></a></dt>
<dd><p>Identify identity (memory) nodes in the Boolean network.</p>
<p>An identity node is a node with a single self-regulatory edge whose
Boolean update function is the identity function <code class="docutils literal notranslate"><span class="pre">f(x)</span> <span class="pre">=</span> <span class="pre">x</span></code>. Such
nodes retain their state over time unless externally modified.</p>
<section id="id23">
<h3>Parameters<a class="headerlink" href="#id23" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>AS_DICT<span class="classifier">bool, optional</span></dt><dd><p>If True, return a dictionary mapping node indices to booleans.
If False (default), return an array of indices of identity nodes.</p>
</dd>
</dl>
</section>
<section id="id24">
<h3>Returns<a class="headerlink" href="#id24" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>dict[int, bool] or np.ndarray</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">AS_DICT</span></code> is True, a dictionary indicating which nodes are
identity nodes.
If <code class="docutils literal notranslate"><span class="pre">AS_DICT</span></code> is False, an array of indices of identity nodes.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.get_network_with_fixed_identity_nodes">
<span class="sig-name descname"><span class="pre">get_network_with_fixed_identity_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values_identity_nodes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork" title="boolforge.boolean_network.BooleanNetwork"><span class="pre">BooleanNetwork</span></a></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.get_network_with_fixed_identity_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.get_network_with_fixed_identity_nodes" title="Link to this definition"></a></dt>
<dd><p>Construct a Boolean network with identity nodes fixed to given values.</p>
<p>Identity nodes are nodes with a single self-regulatory edge and identity
update rule <code class="docutils literal notranslate"><span class="pre">f(x)</span> <span class="pre">=</span> <span class="pre">x</span></code>. This method fixes the values of such nodes and
returns a new BooleanNetwork with the corresponding constants removed.</p>
<section id="id25">
<h3>Parameters<a class="headerlink" href="#id25" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>values_identity_nodes<span class="classifier">sequence of int</span></dt><dd><p>Values to fix for each identity node, in the order returned by
<code class="docutils literal notranslate"><span class="pre">get_identity_nodes(AS_DICT=False)</span></code>. Each value must be either 0 or 1.</p>
</dd>
</dl>
</section>
<section id="id26">
<h3>Returns<a class="headerlink" href="#id26" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>BooleanNetwork</dt><dd><p>A new BooleanNetwork with the specified identity nodes fixed. Any
constants previously removed from the original network are preserved.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.get_network_with_node_controls">
<span class="sig-name descname"><span class="pre">get_network_with_node_controls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices_controlled_nodes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_controlled_nodes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">KEEP_CONTROLLED_NODES</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork" title="boolforge.boolean_network.BooleanNetwork"><span class="pre">BooleanNetwork</span></a></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.get_network_with_node_controls"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.get_network_with_node_controls" title="Link to this definition"></a></dt>
<dd><p>Construct a Boolean network with specified nodes fixed to given values.</p>
<p>This method applies node-level interventions by fixing selected nodes to
constant Boolean values. Controlled nodes may either be removed from the
dynamic network as constants or retained as identity-clamped nodes.</p>
<section id="id27">
<h3>Parameters<a class="headerlink" href="#id27" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>indices_controlled_nodes<span class="classifier">sequence of int</span></dt><dd><p>Indices of nodes to be fixed.</p>
</dd>
<dt>values_controlled_nodes<span class="classifier">sequence of int</span></dt><dd><p>Values to fix for each specified node, in the same order as
<code class="docutils literal notranslate"><span class="pre">indices_controlled_nodes</span></code>. Each value must be either 0 or 1.</p>
</dd>
<dt>KEEP_CONTROLLED_NODES<span class="classifier">bool, optional</span></dt><dd><p>If True, controlled nodes are retained in the network as identity
nodes with self-loops. If False (default), controlled nodes are
eliminated as constants.</p>
</dd>
</dl>
</section>
<section id="id28">
<h3>Returns<a class="headerlink" href="#id28" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>BooleanNetwork</dt><dd><p>A new BooleanNetwork with the specified node controls applied.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.get_network_with_edge_controls">
<span class="sig-name descname"><span class="pre">get_network_with_edge_controls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">control_targets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">control_sources</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_edge_controls</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#boolforge.boolean_network.BooleanNetwork" title="boolforge.boolean_network.BooleanNetwork"><span class="pre">BooleanNetwork</span></a></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.get_network_with_edge_controls"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.get_network_with_edge_controls" title="Link to this definition"></a></dt>
<dd><p>Construct a Boolean network with specified regulatory edges controlled.</p>
<p>This method fixes the influence of selected source nodes on selected target
nodes by restricting the target’s Boolean update function to entries where
the source assumes a specified value, and then removing the corresponding
regulatory edge.</p>
<section id="id29">
<h3>Parameters<a class="headerlink" href="#id29" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>control_targets<span class="classifier">sequence of int</span></dt><dd><p>Indices of target nodes.</p>
</dd>
<dt>control_sources<span class="classifier">sequence of int</span></dt><dd><p>Indices of source nodes whose influence on the corresponding targets
is to be controlled.</p>
</dd>
<dt>values_edge_controls<span class="classifier">sequence of int, optional</span></dt><dd><p>Fixed values (0 or 1) imposed on each controlled edge. If None, all
controlled edges are fixed to 0.</p>
</dd>
</dl>
</section>
<section id="id30">
<h3>Returns<a class="headerlink" href="#id30" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>BooleanNetwork</dt><dd><p>A new BooleanNetwork with the specified edge controls applied.</p>
</dd>
</dl>
</section>
<section id="id31">
<h3>Raises<a class="headerlink" href="#id31" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>ValueError</dt><dd><p>If input lengths do not match, indices are invalid, or edge values are
not in {0, 1}.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.update_single_node">
<span class="sig-name descname"><span class="pre">update_single_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_regulators</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.update_single_node"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.update_single_node" title="Link to this definition"></a></dt>
<dd><p>Update the state of a single node.</p>
<p>The new state is obtained by applying the Boolean update function to the
states of its regulators.</p>
<section id="id32">
<h3>Parameters<a class="headerlink" href="#id32" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>index<span class="classifier">int</span></dt><dd><p>Index of the node to update.</p>
</dd>
<dt>states_regulators<span class="classifier">sequence of int</span></dt><dd><p>Binary states of the node’s regulators.</p>
</dd>
</dl>
</section>
<section id="id33">
<h3>Returns<a class="headerlink" href="#id33" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>int</dt><dd><p>Updated state of the node (0 or 1).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.update_network_synchronously">
<span class="sig-name descname"><span class="pre">update_network_synchronously</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.update_network_synchronously"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.update_network_synchronously" title="Link to this definition"></a></dt>
<dd><p>Perform a synchronous update of the Boolean network.</p>
<section id="id34">
<h3>Parameters<a class="headerlink" href="#id34" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>state<span class="classifier">sequence of int</span></dt><dd><p>Binary state vector of length <code class="docutils literal notranslate"><span class="pre">N</span></code>.</p>
</dd>
</dl>
</section>
<section id="id35">
<h3>Returns<a class="headerlink" href="#id35" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>Updated state vector.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.update_network_SDDS">
<span class="sig-name descname"><span class="pre">update_network_SDDS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.update_network_SDDS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.update_network_SDDS" title="Link to this definition"></a></dt>
<dd><p>Perform a stochastic discrete dynamical system (SDDS) update of the network.</p>
<p>This update scheme follows the SDDS formalism: for each node, the
deterministic Boolean update is first computed. If the update would
increase the node’s state, the change occurs with the node-specific
activation probability. If the update would decrease the node’s state,
the change occurs with the node-specific degradation probability.
Otherwise, the node’s state remains unchanged.</p>
<section id="id36">
<h3>Parameters<a class="headerlink" href="#id36" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>state<span class="classifier">sequence of int</span></dt><dd><p>Current network state (binary vector of length <code class="docutils literal notranslate"><span class="pre">N</span></code>).</p>
</dd>
<dt>P<span class="classifier">np.ndarray</span></dt><dd><p>Array of shape <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">2)</span></code>, where <code class="docutils literal notranslate"><span class="pre">P[i,</span> <span class="pre">0]</span></code> is the activation
probability and <code class="docutils literal notranslate"><span class="pre">P[i,</span> <span class="pre">1]</span></code> is the degradation probability for node <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p>
</dd>
<dt>rng<span class="classifier">optional</span></dt><dd><p>Random number generator or seed, passed to <code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id37">
<h3>Returns<a class="headerlink" href="#id37" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>Updated network state after one stochastic SDDS update.</p>
</dd>
</dl>
</section>
<section id="id38">
<h3>Notes<a class="headerlink" href="#id38" title="Link to this heading"></a></h3>
<p>This implementation follows the SDDS framework introduced in:</p>
<p>Murrugarra, D., Veliz-Cuba, A., Aguilar, B., Arat, S., &amp; Laubenbacher, R.
(2012). <em>Modeling stochasticity and variability in gene regulatory networks</em>.
EURASIP Journal on Bioinformatics and Systems Biology, 2012(1), 5.</p>
<p>The method assumes that <code class="docutils literal notranslate"><span class="pre">state</span></code> is a valid binary vector and that
<code class="docutils literal notranslate"><span class="pre">P</span></code> has the correct shape; no additional validation is performed
for performance reasons.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.get_steady_states_asynchronous_exact">
<span class="sig-name descname"><span class="pre">get_steady_states_asynchronous_exact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stochastic_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iterations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.get_steady_states_asynchronous_exact"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.get_steady_states_asynchronous_exact" title="Link to this definition"></a></dt>
<dd><p>Compute the steady states and basin probabilities under general asynchronous update.</p>
<p>This method exhaustively constructs the asynchronous state transition graph
(STG) of the Boolean network under a general asynchronous update scheme,
where nodes are selected for update according to given propensities.
The resulting Markov chain is solved exactly using an iterative
Gauss–Seidel scheme to obtain absorption probabilities into steady states.</p>
<section id="id39">
<h3>Parameters<a class="headerlink" href="#id39" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>stochastic_weights<span class="classifier">sequence of float or None, optional</span></dt><dd><p>Relative update propensities for each node. If None (default),
all nodes are updated with equal probability. The weights are
normalized internally.</p>
</dd>
<dt>max_iterations<span class="classifier">int, optional</span></dt><dd><p>Maximum number of Gauss–Seidel iterations used to compute absorption
probabilities before declaring non-convergence.</p>
</dd>
<dt>tol<span class="classifier">float, optional</span></dt><dd><p>Convergence tolerance for the infinity norm of probability updates.</p>
</dd>
</dl>
<p>s
Returns
——-
dict</p>
<blockquote>
<div><p>Dictionary with the following entries:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;SteadyStates&quot;</span></code> : list of int  
Decimal representations of steady states.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;NumberOfSteadyStates&quot;</span></code> : int  
Total number of steady states.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;BasinSizes&quot;</span></code> : np.ndarray  
Fraction of the state space converging to each steady state.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;STGAsynchronous&quot;</span></code> : dict  
Asynchronous state transition graph represented as a Markov kernel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;FinalTransitionProbabilities&quot;</span></code> : np.ndarray  
Absorption probabilities from each state into each steady state.</p></li>
</ul>
</div></blockquote>
</section>
<section id="id40">
<h3>Raises<a class="headerlink" href="#id40" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>RuntimeError</dt><dd><p>If the iterative solver does not converge within <code class="docutils literal notranslate"><span class="pre">max_iterations</span></code>.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.get_steady_states_asynchronous">
<span class="sig-name descname"><span class="pre">get_steady_states_asynchronous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search_depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DEBUG</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.get_steady_states_asynchronous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.get_steady_states_asynchronous" title="Link to this definition"></a></dt>
<dd><p>Approximate steady states of a Boolean network under asynchronous updates.</p>
<p>This method performs a Monte Carlo–style exploration of the asynchronous
state space by simulating asynchronous updates from a collection of initial
states. Each simulation proceeds until a steady state is reached or until
a maximum search depth is exceeded.</p>
<p>Unlike <code class="docutils literal notranslate"><span class="pre">get_steady_states_asynchronous_exact</span></code>, this method does <em>not</em>
exhaustively explore the full state space and does not guarantee that all
steady states will be found. It is intended for large networks where exact
enumeration is infeasible.</p>
<section id="id41">
<h3>Parameters<a class="headerlink" href="#id41" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>nsim<span class="classifier">int, optional</span></dt><dd><p>Number of asynchronous simulations to perform (default is 500).</p>
</dd>
<dt>initial_states<span class="classifier">sequence of int or None, optional</span></dt><dd><p>Initial states to use for the simulations, given as decimal
representations of network states. If None (default), <code class="docutils literal notranslate"><span class="pre">nsim</span></code>
random initial states are generated.</p>
</dd>
<dt>search_depth<span class="classifier">int, optional</span></dt><dd><p>Maximum number of asynchronous update steps per simulation before
giving up on convergence (default is 50).</p>
</dd>
<dt>DEBUG<span class="classifier">bool, optional</span></dt><dd><p>If True, print detailed debugging information during simulation.</p>
</dd>
<dt>rng<span class="classifier">optional</span></dt><dd><p>Random number generator or seed, passed to <code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id42">
<h3>Returns<a class="headerlink" href="#id42" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>dict</dt><dd><p>Dictionary with the following entries:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;SteadyStates&quot;</span></code> : list of int  
Decimal representations of steady states encountered.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;NumberOfSteadyStates&quot;</span></code> : int  
Number of unique steady states found.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;BasinSizes&quot;</span></code> : list of int  
Counts of how many simulations converged to each steady state.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;STGAsynchronous&quot;</span></code> : dict  
Partial cache of asynchronous transitions encountered during
simulation. Keys are <code class="docutils literal notranslate"><span class="pre">(state,</span> <span class="pre">node_index)</span></code> and values are
successor states (all in decimal form).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;InitialSamplePoints&quot;</span></code> : list of int  
Decimal initial states used in the simulations (either provided
explicitly or generated randomly).</p></li>
</ul>
</dd>
</dl>
</section>
<section id="id43">
<h3>Notes<a class="headerlink" href="#id43" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>This method detects only <em>steady states</em> (fixed points). If the
asynchronous dynamics contain limit cycles, simulations may fail
to converge within <code class="docutils literal notranslate"><span class="pre">search_depth</span></code>.</p></li>
<li><p>The returned asynchronous transition graph is generally incomplete
and should be interpreted as a cache of explored transitions rather
than the full STG.</p></li>
</ul>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.get_steady_states_asynchronous_given_one_initial_condition">
<span class="sig-name descname"><span class="pre">get_steady_states_asynchronous_given_one_initial_condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_condition</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stochastic_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search_depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DEBUG</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.get_steady_states_asynchronous_given_one_initial_condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.get_steady_states_asynchronous_given_one_initial_condition" title="Link to this definition"></a></dt>
<dd><p>Approximate steady states reachable from a single initial condition under
asynchronous updates.</p>
<p>This method performs multiple asynchronous simulations starting from the
same initial condition. In each simulation, nodes are updated one at a time
according to either a uniform random order or node-specific stochastic
update propensities. The simulation proceeds until a steady state is reached
or a maximum number of update steps is exceeded.</p>
<p>The method is sampling-based and does <em>not</em> guarantee that all reachable
steady states are found. It is intended for exploratory analysis and for
networks where exhaustive asynchronous analysis is infeasible.</p>
<section id="id44">
<h3>Parameters<a class="headerlink" href="#id44" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>initial_condition<span class="classifier">int or sequence of int, optional</span></dt><dd><p>Initial network state. If an integer is provided, it is interpreted as
the decimal encoding of a Boolean state. If a sequence is provided, it
must be a binary vector of length <code class="docutils literal notranslate"><span class="pre">N</span></code>. Default is 0.</p>
</dd>
<dt>nsim<span class="classifier">int, optional</span></dt><dd><p>Number of asynchronous simulation runs (default is 500).</p>
</dd>
<dt>stochastic_weights<span class="classifier">sequence of float or None, optional</span></dt><dd><p>Relative update propensities for each node. If provided, must have
length <code class="docutils literal notranslate"><span class="pre">N</span></code> and be strictly positive. The weights are normalized
internally. If None (default), nodes are updated uniformly at random.</p>
</dd>
<dt>search_depth<span class="classifier">int, optional</span></dt><dd><p>Maximum number of asynchronous update steps per simulation.</p>
</dd>
<dt>DEBUG<span class="classifier">bool, optional</span></dt><dd><p>If True, print detailed debugging information during simulation.</p>
</dd>
<dt>rng<span class="classifier">optional</span></dt><dd><p>Random number generator or seed, passed to <code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id45">
<h3>Returns<a class="headerlink" href="#id45" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>dict</dt><dd><p>Dictionary with the following entries:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;SteadyStates&quot;</span></code> : list of int  
Decimal representations of steady states reached.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;NumberOfSteadyStates&quot;</span></code> : int  
Number of unique steady states found.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;BasinSizes&quot;</span></code> : list of int  
Number of simulations converging to each steady state.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;TransientTimes&quot;</span></code> : list of list of int  
For each steady state, a list of transient lengths (number of update
steps before convergence).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;STGAsynchronous&quot;</span></code> : dict  
Partial cache of asynchronous transitions encountered during
simulation. Keys are <code class="docutils literal notranslate"><span class="pre">(state,</span> <span class="pre">node_index)</span></code> and values are successor
states (all in decimal form).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;UpdateQueues&quot;</span></code> : list of list of int  
For each simulation, the sequence of visited states (in decimal form).</p></li>
</ul>
</dd>
</dl>
</section>
<section id="id46">
<h3>Notes<a class="headerlink" href="#id46" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Only steady states (fixed points) are detected. If the asynchronous
dynamics contain limit cycles, simulations may fail to converge within
<code class="docutils literal notranslate"><span class="pre">search_depth</span></code>.</p></li>
<li><p>The returned asynchronous transition graph is incomplete and represents
only transitions encountered during sampling.</p></li>
</ul>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous">
<span class="sig-name descname"><span class="pre">get_attractors_synchronous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_sample_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_steps_timeout</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">INITIAL_SAMPLE_POINTS_AS_BINARY_VECTORS</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">USE_NUMBA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.get_attractors_synchronous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous" title="Link to this definition"></a></dt>
<dd><p>Approximate synchronous attractors of a Boolean network via sampling.</p>
<p>This method estimates the synchronous attractors (fixed points and cycles)
of a Boolean network by simulating synchronous updates from a collection
of initial states. For each simulation, the network is updated until an
attractor is reached or a maximum number of update steps is exceeded.</p>
<p>The method is sampling-based and does <em>not</em> guarantee that all attractors
are found. Basin sizes are lower-bound estimates based on the sampled
initial conditions.</p>
<p>If Numba is available and <code class="docutils literal notranslate"><span class="pre">USE_NUMBA=True</span></code>, synchronous updates are
accelerated using a compiled kernel.</p>
<section id="id47">
<h3>Parameters<a class="headerlink" href="#id47" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>nsim<span class="classifier">int, optional</span></dt><dd><p>Number of initial conditions to simulate (default is 500). Ignored if
<code class="docutils literal notranslate"><span class="pre">initial_sample_points</span></code> is provided.</p>
</dd>
<dt>initial_sample_points<span class="classifier">sequence of int or sequence of sequence of int, optional</span></dt><dd><p>Initial states to use. If provided, its length determines the number
of simulations. Interpretation depends on
<code class="docutils literal notranslate"><span class="pre">INITIAL_SAMPLE_POINTS_AS_BINARY_VECTORS</span></code>.</p>
</dd>
<dt>n_steps_timeout<span class="classifier">int, optional</span></dt><dd><p>Maximum number of synchronous update steps per simulation before
declaring a timeout (default is 1000).</p>
</dd>
<dt>INITIAL_SAMPLE_POINTS_AS_BINARY_VECTORS<span class="classifier">bool, optional</span></dt><dd><p>If True, <code class="docutils literal notranslate"><span class="pre">initial_sample_points</span></code> are interpreted as binary vectors;
otherwise they are interpreted as decimal-encoded states.</p>
</dd>
<dt>USE_NUMBA<span class="classifier">bool, optional</span></dt><dd><p>If True (default) and Numba is available, use a Numba-accelerated
synchronous update kernel.</p>
</dd>
<dt>rng<span class="classifier">optional</span></dt><dd><p>Random number generator or seed, passed to <code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id48">
<h3>Returns<a class="headerlink" href="#id48" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>dict</dt><dd><p>Dictionary with the following entries:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Attractors&quot;</span></code> : list of list of int  
Attractors found, each represented as a list of decimal states
(cycles are given in cyclic order).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;NumberOfAttractors&quot;</span></code> : int  
Number of distinct attractors found.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;BasinSizes&quot;</span></code> : list of int  
Number of sampled initial conditions converging to each attractor.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;AttractorDict&quot;</span></code> : dict  
Mapping from visited states (decimal) to attractor index.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;InitialSamplePoints&quot;</span></code> : list of int  
Decimal initial states used for sampling.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;STG&quot;</span></code> : dict  
Sampled synchronous state transition graph
(state → successor state).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;NumberOfTimeouts&quot;</span></code> : int  
Number of simulations that did not converge within
<code class="docutils literal notranslate"><span class="pre">n_steps_timeout</span></code>.</p></li>
</ul>
</dd>
</dl>
</section>
<section id="id49">
<h3>Notes<a class="headerlink" href="#id49" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>This method is intended for networks with long transient dynamics, where
exhaustive synchronous analysis is infeasible.</p></li>
<li><p>Basin sizes are <em>sampling-based estimates</em> and should not be interpreted
as exact proportions of the state space.</p></li>
</ul>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.compute_synchronous_state_transition_graph">
<span class="sig-name descname"><span class="pre">compute_synchronous_state_transition_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">USE_NUMBA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.compute_synchronous_state_transition_graph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.compute_synchronous_state_transition_graph" title="Link to this definition"></a></dt>
<dd><p>Compute the exact synchronous state transition graph (STG).</p>
<p>The STG is stored in <code class="docutils literal notranslate"><span class="pre">self.STG</span></code> as a one-dimensional NumPy array of length
<code class="docutils literal notranslate"><span class="pre">2**N</span></code>, where <code class="docutils literal notranslate"><span class="pre">self.STG[x]</span></code> is the decimal representation of the successor
state reached from state <code class="docutils literal notranslate"><span class="pre">x</span></code> under synchronous updating.</p>
<p>This computation is exact and requires memory proportional to <code class="docutils literal notranslate"><span class="pre">2**N</span></code>.
It is therefore intended for small-to-moderate networks only.</p>
<section id="id50">
<h3>Parameters<a class="headerlink" href="#id50" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>USE_NUMBA<span class="classifier">bool, optional</span></dt><dd><p>If True (default) and Numba is available, use a compiled kernel to
accelerate computation.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous_exact">
<span class="sig-name descname"><span class="pre">get_attractors_synchronous_exact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">USE_NUMBA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.get_attractors_synchronous_exact"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous_exact" title="Link to this definition"></a></dt>
<dd><p>Compute all attractors and their exact basin sizes under synchronous updating.</p>
<p>This method computes the exact synchronous state transition graph (STG) and
analyzes it as a functional graph on <code class="docutils literal notranslate"><span class="pre">2**N</span></code> states. All attractors (cycles),
their basin sizes, and the attractor reached from each state are determined
exactly.</p>
<p>This computation requires memory and time proportional to <code class="docutils literal notranslate"><span class="pre">2**N</span></code> and is
intended for small-to-moderate networks only.</p>
<section id="id51">
<h3>Parameters<a class="headerlink" href="#id51" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>USE_NUMBA<span class="classifier">bool, optional</span></dt><dd><p>If True (default) and Numba is available, use a compiled kernel for
attractor detection.</p>
</dd>
</dl>
</section>
<section id="id52">
<h3>Returns<a class="headerlink" href="#id52" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>dict</dt><dd><p>Dictionary with keys:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Attractors<span class="classifier">list[list[int]]</span></dt><dd><p>Each attractor represented as a list of decimal states forming a cycle.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>NumberOfAttractors<span class="classifier">int</span></dt><dd><p>Total number of attractors.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>BasinSizes<span class="classifier">np.ndarray[float]</span></dt><dd><p>Fraction of all states belonging to each attractor basin.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>AttractorID<span class="classifier">np.ndarray[int]</span></dt><dd><p>For each of the <code class="docutils literal notranslate"><span class="pre">2**N</span></code> states, the index of the attractor it reaches.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>STG<span class="classifier">np.ndarray[int]</span></dt><dd><p>The synchronous state transition graph.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.get_attractors_and_robustness_measures_synchronous_exact">
<span class="sig-name descname"><span class="pre">get_attractors_and_robustness_measures_synchronous_exact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">USE_NUMBA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.get_attractors_and_robustness_measures_synchronous_exact"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.get_attractors_and_robustness_measures_synchronous_exact" title="Link to this definition"></a></dt>
<dd><p>Compute the attractors and exact robustness measures of a synchronously
updated Boolean network.</p>
<p>This method computes the exact synchronous state transition graph (STG)
and analyzes it as a functional graph on <code class="docutils literal notranslate"><span class="pre">2**N</span></code> states. All attractors
(cycles), their basin sizes, and the attractor reached from each state
are determined exactly. Based on this decomposition, exact coherence
and fragility measures are computed for the full network, for each basin
of attraction, and for each attractor.</p>
<p>This computation requires memory and time proportional to <code class="docutils literal notranslate"><span class="pre">2**N</span></code> and is
intended for small-to-moderate networks only.</p>
<section id="id53">
<h3>Parameters<a class="headerlink" href="#id53" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>USE_NUMBA<span class="classifier">bool, optional</span></dt><dd><p>If True (default) and Numba is available, use a compiled kernel for
robustness computation.</p>
</dd>
</dl>
</section>
<section id="id54">
<h3>Returns<a class="headerlink" href="#id54" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>dict</dt><dd><p>Dictionary with keys:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Attractors<span class="classifier">list[list[int]]</span></dt><dd><p>Each attractor represented as a list of decimal states forming a cycle.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>NumberOfAttractors<span class="classifier">int</span></dt><dd><p>Total number of attractors.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>BasinSizes<span class="classifier">np.ndarray[float]</span></dt><dd><p>Fraction of all states belonging to each attractor basin.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>AttractorID<span class="classifier">np.ndarray[int]</span></dt><dd><p>For each of the <code class="docutils literal notranslate"><span class="pre">2**N</span></code> states, the index of the attractor it reaches.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Coherence<span class="classifier">float</span></dt><dd><p>Exact global network coherence.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Fragility<span class="classifier">float</span></dt><dd><p>Exact global network fragility.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>BasinCoherence<span class="classifier">np.ndarray[float]</span></dt><dd><p>Exact coherence of each basin of attraction.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>BasinFragility<span class="classifier">np.ndarray[float]</span></dt><dd><p>Exact fragility of each basin of attraction.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>AttractorCoherence<span class="classifier">np.ndarray[float]</span></dt><dd><p>Exact coherence of each attractor.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>AttractorFragility<span class="classifier">np.ndarray[float]</span></dt><dd><p>Exact fragility of each attractor.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.get_attractors_and_robustness_measures_synchronous">
<span class="sig-name descname"><span class="pre">get_attractors_and_robustness_measures_synchronous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_different_IC</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RETURN_ATTRACTOR_COHERENCE</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.get_attractors_and_robustness_measures_synchronous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.get_attractors_and_robustness_measures_synchronous" title="Link to this definition"></a></dt>
<dd><p>Approximate attractors and robustness measures under synchronous updating.</p>
<p>This method samples the attractor landscape by simulating the network from
multiple random initial conditions (ICs) and their single-bit perturbations.
It returns Monte-Carlo approximations of global coherence, fragility, and a
final Hamming-distance-based measure, along with per-basin approximations.
Optionally, it additionally estimates attractor-level coherence and fragility
by perturbing attractor states found during sampling.</p>
<section id="id55">
<h3>Notes<a class="headerlink" href="#id55" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>The attractor set returned is a <em>lower bound</em> on the true number of
attractors, because only the sampled portion of state space is explored.</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&gt;=</span> <span class="pre">64</span></code>, decimal encoding of states may exceed <code class="docutils literal notranslate"><span class="pre">np.int64</span></code> and
this method uses bitstrings (type <code class="docutils literal notranslate"><span class="pre">str</span></code>) as state identifiers.</p></li>
</ul>
</section>
<section id="id56">
<h3>Parameters<a class="headerlink" href="#id56" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>number_different_IC<span class="classifier">int, optional</span></dt><dd><p>Number of random initial conditions to sample (default is 500). For each
IC, the method also simulates one randomly chosen single-bit perturbation.</p>
</dd>
<dt>RETURN_ATTRACTOR_COHERENCE<span class="classifier">bool, optional</span></dt><dd><p>If True (default), also compute attractor-level coherence and fragility
by perturbing attractor states found during sampling.</p>
</dd>
<dt>rng<span class="classifier">None or numpy.random.Generator, optional</span></dt><dd><p>Random number generator or seed-like object. Passed to
<code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id57">
<h3>Returns<a class="headerlink" href="#id57" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>dict</dt><dd><p>Dictionary with keys:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Attractors<span class="classifier">list[list[int]] or list[list[str]]</span></dt><dd><p>List of discovered attractors, each represented as a list of states
forming a cycle. States are decimals (<code class="docutils literal notranslate"><span class="pre">int</span></code>) for <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&lt;</span> <span class="pre">64</span></code> and
bitstrings (<code class="docutils literal notranslate"><span class="pre">str</span></code>) for <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&gt;=</span> <span class="pre">64</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>LowerBoundOfNumberOfAttractors<span class="classifier">int</span></dt><dd><p>Number of distinct attractors discovered (a lower bound on the true
number of attractors).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>BasinSizesApproximation<span class="classifier">np.ndarray[float]</span></dt><dd><p>Approximate basin size (fraction of sampled trajectories that end in
each attractor). Sums to ~1 over discovered attractors.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>CoherenceApproximation<span class="classifier">float</span></dt><dd><p>Approximate global coherence: probability that a random IC and its
single-bit perturbation reach the same attractor.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>FragilityApproximation<span class="classifier">float</span></dt><dd><p>Approximate global fragility: expected normalized difference between
reached attractors when the IC and perturbation reach different
attractors. Normalized by <code class="docutils literal notranslate"><span class="pre">N</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>FinalHammingDistanceApproximation<span class="classifier">float</span></dt><dd><p>Approximate final Hamming distance between the two periodic
trajectories when comparing the IC and its perturbation. This is a
<em>distance</em> in [0, 1], where 0 means identical and 1 means completely
different.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>BasinCoherenceApproximation<span class="classifier">np.ndarray[float]</span></dt><dd><p>Approximate coherence per basin (same definition as coherence but
conditioned on having reached that basin).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>BasinFragilityApproximation<span class="classifier">np.ndarray[float]</span></dt><dd><p>Approximate fragility per basin (same definition as fragility but
conditioned on having reached that basin).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>AttractorCoherence<span class="classifier">np.ndarray[float], optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">RETURN_ATTRACTOR_COHERENCE</span></code> is True: estimated attractor-level
coherence (probability that a single-bit perturbation of an attractor
state returns to the same attractor).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>AttractorFragility<span class="classifier">np.ndarray[float], optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">RETURN_ATTRACTOR_COHERENCE</span></code> is True: estimated attractor-level
fragility based on differences between the original attractor and the
attractor reached after perturbation.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Link to this heading"></a></h3>
<p>Park, K. H., Costa, F. X., Rocha, L. M., Albert, R., &amp; Rozum, J. C. (2023).
Models of cell processes are far from the edge of chaos. PRX Life, 1(2), 023009.</p>
<p>Bavisetty, V. S. N., Wheeler, M., &amp; Kadelka, C. (2025).
Attractors are less stable than their basins: Canalization creates a coherence
gap in gene regulatory networks. bioRxiv 2025-11.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.get_derrida_value">
<span class="sig-name descname"><span class="pre">get_derrida_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">EXACT</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">USE_NUMBA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.get_derrida_value"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.get_derrida_value" title="Link to this definition"></a></dt>
<dd><p>Compute the Derrida value of a Boolean network.</p>
<p>The Derrida value measures the average Hamming distance between the
one-step synchronous updates of two states that differ by a single-bit
perturbation. It quantifies the short-term sensitivity of the network
dynamics to small perturbations.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">EXACT</span></code> is True, the Derrida value is computed exactly as the mean
(unnormalized) average sensitivity of the Boolean update functions.
Otherwise, it is approximated via Monte Carlo simulation.</p>
<section id="id58">
<h3>Parameters<a class="headerlink" href="#id58" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>nsim<span class="classifier">int, optional</span></dt><dd><p>Number of Monte Carlo simulations to perform (default is 1000).
Ignored if <code class="docutils literal notranslate"><span class="pre">EXACT</span></code> is True.</p>
</dd>
<dt>EXACT<span class="classifier">bool, optional</span></dt><dd><p>If True, compute the exact Derrida value. If False (default),
approximate the Derrida value using Monte Carlo simulation.</p>
</dd>
<dt>USE_NUMBA<span class="classifier">bool, optional</span></dt><dd><p>If True (default) and Numba is available, use a compiled kernel for
Monte Carlo simulation.</p>
</dd>
<dt>rng<span class="classifier">None or np.random.Generator, optional</span></dt><dd><p>Random number generator, passed through <code class="docutils literal notranslate"><span class="pre">utils._coerce_rng</span></code>.</p>
</dd>
</dl>
</section>
<section id="id59">
<h3>Returns<a class="headerlink" href="#id59" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>float</dt><dd><p>The Derrida value, defined as the average Hamming distance after
one synchronous update following a single-bit perturbation.</p>
</dd>
</dl>
</section>
<section id="id60">
<h3>References<a class="headerlink" href="#id60" title="Link to this heading"></a></h3>
<p>Derrida, B., &amp; Pomeau, Y. (1986).
Random networks of automata: a simple annealed approximation.
<em>Europhysics Letters</em>, 1(2), 45.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous_exact_non_autonomous">
<span class="sig-name descname"><span class="pre">get_attractors_synchronous_exact_non_autonomous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">non_periodic_component</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">periodic_component</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.get_attractors_synchronous_exact_non_autonomous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous_exact_non_autonomous" title="Link to this definition"></a></dt>
<dd><p>desc.</p>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>non_periodic_component (list | np.array): desc.</p></li>
<li><p>periodic_component (list | np.array): desc.</p></li>
</ul>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul>
<li><p>dict[str:Variant]: A dictionary containing:</p>
<blockquote>
<div><ul class="simple">
<li><p>Attractors (list[list[tuple[int, int]]]): List of attractors
where each attractor is repesented as a list of integer pairs
forming the cycle. The first value in each pair represents
the decimal value of the input pattern, and the second value
represents the decimal value of the state.</p></li>
<li><p>NumberOfAttractors (int): Total number of unique attractors.</p></li>
<li><p>BasinSizes (list[int]): List of counts for each attractor.</p></li>
<li><p>AttractorDict (dict[tuple[int, int]:int]): Dictionary mapping
each state value pair (in decimal) to its attractor index.</p></li>
<li><p>STG (dict[int:int]): The state transition graph as a dictionary,
with each state represented by its decimal pair representation.</p></li>
<li><p>InitialStatesPeriodic (list[int]): The set of unique initial
states in decimal format after evaluating the non-periodic
component of the input sequence. Used as initial states for
the evaluation of the periodic component.</p></li>
<li><p>FormattedAttractors (list[list[list[int]]]): List of attractors
represented as a list of binary vectors. The values of the
attractor decimal pairs are concatenated into a single vector.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous_exact_with_external_inputs">
<span class="sig-name descname"><span class="pre">get_attractors_synchronous_exact_with_external_inputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">input_patterns:</span> <span class="pre">[&lt;class</span> <span class="pre">'list'&gt;,</span> <span class="pre">&lt;built-in</span> <span class="pre">function</span> <span class="pre">array&gt;],</span> <span class="pre">starting_states:</span> <span class="pre">[&lt;class</span> <span class="pre">'list'&gt;,</span> <span class="pre">&lt;built-in</span> <span class="pre">function</span> <span class="pre">array&gt;,</span> <span class="pre">None]</span> <span class="pre">=</span> <span class="pre">None</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="reference internal" href="_modules/boolforge/boolean_network.html#BooleanNetwork.get_attractors_synchronous_exact_with_external_inputs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#boolforge.boolean_network.BooleanNetwork.get_attractors_synchronous_exact_with_external_inputs" title="Link to this definition"></a></dt>
<dd><p>desc.</p>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>input_patterns (list | np.array): desc.</p></li>
<li><p>starting_states (list | np.array | None, optional): desc.</p></li>
</ul>
</div></blockquote>
<p><strong>Returns:</strong></p>
<blockquote>
<div><ul>
<li><p>dict[str:Variant]: A dictionary containing:</p>
<blockquote>
<div><ul class="simple">
<li><p>Attractors (list[list[tuple[int, int]]]): List of attractors
(each attractor is repesented as a list of integer pairs
forming the cycle). The first value in each pair represents
the decimal value of the input pattern, and the second value
represents the decimal value of the state.</p></li>
<li><p>NumberOfAttractors (int): Total number of unique attractors.</p></li>
<li><p>BasinSizes (list[int]): List of counts for each attractor.</p></li>
<li><p>AttractorDict (dict[tuple[int, int]:int]): Dictionary mapping
each state value pair (in decimal) to its attractor index.</p></li>
<li><p>STG (dict[int:int]): The state transition graph as a dictionary,
with each state represented by its decimal pair representation.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</dd></dl>

</section>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="boolean_function.html" class="btn btn-neutral float-left" title="Boolean Function" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="generate.html" class="btn btn-neutral float-right" title="Generate" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Claus Kadelka, Benjamin Coberly.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
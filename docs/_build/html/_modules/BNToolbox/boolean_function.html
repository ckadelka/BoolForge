

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BNToolbox.boolean_function &mdash; BooleanNetworkToolbox 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            BooleanNetworkToolbox
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../bf.html">Boolean Function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bn.html">Boolean Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generate.html">Generate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utils.html">Utils</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">BooleanNetworkToolbox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">BNToolbox.boolean_function</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for BNToolbox.boolean_function</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Tue Aug 12 11:03:49 2025</span>
<span class="sd">Last Edited on Thu Aug 14 2025</span>

<span class="sd">@author: Benjamin Coberly</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">BNToolbox.utils</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">utils</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">cana.boolean_node</span>
    <span class="n">__LOADED_CANA__</span><span class="o">=</span><span class="kc">True</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The module cana cannot be found. Ensure it is installed to use all functionality of this toolbox.&#39;</span><span class="p">)</span>
    <span class="n">__LOADED_CANA__</span><span class="o">=</span><span class="kc">False</span>
    
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pyboolnet</span><span class="c1"># import bnet2primes, primes2bnet</span>
    <span class="n">__LOADED_PYBOOLNET__</span><span class="o">=</span><span class="kc">True</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The module pyboolnet cannot be found. Ensure it is installed to use all functionality of this toolbox.&#39;</span><span class="p">)</span>
    <span class="n">__LOADED_PYBOOLNET__</span><span class="o">=</span><span class="kc">False</span>

<div class="viewcode-block" id="cana_BooleanNode_to_BooleanFunction">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.cana_BooleanNode_to_BooleanFunction">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cana_BooleanNode_to_BooleanFunction</span><span class="p">(</span><span class="n">BooleanNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compatability method: Transforms an instance of cana.boolean_node.BooleanNode to an instance of the class BooleanFunction, used in this toolbox.</span>

<span class="sd">    Returns:</span>
<span class="sd">        - An instance of BooleanFunction</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">BooleanFunction</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">BooleanNode</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span></div>



<div class="viewcode-block" id="get_layer_structure_from_can_outputs">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.get_layer_structure_from_can_outputs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_layer_structure_from_can_outputs</span><span class="p">(</span><span class="n">can_outputs</span><span class="p">):</span>
    <span class="n">canalizing_depth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">can_outputs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">canalizing_depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">size_of_layer</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">layer_structure</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">canalizing_depth</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">can_outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">can_outputs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">size_of_layer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">layer_structure</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size_of_layer</span><span class="p">)</span>
            <span class="n">size_of_layer</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">layer_structure</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size_of_layer</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">layer_structure</span></div>



<div class="viewcode-block" id="BooleanFunction">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BooleanFunction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class representing a Boolean function.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        - f (list or numpy array): A list of length 2^n representing the outputs of a Boolean function with n inputs.</span>
<span class="sd">    </span>
<span class="sd">    Members:</span>
<span class="sd">        - f (list or numpy array): As passed by the constructor.</span>
<span class="sd">        - n (int): The number of inputs for the Boolean function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span> <span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="s2">&quot;f must be either a list or numpy array&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;f cannot be empty&quot;</span>
        <span class="n">_n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span> <span class="o">-</span> <span class="n">_n</span> <span class="o">&lt;=</span> <span class="mf">0.000001</span><span class="p">,</span> <span class="s2">&quot;f must be of size 2^n, n &gt;= 0&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">_n</span>
    
<div class="viewcode-block" id="BooleanFunction.to_cana_BooleanNode">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.to_cana_BooleanNode">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_cana_BooleanNode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compatability method: Transforms an instance of this class to an instance of cana.boolean_node.BooleanNode</span>

<span class="sd">        Returns:</span>
<span class="sd">            - An instance of cana.boolean_node.BooleanNode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__LOADED_CANA__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cana</span><span class="o">.</span><span class="n">boolean_node</span><span class="o">.</span><span class="n">BooleanNode</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The method </span><span class="se">\&#39;</span><span class="s1">to_cana_BooleanNode</span><span class="se">\&#39;</span><span class="s1"> requires the module cana, which cannot be found. Ensure it is installed to use this functionality.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    
<div class="viewcode-block" id="BooleanFunction.is_constant">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.is_constant">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether a Boolean function is constant.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            - bool: True if f is constant (all outputs are 0 or all are 1), False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)]</span></div>

    
<div class="viewcode-block" id="BooleanFunction.is_degenerated">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.is_degenerated">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_degenerated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if a Boolean function contains non-essential variables.</span>

<span class="sd">        A variable is non-essential if the function&#39;s output does not depend on it.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            - bool: True if f contains at least one non-essential variable, False if all variables are essential.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">dummy_add</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">))</span>
            <span class="n">dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">))</span> <span class="o">//</span> <span class="n">dummy_add</span>
            <span class="n">depends_on_i</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dummy</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">dummy_add</span><span class="p">]:</span>
                        <span class="n">depends_on_i</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="n">depends_on_i</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="BooleanFunction.get_essential_variables">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.get_essential_variables">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_essential_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the indices of essential variables in a Boolean function.</span>

<span class="sd">        A variable is essential if changing its value (while holding the others constant) can change the output of f.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            - list: List of indices corresponding to the essential variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">essential_variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">dummy_add</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">))</span>
            <span class="n">dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">))</span> <span class="o">//</span> <span class="n">dummy_add</span>
            <span class="n">depends_on_i</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dummy</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">dummy_add</span><span class="p">]:</span>
                        <span class="n">depends_on_i</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="n">depends_on_i</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">essential_variables</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">essential_variables</span> </div>


<div class="viewcode-block" id="BooleanFunction.get_number_of_essential_variables">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.get_number_of_essential_variables">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_number_of_essential_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number of essential variables in a Boolean function.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            - int: The number of essential variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_essential_variables</span><span class="p">())</span></div>

    
<div class="viewcode-block" id="BooleanFunction.is_monotonic">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.is_monotonic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_monotonic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GET_DETAILS</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if a Boolean function is monotonic.</span>

<span class="sd">        A Boolean function is monotonic if it is monotonic in each variable. </span>
<span class="sd">        That is, if for all i=1,...,n: f(x_1,...,x_i=0,...,x_n) &gt;= f(x_1,...,x_i=1,...,x_n) for all (x_1,...,x_n) or f(x_1,...,x_i=0,...,x_n) &lt;= f(x_1,...,x_i=1,...,x_n) for all (x_1,...,x_n)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            - GET_DETAILS (bool, optional): If True, the type of each variable (increasing, decreasing, not monotonic, not essential) is returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            - bool: True if f contains at least one non-essential variable, False if all variables are essential.</span>
<span class="sd">            - list: List containing the type of regulation of each variable. Only returned if GET_DETAILS==True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">monotonic</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">dummy_add</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">))</span>
            <span class="n">dummy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">))</span><span class="o">//</span><span class="n">dummy_add</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">dummy</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">dummy</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">min_diff</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
            <span class="n">max_diff</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">min_diff</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">max_diff</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">monotonic</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;not essential&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">min_diff</span><span class="o">==-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">max_diff</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">monotonic</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;not monotonic&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">min_diff</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">max_diff</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">monotonic</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;increasing&#39;</span><span class="p">)</span>            
            <span class="k">elif</span> <span class="n">min_diff</span><span class="o">==-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">max_diff</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">monotonic</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;decreasing&#39;</span><span class="p">)</span>   
        <span class="k">if</span> <span class="n">GET_DETAILS</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;not essential&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">monotonic</span><span class="p">,</span><span class="n">monotonic</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;not essential&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">monotonic</span></div>

    
<div class="viewcode-block" id="BooleanFunction.get_symmetry_groups">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.get_symmetry_groups">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_symmetry_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_side_of_truth_table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine all symmetry groups of input variables for a Boolean function.</span>

<span class="sd">        Two variables are in the same symmetry group if swapping their values does not change the output</span>
<span class="sd">        of the function for any input of the other variables.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            - left_side_of_truth_table (optional, array-like): Precomputed left-hand side of the truth table (2^n x n). If not provided or if its shape does not match, it will be computed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            - list: A list of lists where each inner list contains indices of variables that form a symmetry group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">left_side_of_truth_table</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">left_side_of_truth_table</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="ow">or</span> <span class="n">left_side_of_truth_table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">):</span>
            <span class="n">left_side_of_truth_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)))</span>
        <span class="n">symmetry_groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">left_to_check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left_to_check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">symmetry_groups</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
                <span class="n">left_to_check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">left_side_of_truth_table</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">diff</span><span class="p">]:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">left_to_check</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">symmetry_groups</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">symmetry_groups</span></div>

    
<div class="viewcode-block" id="BooleanFunction.get_absolute_bias">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.get_absolute_bias">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_absolute_bias</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the absolute bias of a Boolean function.</span>

<span class="sd">        The absolute bias is defined as \|(sum(f) / 2^(n-1)) - 1|\, which quantifies how far the function&#39;s output distribution</span>
<span class="sd">        deviates from being balanced.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            - float: The absolute bias of the Boolean function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="BooleanFunction.get_average_sensitivity">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.get_average_sensitivity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_average_sensitivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsim</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">EXACT</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">NORMALIZED</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the average sensitivity of a Boolean function.</span>

<span class="sd">        The average sensitivity is equivalent to the Derrida value D(F,1) when the update rule is sampled</span>
<span class="sd">        from the same space. This function can compute the exact sensitivity by exhaustively iterating over all inputs (if EXACT is True)</span>
<span class="sd">        or estimate it via Monte Carlo sampling (if EXACT is False). The result can be normalized by the number of inputs.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            - nsim (int, optional): Number of random samples (default is 10000, used when EXACT is False).</span>
<span class="sd">            - EXACT (bool, optional): If True, compute the exact sensitivity by iterating over all inputs; otherwise, use sampling (default).</span>
<span class="sd">            - NORMALIZED (bool, optional): If True, return the normalized sensitivity (divided by the number of function inputs); otherwise, return the total count.</span>

<span class="sd">        Returns:</span>
<span class="sd">            - float: The (normalized) average sensitivity of the Boolean function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_values</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">EXACT</span><span class="p">:</span>
            <span class="n">left_side_of_truth_table</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))))</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">X</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">left_side_of_truth_table</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">Ydec</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">Ydec</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">NORMALIZED</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_values</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span> <span class="o">/</span> <span class="n">num_values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsim</span><span class="p">):</span>
                <span class="n">xdec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">num_values</span><span class="p">)</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">xdec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                <span class="n">Y</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Y</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="n">Ybin</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">bin2dec</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">xdec</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">Ybin</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">NORMALIZED</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span> <span class="o">/</span> <span class="n">nsim</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="n">s</span> <span class="o">/</span> <span class="n">nsim</span></div>

    
<div class="viewcode-block" id="BooleanFunction.is_canalizing">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.is_canalizing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_canalizing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if a Boolean function is canalizing.</span>

<span class="sd">        A Boolean function f(x_1, ..., x_n) is canalizing if there exists at least one variable x_i and a value a ∈ {0, 1} </span>
<span class="sd">        such that f(x_1, ..., x_i = a, ..., x_n) is constant.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            - bool: True if f is canalizing, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desired_value</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">]</span>
        <span class="n">Atimesf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Atimesf</span> <span class="o">==</span> <span class="n">desired_value</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Atimesf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

    
<div class="viewcode-block" id="BooleanFunction.is_k_canalizing">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.is_k_canalizing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_k_canalizing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if a Boolean function is k-canalizing.</span>

<span class="sd">        A Boolean function is k-canalizing if it has at least k conditionally canalizing variables.</span>
<span class="sd">        This is checked recursively: after fixing a canalizing variable (with a fixed canalizing input that forces the output),</span>
<span class="sd">        the subfunction (core function) must itself be canalizing for the next variable, and so on.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            - k (int): The desired canalizing depth (0 ≤ k ≤ n). Note: every function is 0-canalizing.</span>

<span class="sd">        Returns:</span>
<span class="sd">            - bool: True if f is k-canalizing, False otherwise.</span>
<span class="sd">        </span>
<span class="sd">        References:</span>
<span class="sd">            He, Q., &amp; Macauley, M. (2016). Stratification and enumeration of Boolean functions by canalizing depth.</span>
<span class="sd">                Physica D: Nonlinear Phenomena, 314, 1-8.</span>
<span class="sd">            Dimitrova, E., Stigler, B., Kadelka, C., &amp; Murrugarra, D. (2022). Revealing the canalizing structure of Boolean functions:</span>
<span class="sd">                Algorithms and applications. Automatica, 146, 110630.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">w</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>  <span class="c1"># Hamming weight of f</span>
        <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>  <span class="c1"># constant function</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">desired_value</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>  <span class="c1"># check for canalizing output 1</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">))</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">desired_value</span><span class="p">)</span>
            <span class="n">new_bf</span> <span class="o">=</span> <span class="n">BooleanFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">return</span> <span class="n">new_bf</span><span class="o">.</span><span class="n">is_k_canalizing</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># check for canalizing output 0</span>
                <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">))</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">desired_value</span><span class="p">)</span>
                <span class="n">new_bf</span> <span class="o">=</span> <span class="n">BooleanFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="k">return</span> <span class="n">new_bf</span><span class="o">.</span><span class="n">is_k_canalizing</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_layer_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">can_inputs</span><span class="p">,</span> <span class="n">can_outputs</span><span class="p">,</span> <span class="n">can_order</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">number_layers</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Only for internal use by recursively defined get_layer_structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="p">:</span>  <span class="c1">#eventually the recursion will end here (if self.f is a constant function)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">number_layers</span><span class="p">,</span> <span class="n">can_inputs</span><span class="p">,</span> <span class="n">can_outputs</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">can_order</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">variables</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">desired_value</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">n</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">]</span>

        <span class="n">indices1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="n">desired_value</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">indices0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="n">desired_value</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sorted_order</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices1</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">indices1</span> <span class="o">%</span> <span class="n">n</span><span class="p">)[</span><span class="n">x</span><span class="p">])</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">indices1</span> <span class="o">//</span> <span class="n">n</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sorted_order</span><span class="p">)]</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">new_canalizing_variables</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">indices1</span> <span class="o">%</span> <span class="n">n</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">new_canalizing_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variables</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
            <span class="n">new_canalizing_variables</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">new_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">[]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">INPUT</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices1</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)])))]</span>
            <span class="n">new_bf</span> <span class="o">=</span> <span class="n">BooleanFunction</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_f</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">new_bf</span><span class="o">.</span><span class="n">_get_layer_structure</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">can_inputs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">can_outputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">can_order</span><span class="p">,</span> <span class="n">new_canalizing_variables</span><span class="p">),</span> <span class="n">variables</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_canalizing_variables</span><span class="p">),</span>
                               <span class="n">number_layers</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices0</span><span class="p">):</span>
            <span class="n">sorted_order</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices0</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">indices0</span> <span class="o">%</span> <span class="n">n</span><span class="p">)[</span><span class="n">x</span><span class="p">])</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">indices0</span> <span class="o">//</span> <span class="n">n</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sorted_order</span><span class="p">)]</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">new_canalizing_variables</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">indices0</span> <span class="o">%</span> <span class="n">n</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">new_canalizing_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variables</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
            <span class="n">new_canalizing_variables</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">new_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">[]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">INPUT</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices0</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)])))]</span>
            <span class="n">new_bf</span> <span class="o">=</span> <span class="n">BooleanFunction</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_f</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">new_bf</span><span class="o">.</span><span class="n">_get_layer_structure</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">can_inputs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">can_outputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">can_order</span><span class="p">,</span> <span class="n">new_canalizing_variables</span><span class="p">),</span> <span class="n">variables</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_canalizing_variables</span><span class="p">),</span>
                               <span class="n">number_layers</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1">#or the recursion will end here (if self.f is non-canalizing)</span>
        
            <span class="k">return</span> <span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">number_layers</span><span class="p">,</span> <span class="n">can_inputs</span><span class="p">,</span> <span class="n">can_outputs</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">can_order</span><span class="p">)</span>        

<div class="viewcode-block" id="BooleanFunction.get_layer_structure">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.get_layer_structure">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_layer_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the canalizing layer structure of a Boolean function.</span>

<span class="sd">        This function decomposes a Boolean function into its canalizing layers (standard monomial form)</span>
<span class="sd">        by recursively identifying and removing conditionally canalizing variables.</span>
<span class="sd">        The output includes the canalizing depth, the number of layers, the canalizing inputs and outputs,</span>
<span class="sd">        the core polynomial, and the order of the canalizing variables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            - dict: A dictionary containing:</span>
<span class="sd">                - CanalizingDepth (int): Canalizing depth (number of conditionally canalizing variables).</span>
<span class="sd">                - NumberOfLayers (int): Number of distinct canalizing layers.</span>
<span class="sd">                - CanalizingInputs (np.array): Array of canalizing input values.</span>
<span class="sd">                - CanalizingOutputs (np.array): Array of canalized output values.</span>
<span class="sd">                - CorePolynomial (np.array): The core polynomial (truth table) after removing canalizing variables.</span>
<span class="sd">                - OrderOfCanalizingVariables (np.array): Array of indices representing the order of canalizing variables.</span>
<span class="sd">        </span>
<span class="sd">        References:</span>
<span class="sd">            He, Q., &amp; Macauley, M. (2016). Stratification and enumeration of Boolean functions by canalizing depth.</span>
<span class="sd">                Physica D: Nonlinear Phenomena, 314, 1-8.</span>
<span class="sd">            Dimitrova, E., Stigler, B., Kadelka, C., &amp; Murrugarra, D. (2022). Revealing the canalizing structure of Boolean functions:</span>
<span class="sd">                Algorithms and applications. Automatica, 146, 110630.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s2">&quot;CanalizingDepth&quot;</span><span class="p">,</span> <span class="s2">&quot;NumberOfLayers&quot;</span><span class="p">,</span> <span class="s2">&quot;CanalizingInputs&quot;</span><span class="p">,</span> <span class="s2">&quot;CanalizingOutputs&quot;</span><span class="p">,</span> <span class="s2">&quot;CorePolynomial&quot;</span><span class="p">,</span> <span class="s2">&quot;OrderOfCanalizingVariables&quot;</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_get_layer_structure</span><span class="p">(</span><span class="n">can_inputs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">can_outputs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
                                 <span class="n">can_order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">variables</span><span class="o">=</span><span class="p">[],</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">number_layers</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span></div>


    
<div class="viewcode-block" id="BooleanFunction.get_proportion_of_collectively_canalizing_input_sets">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.get_proportion_of_collectively_canalizing_input_sets">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_proportion_of_collectively_canalizing_input_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">left_side_of_truth_table</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the proportion of k-set canalizing input sets for a Boolean function.</span>

<span class="sd">        For a given k, this function calculates the probability that a randomly chosen set of k inputs canalizes the function,</span>
<span class="sd">        i.e., forces the output regardless of the remaining variables.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            - k (int): The size of the variable set (0 ≤ k ≤ n).</span>
<span class="sd">            - left_side_of_truth_table (optional, array-like): Precomputed left-hand side of the truth table (2^n x n). If not provided or if its shape does not match, it will be computed.</span>
<span class="sd">            - verbose (bool, optional): If True, prints detailed information about canalizing k-sets.</span>

<span class="sd">        Returns:</span>
<span class="sd">            - float: The proportion of k-set canalizing input sets.</span>
<span class="sd">        </span>
<span class="sd">        References:</span>
<span class="sd">            Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023). Collectively canalizing Boolean functions.</span>
<span class="sd">            Advances in Applied Mathematics, 145, 102475.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">())</span>
        <span class="n">desired_value</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">left_side_of_truth_table</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">left_side_of_truth_table</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="ow">or</span> <span class="n">left_side_of_truth_table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">):</span>
            <span class="n">left_side_of_truth_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)))</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">left_side_of_truth_table</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Tk</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">k</span><span class="p">))</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">]</span>
        <span class="n">Ak</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">canalizing_inputs</span> <span class="ow">in</span> <span class="n">Tk</span><span class="p">:</span>
                <span class="n">indices_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">canalizing_inputs</span><span class="p">)</span>
                <span class="n">dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">indices_values</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span> <span class="o">==</span> <span class="n">desired_value</span><span class="p">:</span>
                    <span class="n">Ak</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dummy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">desired_value</span><span class="p">]:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">canalizing_inputs</span><span class="p">,</span> <span class="n">indices_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dummy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">canalizing_inputs</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dummy</span><span class="p">),</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
        <span class="n">Ak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ak</span><span class="p">)</span>
        <span class="n">is_there_canalization</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ak</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">desired_value</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">is_there_canalization</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">is_there_canalization</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.is_kset_canalizing">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.is_kset_canalizing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_kset_canalizing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">left_side_of_truth_table</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if a Boolean function is k-set canalizing.</span>

<span class="sd">        A Boolean function is k-set canalizing if there exists a set of k variables such that setting these variables to specific values</span>
<span class="sd">        forces the output of the function, irrespective of the other n - k inputs.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            - k (int): The size of the variable set (with 0 ≤ k ≤ n).</span>
<span class="sd">            - left_side_of_truth_table (optional, array-like): Precomputed left-hand side of the truth table (2^n x n). If not provided or if its shape does not match, it will be computed.</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">            - bool: True if f is k-set canalizing, False otherwise.</span>

<span class="sd">        References:</span>
<span class="sd">            Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023). Collectively canalizing Boolean functions.</span>
<span class="sd">            Advances in Applied Mathematics, 145, 102475.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">left_side_of_truth_table</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">left_side_of_truth_table</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="ow">or</span> <span class="n">left_side_of_truth_table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">):</span>
            <span class="n">left_side_of_truth_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_proportion_of_collectively_canalizing_input_sets</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">left_side_of_truth_table</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span></div>



<div class="viewcode-block" id="BooleanFunction.get_canalizing_strength">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.get_canalizing_strength">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_canalizing_strength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_side_of_truth_table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the canalizing strength of a Boolean function via exhaustive enumeration.</span>

<span class="sd">        The canalizing strength is defined as a weighted average of the proportions of k-set canalizing inputs for k = 1 to n-1.</span>
<span class="sd">        It is 0 for minimally canalizing functions (e.g., Boolean parity functions) and 1 for maximally canalizing functions</span>
<span class="sd">        (e.g., nested canalizing functions with one layer).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            - left_side_of_truth_table (optional, array-like): Precomputed left-hand side of the truth table (2^n x n). If not provided or if its shape does not match, it will be computed.</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">            - tuple:</span>
<span class="sd">                - float: The canalizing strength of f.</span>
<span class="sd">                - list: A list of the k-set canalizing proportions for k = 1, 2, ..., n-1.</span>
<span class="sd">        </span>
<span class="sd">        References:</span>
<span class="sd">            Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023). Collectively canalizing Boolean functions.</span>
<span class="sd">            Advances in Applied Mathematics, 145, 102475.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nfloat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">nfloat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">,</span> <span class="s2">&quot;f needs to be of length 2^n for some n &gt; 1&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Canalizing strength is only defined for Boolean functions with n &gt; 1 inputs&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">left_side_of_truth_table</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">left_side_of_truth_table</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="ow">or</span> <span class="n">left_side_of_truth_table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">):</span>
            <span class="n">left_side_of_truth_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_proportion_of_collectively_canalizing_input_sets</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">left_side_of_truth_table</span><span class="o">=</span><span class="n">left_side_of_truth_table</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))),</span> <span class="n">res</span></div>

    
<div class="viewcode-block" id="BooleanFunction.get_input_redundancy">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.get_input_redundancy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_input_redundancy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the input redundancy of a Boolean function.</span>

<span class="sd">        The input redundancy quantifies how many inputs are not required to determine the function’s output.</span>
<span class="sd">        Constant functions have an input redundancy of 1 (none of the inputs are needed), whereas parity functions have an input redundancy of 0 (all inputs are necessary).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            - float: Normalized input redundancy in the interval [0, 1].</span>
<span class="sd">        </span>
<span class="sd">        References:</span>
<span class="sd">            [1] Marques-Pita, M., &amp; Rocha, L. M. (2013). Canalization and control in automata networks: body segmentation in Drosophila melanogaster. PloS One, 8(3), e55946.</span>
<span class="sd">            [2] Correia, R. B., Gates, A. J., Wang, X., &amp; Rocha, L. M. (2018). CANA: a python package for quantifying control and canalization in Boolean networks. Frontiers in Physiology, 9, 1046.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__LOADED_CANA__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cana_BooleanNode</span><span class="p">()</span><span class="o">.</span><span class="n">input_redundancy</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The method </span><span class="se">\&#39;</span><span class="s1">get_input_redundancy</span><span class="se">\&#39;</span><span class="s1"> requires the module cana, which cannot be found. Ensure it is installed to use this functionality.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    
<div class="viewcode-block" id="BooleanFunction.get_edge_effectiveness">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.get_edge_effectiveness">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_edge_effectiveness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the edge effectiveness for each regulator of a Boolean function.</span>

<span class="sd">        Edge effectiveness measures how much flipping a given input (regulator) influences the output.</span>
<span class="sd">        Non-essential inputs have an effectiveness of 0, whereas inputs that always flip the output when toggled have an effectiveness of 1.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            - list: A list of n floats in [0, 1] representing the edge effectiveness for each input.</span>

<span class="sd">        References:</span>
<span class="sd">            [1] Marques-Pita, M., &amp; Rocha, L. M. (2013). Canalization and control in automata networks: body segmentation in Drosophila melanogaster. PloS One, 8(3), e55946.</span>
<span class="sd">            [2] Correia, R. B., Gates, A. J., Wang, X., &amp; Rocha, L. M. (2018). CANA: a python package for quantifying control and canalization in Boolean networks. Frontiers in Physiology, 9, 1046.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__LOADED_CANA__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cana_BooleanNode</span><span class="p">()</span><span class="o">.</span><span class="n">edge_effectiveness</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The method </span><span class="se">\&#39;</span><span class="s1">get_edge_effectiveness</span><span class="se">\&#39;</span><span class="s1"> requires the module cana, which cannot be found. Ensure it is installed to use this functionality.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="BooleanFunction.get_effective_degree">
<a class="viewcode-back" href="../../bf.html#BNToolbox.boolean_function.BooleanFunction.get_effective_degree">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_effective_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the effective degree, i.e., the sum of the edge effectivenesses of each regulator, of a Boolean function.</span>

<span class="sd">        Edge effectiveness measures how much flipping a given input (regulator) influences the output.</span>
<span class="sd">        Non-essential inputs have an effectiveness of 0, whereas inputs that always flip the output when toggled have an effectiveness of 1.</span>

<span class="sd">        Returns:</span>
<span class="sd">            - list: A value in [0, 1] representing the effective degree for each input.</span>

<span class="sd">        References:</span>
<span class="sd">            [1] Marques-Pita, M., &amp; Rocha, L. M. (2013). Canalization and control in automata networks: body segmentation in Drosophila melanogaster. PloS One, 8(3), e55946.</span>
<span class="sd">            [2] Correia, R. B., Gates, A. J., Wang, X., &amp; Rocha, L. M. (2018). CANA: a python package for quantifying control and canalization in Boolean networks. Frontiers in Physiology, 9, 1046.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__LOADED_CANA__</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_edge_effectiveness</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The method </span><span class="se">\&#39;</span><span class="s1">get_effective_degree</span><span class="se">\&#39;</span><span class="s1"> requires the module cana, which cannot be found. Ensure it is installed to use this functionality.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Claus Kadelka, Benjamin Coberly.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
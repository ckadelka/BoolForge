

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Boolean Function &mdash; BoolForge 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=8d563738"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Boolean Network" href="bn.html" />
    <link rel="prev" title="Home" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            BoolForge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Documentation:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Boolean Function</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction"><code class="docutils literal notranslate"><span class="pre">BooleanFunction</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.get_absolute_bias"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_absolute_bias()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.get_average_sensitivity"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_average_sensitivity()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.get_canalizing_strength"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_canalizing_strength()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.get_edge_effectiveness"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_edge_effectiveness()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.get_effective_degree"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_effective_degree()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.get_essential_variables"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_essential_variables()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.get_input_redundancy"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_input_redundancy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.get_layer_structure"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_layer_structure()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.get_number_of_essential_variables"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_number_of_essential_variables()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.get_proportion_of_collectively_canalizing_input_sets"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_proportion_of_collectively_canalizing_input_sets()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.get_symmetry_groups"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.get_symmetry_groups()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.is_canalizing"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.is_canalizing()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.is_constant"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.is_constant()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.is_degenerated"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.is_degenerated()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.is_k_canalizing"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.is_k_canalizing()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.is_kset_canalizing"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.is_kset_canalizing()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.is_monotonic"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.is_monotonic()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#BNToolbox.boolean_function.BooleanFunction.to_cana_BooleanNode"><code class="docutils literal notranslate"><span class="pre">BooleanFunction.to_cana_BooleanNode()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#BNToolbox.boolean_function.cana_BooleanNode_to_BooleanFunction"><code class="docutils literal notranslate"><span class="pre">cana_BooleanNode_to_BooleanFunction()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#BNToolbox.boolean_function.get_layer_structure_from_can_outputs"><code class="docutils literal notranslate"><span class="pre">get_layer_structure_from_can_outputs()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bn.html">Boolean Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="generate.html">Generate</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utils</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BoolForge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Boolean Function</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/bf.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-BNToolbox.boolean_function">
<span id="boolean-function"></span><h1>Boolean Function<a class="headerlink" href="#module-BNToolbox.boolean_function" title="Link to this heading"></a></h1>
<p>Created on Tue Aug 12 11:03:49 2025
Last Edited on Thu Aug 14 2025</p>
<p>&#64;author: Benjamin Coberly</p>
<dl class="py class">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">BNToolbox.boolean_function.</span></span><span class="sig-name descname"><span class="pre">BooleanFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class representing a Boolean function.</p>
<dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p>f (list or numpy array): A list of length 2^n representing the outputs of a Boolean function with n inputs.</p></li>
</ul>
</dd>
<dt>Members:</dt><dd><ul class="simple">
<li><p>f (list or numpy array): As passed by the constructor.</p></li>
<li><p>n (int): The number of inputs for the Boolean function.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.get_absolute_bias">
<span class="sig-name descname"><span class="pre">get_absolute_bias</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.get_absolute_bias"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.get_absolute_bias" title="Link to this definition"></a></dt>
<dd><p>Compute the absolute bias of a Boolean function.</p>
<p>The absolute bias is defined as |(sum(f) / 2^(n-1)) - 1|, which quantifies how far the function’s output distribution
deviates from being balanced.</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float: The absolute bias of the Boolean function.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.get_average_sensitivity">
<span class="sig-name descname"><span class="pre">get_average_sensitivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">EXACT</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NORMALIZED</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.get_average_sensitivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.get_average_sensitivity" title="Link to this definition"></a></dt>
<dd><p>Compute the average sensitivity of a Boolean function.</p>
<p>The average sensitivity is equivalent to the Derrida value D(F,1) when the update rule is sampled
from the same space. This function can compute the exact sensitivity by exhaustively iterating over all inputs (if EXACT is True)
or estimate it via Monte Carlo sampling (if EXACT is False). The result can be normalized by the number of inputs.</p>
<dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p>nsim (int, optional): Number of random samples (default is 10000, used when EXACT is False).</p></li>
<li><p>EXACT (bool, optional): If True, compute the exact sensitivity by iterating over all inputs; otherwise, use sampling (default).</p></li>
<li><p>NORMALIZED (bool, optional): If True, return the normalized sensitivity (divided by the number of function inputs); otherwise, return the total count.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float: The (normalized) average sensitivity of the Boolean function.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.get_canalizing_strength">
<span class="sig-name descname"><span class="pre">get_canalizing_strength</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_side_of_truth_table</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.get_canalizing_strength"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.get_canalizing_strength" title="Link to this definition"></a></dt>
<dd><p>Compute the canalizing strength of a Boolean function via exhaustive enumeration.</p>
<p>The canalizing strength is defined as a weighted average of the proportions of k-set canalizing inputs for k = 1 to n-1.
It is 0 for minimally canalizing functions (e.g., Boolean parity functions) and 1 for maximally canalizing functions
(e.g., nested canalizing functions with one layer).</p>
<dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p>left_side_of_truth_table (optional, array-like): Precomputed left-hand side of the truth table (2^n x n). If not provided or if its shape does not match, it will be computed.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>tuple:</dt><dd><ul>
<li><p>float: The canalizing strength of f.</p></li>
<li><p>list: A list of the k-set canalizing proportions for k = 1, 2, …, n-1.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>References:</dt><dd><p>Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023). Collectively canalizing Boolean functions.
Advances in Applied Mathematics, 145, 102475.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.get_edge_effectiveness">
<span class="sig-name descname"><span class="pre">get_edge_effectiveness</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.get_edge_effectiveness"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.get_edge_effectiveness" title="Link to this definition"></a></dt>
<dd><p>Compute the edge effectiveness for each regulator of a Boolean function.</p>
<p>Edge effectiveness measures how much flipping a given input (regulator) influences the output.
Non-essential inputs have an effectiveness of 0, whereas inputs that always flip the output when toggled have an effectiveness of 1.</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>list: A list of n floats in [0, 1] representing the edge effectiveness for each input.</p></li>
</ul>
</dd>
<dt>References:</dt><dd><p>[1] Marques-Pita, M., &amp; Rocha, L. M. (2013). Canalization and control in automata networks: body segmentation in Drosophila melanogaster. PloS One, 8(3), e55946.
[2] Correia, R. B., Gates, A. J., Wang, X., &amp; Rocha, L. M. (2018). CANA: a python package for quantifying control and canalization in Boolean networks. Frontiers in Physiology, 9, 1046.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.get_effective_degree">
<span class="sig-name descname"><span class="pre">get_effective_degree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.get_effective_degree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.get_effective_degree" title="Link to this definition"></a></dt>
<dd><p>Compute the effective degree, i.e., the sum of the edge effectivenesses of each regulator, of a Boolean function.</p>
<p>Edge effectiveness measures how much flipping a given input (regulator) influences the output.
Non-essential inputs have an effectiveness of 0, whereas inputs that always flip the output when toggled have an effectiveness of 1.</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>list: A value in [0, 1] representing the effective degree for each input.</p></li>
</ul>
</dd>
<dt>References:</dt><dd><p>[1] Marques-Pita, M., &amp; Rocha, L. M. (2013). Canalization and control in automata networks: body segmentation in Drosophila melanogaster. PloS One, 8(3), e55946.
[2] Correia, R. B., Gates, A. J., Wang, X., &amp; Rocha, L. M. (2018). CANA: a python package for quantifying control and canalization in Boolean networks. Frontiers in Physiology, 9, 1046.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.get_essential_variables">
<span class="sig-name descname"><span class="pre">get_essential_variables</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.get_essential_variables"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.get_essential_variables" title="Link to this definition"></a></dt>
<dd><p>Determine the indices of essential variables in a Boolean function.</p>
<p>A variable is essential if changing its value (while holding the others constant) can change the output of f.</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>list: List of indices corresponding to the essential variables.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.get_input_redundancy">
<span class="sig-name descname"><span class="pre">get_input_redundancy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.get_input_redundancy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.get_input_redundancy" title="Link to this definition"></a></dt>
<dd><p>Compute the input redundancy of a Boolean function.</p>
<p>The input redundancy quantifies how many inputs are not required to determine the function’s output.
Constant functions have an input redundancy of 1 (none of the inputs are needed), whereas parity functions have an input redundancy of 0 (all inputs are necessary).</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float: Normalized input redundancy in the interval [0, 1].</p></li>
</ul>
</dd>
<dt>References:</dt><dd><p>[1] Marques-Pita, M., &amp; Rocha, L. M. (2013). Canalization and control in automata networks: body segmentation in Drosophila melanogaster. PloS One, 8(3), e55946.
[2] Correia, R. B., Gates, A. J., Wang, X., &amp; Rocha, L. M. (2018). CANA: a python package for quantifying control and canalization in Boolean networks. Frontiers in Physiology, 9, 1046.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.get_layer_structure">
<span class="sig-name descname"><span class="pre">get_layer_structure</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.get_layer_structure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.get_layer_structure" title="Link to this definition"></a></dt>
<dd><p>Determine the canalizing layer structure of a Boolean function.</p>
<p>This function decomposes a Boolean function into its canalizing layers (standard monomial form)
by recursively identifying and removing conditionally canalizing variables.
The output includes the canalizing depth, the number of layers, the canalizing inputs and outputs,
the core polynomial, and the order of the canalizing variables.</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>dict: A dictionary containing:</dt><dd><ul>
<li><p>CanalizingDepth (int): Canalizing depth (number of conditionally canalizing variables).</p></li>
<li><p>NumberOfLayers (int): Number of distinct canalizing layers.</p></li>
<li><p>CanalizingInputs (np.array): Array of canalizing input values.</p></li>
<li><p>CanalizingOutputs (np.array): Array of canalized output values.</p></li>
<li><p>CorePolynomial (np.array): The core polynomial (truth table) after removing canalizing variables.</p></li>
<li><p>OrderOfCanalizingVariables (np.array): Array of indices representing the order of canalizing variables.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>References:</dt><dd><dl class="simple">
<dt>He, Q., &amp; Macauley, M. (2016). Stratification and enumeration of Boolean functions by canalizing depth.</dt><dd><p>Physica D: Nonlinear Phenomena, 314, 1-8.</p>
</dd>
<dt>Dimitrova, E., Stigler, B., Kadelka, C., &amp; Murrugarra, D. (2022). Revealing the canalizing structure of Boolean functions:</dt><dd><p>Algorithms and applications. Automatica, 146, 110630.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.get_number_of_essential_variables">
<span class="sig-name descname"><span class="pre">get_number_of_essential_variables</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.get_number_of_essential_variables"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.get_number_of_essential_variables" title="Link to this definition"></a></dt>
<dd><p>Count the number of essential variables in a Boolean function.</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>int: The number of essential variables.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.get_proportion_of_collectively_canalizing_input_sets">
<span class="sig-name descname"><span class="pre">get_proportion_of_collectively_canalizing_input_sets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left_side_of_truth_table</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.get_proportion_of_collectively_canalizing_input_sets"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.get_proportion_of_collectively_canalizing_input_sets" title="Link to this definition"></a></dt>
<dd><p>Compute the proportion of k-set canalizing input sets for a Boolean function.</p>
<p>For a given k, this function calculates the probability that a randomly chosen set of k inputs canalizes the function,
i.e., forces the output regardless of the remaining variables.</p>
<dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p>k (int): The size of the variable set (0 ≤ k ≤ n).</p></li>
<li><p>left_side_of_truth_table (optional, array-like): Precomputed left-hand side of the truth table (2^n x n). If not provided or if its shape does not match, it will be computed.</p></li>
<li><p>verbose (bool, optional): If True, prints detailed information about canalizing k-sets.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float: The proportion of k-set canalizing input sets.</p></li>
</ul>
</dd>
<dt>References:</dt><dd><p>Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023). Collectively canalizing Boolean functions.
Advances in Applied Mathematics, 145, 102475.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.get_symmetry_groups">
<span class="sig-name descname"><span class="pre">get_symmetry_groups</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_side_of_truth_table</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.get_symmetry_groups"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.get_symmetry_groups" title="Link to this definition"></a></dt>
<dd><p>Determine all symmetry groups of input variables for a Boolean function.</p>
<p>Two variables are in the same symmetry group if swapping their values does not change the output
of the function for any input of the other variables.</p>
<dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p>left_side_of_truth_table (optional, array-like): Precomputed left-hand side of the truth table (2^n x n). If not provided or if its shape does not match, it will be computed.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>list: A list of lists where each inner list contains indices of variables that form a symmetry group.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.is_canalizing">
<span class="sig-name descname"><span class="pre">is_canalizing</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.is_canalizing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.is_canalizing" title="Link to this definition"></a></dt>
<dd><p>Determine if a Boolean function is canalizing.</p>
<p>A Boolean function f(x_1, …, x_n) is canalizing if there exists at least one variable x_i and a value a ∈ {0, 1} 
such that f(x_1, …, x_i = a, …, x_n) is constant.</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>bool: True if f is canalizing, False otherwise.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.is_constant">
<span class="sig-name descname"><span class="pre">is_constant</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.is_constant"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.is_constant" title="Link to this definition"></a></dt>
<dd><p>Check whether a Boolean function is constant.</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>bool: True if f is constant (all outputs are 0 or all are 1), False otherwise.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.is_degenerated">
<span class="sig-name descname"><span class="pre">is_degenerated</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.is_degenerated"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.is_degenerated" title="Link to this definition"></a></dt>
<dd><p>Determine if a Boolean function contains non-essential variables.</p>
<p>A variable is non-essential if the function’s output does not depend on it.</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>bool: True if f contains at least one non-essential variable, False if all variables are essential.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.is_k_canalizing">
<span class="sig-name descname"><span class="pre">is_k_canalizing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.is_k_canalizing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.is_k_canalizing" title="Link to this definition"></a></dt>
<dd><p>Determine if a Boolean function is k-canalizing.</p>
<p>A Boolean function is k-canalizing if it has at least k conditionally canalizing variables.
This is checked recursively: after fixing a canalizing variable (with a fixed canalizing input that forces the output),
the subfunction (core function) must itself be canalizing for the next variable, and so on.</p>
<dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p>k (int): The desired canalizing depth (0 ≤ k ≤ n). Note: every function is 0-canalizing.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>bool: True if f is k-canalizing, False otherwise.</p></li>
</ul>
</dd>
<dt>References:</dt><dd><dl class="simple">
<dt>He, Q., &amp; Macauley, M. (2016). Stratification and enumeration of Boolean functions by canalizing depth.</dt><dd><p>Physica D: Nonlinear Phenomena, 314, 1-8.</p>
</dd>
<dt>Dimitrova, E., Stigler, B., Kadelka, C., &amp; Murrugarra, D. (2022). Revealing the canalizing structure of Boolean functions:</dt><dd><p>Algorithms and applications. Automatica, 146, 110630.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.is_kset_canalizing">
<span class="sig-name descname"><span class="pre">is_kset_canalizing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left_side_of_truth_table</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.is_kset_canalizing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.is_kset_canalizing" title="Link to this definition"></a></dt>
<dd><p>Determine if a Boolean function is k-set canalizing.</p>
<p>A Boolean function is k-set canalizing if there exists a set of k variables such that setting these variables to specific values
forces the output of the function, irrespective of the other n - k inputs.</p>
<dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p>k (int): The size of the variable set (with 0 ≤ k ≤ n).</p></li>
<li><p>left_side_of_truth_table (optional, array-like): Precomputed left-hand side of the truth table (2^n x n). If not provided or if its shape does not match, it will be computed.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>bool: True if f is k-set canalizing, False otherwise.</p></li>
</ul>
</dd>
<dt>References:</dt><dd><p>Kadelka, C., Keilty, B., &amp; Laubenbacher, R. (2023). Collectively canalizing Boolean functions.
Advances in Applied Mathematics, 145, 102475.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.is_monotonic">
<span class="sig-name descname"><span class="pre">is_monotonic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">GET_DETAILS</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.is_monotonic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.is_monotonic" title="Link to this definition"></a></dt>
<dd><p>Determine if a Boolean function is monotonic.</p>
<p>A Boolean function is monotonic if it is monotonic in each variable. 
That is, if for all i=1,…,n: f(x_1,…,x_i=0,…,x_n) &gt;= f(x_1,…,x_i=1,…,x_n) for all (x_1,…,x_n) or f(x_1,…,x_i=0,…,x_n) &lt;= f(x_1,…,x_i=1,…,x_n) for all (x_1,…,x_n)</p>
<dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p>GET_DETAILS (bool, optional): If True, the type of each variable (increasing, decreasing, not monotonic, not essential) is returned.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>bool: True if f contains at least one non-essential variable, False if all variables are essential.</p></li>
<li><p>list: List containing the type of regulation of each variable. Only returned if GET_DETAILS==True.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.BooleanFunction.to_cana_BooleanNode">
<span class="sig-name descname"><span class="pre">to_cana_BooleanNode</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#BooleanFunction.to_cana_BooleanNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.BooleanFunction.to_cana_BooleanNode" title="Link to this definition"></a></dt>
<dd><p>Compatability method: Transforms an instance of this class to an instance of cana.boolean_node.BooleanNode</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>An instance of cana.boolean_node.BooleanNode</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.cana_BooleanNode_to_BooleanFunction">
<span class="sig-prename descclassname"><span class="pre">BNToolbox.boolean_function.</span></span><span class="sig-name descname"><span class="pre">cana_BooleanNode_to_BooleanFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">BooleanNode</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#cana_BooleanNode_to_BooleanFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.cana_BooleanNode_to_BooleanFunction" title="Link to this definition"></a></dt>
<dd><p>Compatability method: Transforms an instance of cana.boolean_node.BooleanNode to an instance of the class BooleanFunction, used in this toolbox.</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>An instance of BooleanFunction</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="BNToolbox.boolean_function.get_layer_structure_from_can_outputs">
<span class="sig-prename descclassname"><span class="pre">BNToolbox.boolean_function.</span></span><span class="sig-name descname"><span class="pre">get_layer_structure_from_can_outputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">can_outputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/BNToolbox/boolean_function.html#get_layer_structure_from_can_outputs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#BNToolbox.boolean_function.get_layer_structure_from_can_outputs" title="Link to this definition"></a></dt>
<dd></dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Home" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="bn.html" class="btn btn-neutral float-right" title="Boolean Network" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Claus Kadelka, Benjamin Coberly.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
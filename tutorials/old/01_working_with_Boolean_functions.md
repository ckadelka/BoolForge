# BoolForge Tutorial #1: Working with Boolean functions

In this tutorial, we will explore the `BooleanFunction` class — the foundation of BoolForge.
You will learn how to:
- create Boolean functions from truth tables and text expressions,
- compute basic properties such as degree and bias, and
- convert between truth tables, logical expressions, polynomials, and the CANA package.

Boolean functions form the regulatory rules in Boolean network models of gene regulation, so understanding their structure is essential before studying networks.


```python
import boolforge
import numpy as np
```

## Create a Boolean function 

Boolean functions can be described in logical form, as polynomials, or as truth tables. BoolForge treats Boolean functions as binary vectors of length $2^n$, where n is the number of inputs. The vectors describe the right side of the truth table. The left side of the truth table is not stored because it is the same for any function with n inputs. For example, the function f(A,B) = A AND B is stored as [0,0,0,1], which is exactly the right side of the truth table
<div align="center">

| A | B | f(A,B) |
| :-: | :-: | :-: |
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

</div>

### Create a Boolean function from truth table

An instance of `BooleanFunction` can be generated by specifying the right side of the truth table, i.e., by providing a binary vector of length $2^n$ for any $n\geq 0$. For example, to create the AND function above, we can write


```python
# Define a simple Boolean function f(A,B) = A AND B with optional name 'f_AND'
f = boolforge.BooleanFunction([0, 0, 0, 1], name="f_AND")
print('f',f)
print('truth table of f:\n',f.to_truth_table())
```

    f [0 0 0 1]
    truth table of f:
        x0  x1  f_AND
    0   0   0      0
    1   0   1      0
    2   1   0      0
    3   1   1      1


### Create a Boolean function from text

Instances of `BooleanFunction` can also be created from text. For example, to define the same function as f, we can write


```python
f2 = boolforge.BooleanFunction('A and B')
print('f2',f2)
```

    f2 [0 0 0 1]


The text processor is fairly versatile. For example, we can define the same function as f also by writing



```python
f3 = boolforge.BooleanFunction('A + B > 1')
print('f3',f3)
```

    f3 [0 0 0 1]


Some examples of more complicated functions include


```python
# Define a 3-input function without any symmetries
g = boolforge.BooleanFunction('(A AND B) OR (NOT A AND C)')

# Define a 3-input linear / parity function 
h = boolforge.BooleanFunction('(x + y + z) % 2 == 0')

# Define a 3-input threshold function
k = boolforge.BooleanFunction('x + y - z > 0')

labels = ['g','h','k']
boolforge.display_truth_table(g,h,k,labels=labels)
```

    x1	x2	x3	|	g	h	k
    -------------------------------------------------
    0	0	0	|	0	1	0
    0	0	1	|	1	0	1
    0	1	0	|	0	0	1
    0	1	1	|	1	1	0
    1	0	0	|	0	0	1
    1	0	1	|	0	1	0
    1	1	0	|	1	1	1
    1	1	1	|	1	0	1


### Creating Boolean functions by combining existing BooleanFunction objects

BoolForge also allows you to construct new Boolean functions by combining
existing ones using Boolean algebra operations.  
This is useful when building larger rules from simpler components.

Supported operations include:
- `+` for addition modulo 2
- `&` for logical AND  
- `|` for logical OR  
- `^` for XOR  
- `~` for NOT

Here are a few examples:


```python
a = boolforge.BooleanFunction("X + Y == 1")
b = boolforge.BooleanFunction("X OR Y")

# Negation: ¬A
not_a = ~a

# AND: A ∨ B
a_and_b = a & b

# AND: A ∧ B
a_or_b = a | b

# XOR: A ⊕ B
a_xor_b = a ^ b

labels = ['a','b','not a','a AND b','a OR b','a XOR b']
boolforge.display_truth_table(a,b,a_and_b,a_or_b,a_xor_b,not_a,labels=labels)

```

    x1	x2	|	a	b	not a	a AND b	a OR b	a XOR b
    -----------------------------------------------------------------------
    0	0	|	0	0	0	0	0	1
    0	1	|	1	1	1	1	0	0
    1	0	|	1	1	1	1	0	0
    1	1	|	0	1	0	1	1	1


## Attributes of BooleanFunction

Every instance of `BooleanFunction` has five attributes:
<div align="center">

| attribute | data type | description | 
| :-: | :-: | :- | 
| f | np.array(int) | stores the Boolean function (the right side of its truth table) |
| n | int | the degree, i.e., the number of variables |
| variables | np.array(str) | the name of the variables. By default, $x_0, \ldots, x_{n-1}$ | 
| name | str | optional, default '' |
| properties | dict | stores certain properties of the function as they are computed |

</div>


```python
print('f.f',f.f)
print('f.n',f.n)
print('f.variables',f.variables)
print('f.name',f.name)
print('f.properties',f.properties)
```

    f.f [0 0 0 1]
    f.n 2
    f.variables ['x0' 'x1']
    f.name f_AND
    f.properties {}


Since `f` was generated from truth table, its variables default to $x_0, x_1$. On the contrary, generating instances of `BooleanFunction` from text also provides the variable names. This becomes important when reading from text files entire Boolean networks, i.e., collections of Boolean functions. For example, for `f2`, `f3`, `g`, and `h`, we have:


```python
print('f2.variables',f2.variables)
print('f3.variables',f3.variables)
print('g.variables',g.variables)
print('h.variables',h.variables)

```

    f2.variables ['A' 'B']
    f3.variables ['A' 'B']
    g.variables ['A' 'B' 'C']
    h.variables ['x' 'y' 'z']


The variable order is determined by the first occurence of the variable in the generating text. See e.g.,


```python
print(boolforge.BooleanFunction('(x + y + z) % 2 == 0').variables)
print(boolforge.BooleanFunction('(y + z + x) % 2 == 0').variables)
```

    ['x' 'y' 'z']
    ['y' 'z' 'x']


The variable order determines how the truth table is indexed. For example, for variables [x,y,z], the entry in position i corresponds to the binary expansion of i over 
(x,y,z). Therefore, the same expression with a different variable order results in a different right-side truth table ordering. This becomes important when combining functions inside networks or importing networks from text files.

## Basic properties of Boolean functions

We can inspect various properties of a Boolean function. The degree, i.e., the number of inputs, is readily available via 'f.n'. Other properties can be computed.


```python
print("Number of variables:", f.n)
print("Is constant?", f.is_constant())
print("Is degenerate?", f.is_degenerate())
print("Indices of essential variables:", f.get_essential_variables())
print("Type of inputs:", f.get_type_of_inputs())
print("Hamming weight:", f.get_hamming_weight())
print("Absolute bias:", f.get_absolute_bias())
```

    Number of variables: 2
    Is constant? False
    Is degenerate? False
    Indices of essential variables: [0, 1]
    Type of inputs: ['positive' 'positive']
    Hamming weight: 1
    Absolute bias: 0.5


Rerunning the above code for `g` helps understand the different properties. 
- 'g.is_constant()' checks if the function is constant, 
- 'g.is_degenerate()' checks if the function contains non-essential variables, 
- 'g.get_essential_variables()' provides the indices (Python: starting at 0!) of the essential variables, 
- 'g.get_type_of_inputs()' describes the type of each input ('increasing','decreasing','conditional', or 'non-essential').
- The Hamming weight is the number of 1s in the right side of the truth table.
- The absolute bias is $|\text{\#ones} - \text{\#zeros}| / 2^n$. It equals 1 for constant functions and 0 for unbiased functions.



```python
print("Number of variables:", g.n)
print("Is constant?", g.is_constant())
print("Is degenerate?", g.is_degenerate())
print("Indices of essential variables:", g.get_essential_variables())
print("Type of inputs:", g.get_type_of_inputs())
print("Hamming weight:", g.get_hamming_weight())
print("Absolute bias:", g.get_absolute_bias())
```

    Number of variables: 3
    Is constant? False
    Is degenerate? False
    Indices of essential variables: [0, 1, 2]
    Type of inputs: ['positive' 'positive' 'conditional']
    Hamming weight: 4
    Absolute bias: 0.0


## Convert to logical and polynomial expression

While Boolean functions are stored as truth tables, they can be expressed in logical and polynomial format.


```python
print(f"Logical form of {f.name}:", f.to_logical(AND=' ∧ ', OR=' ∨ ', NOT=' ¬'))
print(f"Polynomial form of {f.name}:", f.to_polynomial())
```

    Logical form of f_AND: x0 ∧ x1
    Polynomial form of f_AND: x0 * x1


In addition, an instance of `BooleanFunction` can be turned into an instance of `BooleanNode` from the [CANA package](https:www.github.com). This requires the optional CANA package to be installed.


```python
cana_object = f.to_cana()
print(type(cana_object))
```

    <class 'cana.boolean_node.BooleanNode'>


## Summary of Key Concepts

Before moving on to more advanced topics, here is a short summary of the
fundamental ideas introduced in this tutorial:

### **Boolean functions**
A Boolean function maps a set of binary inputs (0/1) to a single binary output.
BoolForge represents Boolean functions internally by their truth table, i.e.,
the list of outputs in lexicographic order of the input combinations.

### **Representations of Boolean functions**
Boolean functions can be created from:
- a truth table (list of 0s and 1s),
- a logical expression written in Python syntax,
- algebraic combinations of existing BooleanFunction objects using operations such as  
  `+` (OR), `*` (AND), `^` (XOR), and other supported Boolean operations.

Each representation produces an equivalent internal truth-table-based object.

### **Variable names and ordering**
BoolForge automatically infers variable names from the order of first appearance
in expressions.  
This order determines the indexing of the truth table and therefore affects how
the function interacts with larger Boolean networks.

### **Basic properties of Boolean functions**
BoolForge can compute structural properties, including:
- the number of variables (`n`),
- the Hamming weight (number of 1s in the truth table),
- absolute bias (imbalance between 0s and 1s),
- essential and non-essential variables,
- positive/negative influence of each input.

These properties help characterize the function’s behavior and are used
throughout later tutorials.

### **Conversions and interoperability**
BoolForge supports conversion between representations (e.g., truth table ↔
polynomial form) and is compatible with external packages such as **CANA** for
advanced analysis.  
This makes it easy to move between analytical frameworks and reuse models.

---

Together, these concepts provide the foundation for understanding canalization,
random Boolean function generation, and eventually the construction and analysis
of full Boolean networks.

## Frequently Asked Questions (FAQ)

### **1. Why does the order of variables matter?**
The order in which variables appear determines the ordering of the truth table.
For a function with variables `[A, B, C]`, the entry at position `i` corresponds
to the binary representation of `i` over `(A, B, C)`.  
If two equivalent expressions list variables in different orders, their truth
tables will be indexed differently.

To ensure reproducibility, always use consistent variable names and ordering.

### **2. How do I choose between defining a function via a truth table or via an expression?**
Use a **truth table** if:
- you want full control over the outputs,
- you generated the table programmatically,
- or a biological dataset already provides the output values.

Use a **textual expression** if:
- the function has a natural logical description (e.g., `A and B`),
- you want readability,
- or you want BoolForge to automatically determine variables.

Both methods produce identical internal representations.

### **3. How do I control the variable names for a truth-table–defined function?**
By default, BoolForge assigns names `x0, x1, ...`.

If you want custom variable names, specify them explicitly:


```python
boolforge.BooleanFunction([0,0,0,1], variables=["A", "B"])
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    Cell In[26], line 1
    ----> 1 boolforge.BooleanFunction([0,0,0,1], variables=["A", "B"])


    TypeError: BooleanFunction.__init__() got an unexpected keyword argument 'variables'


### **4. Can I see all properties of a Boolean function at once?**
Yes. The .summary() method prints all basic properties, while the properties dictionary lists precomputed and cached properties, such as various computation-intensive canalizing properties, discussed in detail in Tutorial #3:


```python
f = boolforge.BooleanFunction("(A and B) OR C")
#print(f"f.summary():\n {f.summary()}")

f.get_layer_structure()
print("f.properties:")
for key in f.properties:
    print(key,f.properties[key])

```

    f.properties:
    CanalizingDepth 3
    NumberOfLayers 2
    CanalizingInputs [1 0 0]
    CanalizedOutputs [1 0 0]
    CoreFunction [1]
    OrderOfCanalizingVariables [2 0 1]
    LayerStructure [1, 2]


5. What is the difference between get_type_of_inputs() and monotonicity?
get_type_of_inputs() identifies whether each input variable influences the
function positively, negatively, or not at all.
Monotonicity is a global property describing whether all inputs influence the
output in a consistent direction.
A function can have mixed input types and therefore be non-monotone, even if
individual inputs have clear influence types.
